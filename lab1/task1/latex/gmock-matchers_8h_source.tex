\doxysection{gmock-\/matchers.h}
\hypertarget{gmock-matchers_8h_source}{}\label{gmock-matchers_8h_source}\index{googletest/googlemock/include/gmock/gmock-\/matchers.h@{googletest/googlemock/include/gmock/gmock-\/matchers.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ Copyright\ 2007,\ Google\ Inc.}}
\DoxyCodeLine{00002\ \textcolor{comment}{//\ All\ rights\ reserved.}}
\DoxyCodeLine{00003\ \textcolor{comment}{//}}
\DoxyCodeLine{00004\ \textcolor{comment}{//\ Redistribution\ and\ use\ in\ source\ and\ binary\ forms,\ with\ or\ without}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ modification,\ are\ permitted\ provided\ that\ the\ following\ conditions\ are}}
\DoxyCodeLine{00006\ \textcolor{comment}{//\ met:}}
\DoxyCodeLine{00007\ \textcolor{comment}{//}}
\DoxyCodeLine{00008\ \textcolor{comment}{//\ \ \ \ \ *\ Redistributions\ of\ source\ code\ must\ retain\ the\ above\ copyright}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ notice,\ this\ list\ of\ conditions\ and\ the\ following\ disclaimer.}}
\DoxyCodeLine{00010\ \textcolor{comment}{//\ \ \ \ \ *\ Redistributions\ in\ binary\ form\ must\ reproduce\ the\ above}}
\DoxyCodeLine{00011\ \textcolor{comment}{//\ copyright\ notice,\ this\ list\ of\ conditions\ and\ the\ following\ disclaimer}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ in\ the\ documentation\ and/or\ other\ materials\ provided\ with\ the}}
\DoxyCodeLine{00013\ \textcolor{comment}{//\ distribution.}}
\DoxyCodeLine{00014\ \textcolor{comment}{//\ \ \ \ \ *\ Neither\ the\ name\ of\ Google\ Inc.\ nor\ the\ names\ of\ its}}
\DoxyCodeLine{00015\ \textcolor{comment}{//\ contributors\ may\ be\ used\ to\ endorse\ or\ promote\ products\ derived\ from}}
\DoxyCodeLine{00016\ \textcolor{comment}{//\ this\ software\ without\ specific\ prior\ written\ permission.}}
\DoxyCodeLine{00017\ \textcolor{comment}{//}}
\DoxyCodeLine{00018\ \textcolor{comment}{//\ THIS\ SOFTWARE\ IS\ PROVIDED\ BY\ THE\ COPYRIGHT\ HOLDERS\ AND\ CONTRIBUTORS}}
\DoxyCodeLine{00019\ \textcolor{comment}{//\ "{}AS\ IS"{}\ AND\ ANY\ EXPRESS\ OR\ IMPLIED\ WARRANTIES,\ INCLUDING,\ BUT\ NOT}}
\DoxyCodeLine{00020\ \textcolor{comment}{//\ LIMITED\ TO,\ THE\ IMPLIED\ WARRANTIES\ OF\ MERCHANTABILITY\ AND\ FITNESS\ FOR}}
\DoxyCodeLine{00021\ \textcolor{comment}{//\ A\ PARTICULAR\ PURPOSE\ ARE\ DISCLAIMED.\ IN\ NO\ EVENT\ SHALL\ THE\ COPYRIGHT}}
\DoxyCodeLine{00022\ \textcolor{comment}{//\ OWNER\ OR\ CONTRIBUTORS\ BE\ LIABLE\ FOR\ ANY\ DIRECT,\ INDIRECT,\ INCIDENTAL,}}
\DoxyCodeLine{00023\ \textcolor{comment}{//\ SPECIAL,\ EXEMPLARY,\ OR\ CONSEQUENTIAL\ DAMAGES\ (INCLUDING,\ BUT\ NOT}}
\DoxyCodeLine{00024\ \textcolor{comment}{//\ LIMITED\ TO,\ PROCUREMENT\ OF\ SUBSTITUTE\ GOODS\ OR\ SERVICES;\ LOSS\ OF\ USE,}}
\DoxyCodeLine{00025\ \textcolor{comment}{//\ DATA,\ OR\ PROFITS;\ OR\ BUSINESS\ INTERRUPTION)\ HOWEVER\ CAUSED\ AND\ ON\ ANY}}
\DoxyCodeLine{00026\ \textcolor{comment}{//\ THEORY\ OF\ LIABILITY,\ WHETHER\ IN\ CONTRACT,\ STRICT\ LIABILITY,\ OR\ TORT}}
\DoxyCodeLine{00027\ \textcolor{comment}{//\ (INCLUDING\ NEGLIGENCE\ OR\ OTHERWISE)\ ARISING\ IN\ ANY\ WAY\ OUT\ OF\ THE\ USE}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ OF\ THIS\ SOFTWARE,\ EVEN\ IF\ ADVISED\ OF\ THE\ POSSIBILITY\ OF\ SUCH\ DAMAGE.}}
\DoxyCodeLine{00029\ }
\DoxyCodeLine{00030\ \textcolor{comment}{//\ Google\ Mock\ -\/\ a\ framework\ for\ writing\ C++\ mock\ classes.}}
\DoxyCodeLine{00031\ \textcolor{comment}{//}}
\DoxyCodeLine{00032\ \textcolor{comment}{//\ The\ MATCHER*\ family\ of\ macros\ can\ be\ used\ in\ a\ namespace\ scope\ to}}
\DoxyCodeLine{00033\ \textcolor{comment}{//\ define\ custom\ matchers\ easily.}}
\DoxyCodeLine{00034\ \textcolor{comment}{//}}
\DoxyCodeLine{00035\ \textcolor{comment}{//\ Basic\ Usage}}
\DoxyCodeLine{00036\ \textcolor{comment}{//\ ===========}}
\DoxyCodeLine{00037\ \textcolor{comment}{//}}
\DoxyCodeLine{00038\ \textcolor{comment}{//\ The\ syntax}}
\DoxyCodeLine{00039\ \textcolor{comment}{//}}
\DoxyCodeLine{00040\ \textcolor{comment}{//\ \ \ MATCHER(name,\ description\_string)\ \{\ statements;\ \}}}
\DoxyCodeLine{00041\ \textcolor{comment}{//}}
\DoxyCodeLine{00042\ \textcolor{comment}{//\ defines\ a\ matcher\ with\ the\ given\ name\ that\ executes\ the\ statements,}}
\DoxyCodeLine{00043\ \textcolor{comment}{//\ which\ must\ return\ a\ bool\ to\ indicate\ if\ the\ match\ succeeds.\ \ Inside}}
\DoxyCodeLine{00044\ \textcolor{comment}{//\ the\ statements,\ you\ can\ refer\ to\ the\ value\ being\ matched\ by\ 'arg',}}
\DoxyCodeLine{00045\ \textcolor{comment}{//\ and\ refer\ to\ its\ type\ by\ 'arg\_type'.}}
\DoxyCodeLine{00046\ \textcolor{comment}{//}}
\DoxyCodeLine{00047\ \textcolor{comment}{//\ The\ description\ string\ documents\ what\ the\ matcher\ does,\ and\ is\ used}}
\DoxyCodeLine{00048\ \textcolor{comment}{//\ to\ generate\ the\ failure\ message\ when\ the\ match\ fails.\ \ Since\ a}}
\DoxyCodeLine{00049\ \textcolor{comment}{//\ MATCHER()\ is\ usually\ defined\ in\ a\ header\ file\ shared\ by\ multiple}}
\DoxyCodeLine{00050\ \textcolor{comment}{//\ C++\ source\ files,\ we\ require\ the\ description\ to\ be\ a\ C-\/string}}
\DoxyCodeLine{00051\ \textcolor{comment}{//\ literal\ to\ avoid\ possible\ side\ effects.\ \ It\ can\ be\ empty,\ in\ which}}
\DoxyCodeLine{00052\ \textcolor{comment}{//\ case\ we'll\ use\ the\ sequence\ of\ words\ in\ the\ matcher\ name\ as\ the}}
\DoxyCodeLine{00053\ \textcolor{comment}{//\ description.}}
\DoxyCodeLine{00054\ \textcolor{comment}{//}}
\DoxyCodeLine{00055\ \textcolor{comment}{//\ For\ example:}}
\DoxyCodeLine{00056\ \textcolor{comment}{//}}
\DoxyCodeLine{00057\ \textcolor{comment}{//\ \ \ MATCHER(IsEven,\ "{}"{})\ \{\ return\ (arg\ \%\ 2)\ ==\ 0;\ \}}}
\DoxyCodeLine{00058\ \textcolor{comment}{//}}
\DoxyCodeLine{00059\ \textcolor{comment}{//\ allows\ you\ to\ write}}
\DoxyCodeLine{00060\ \textcolor{comment}{//}}
\DoxyCodeLine{00061\ \textcolor{comment}{//\ \ \ //\ Expects\ mock\_foo.Bar(n)\ to\ be\ called\ where\ n\ is\ even.}}
\DoxyCodeLine{00062\ \textcolor{comment}{//\ \ \ EXPECT\_CALL(mock\_foo,\ Bar(IsEven()));}}
\DoxyCodeLine{00063\ \textcolor{comment}{//}}
\DoxyCodeLine{00064\ \textcolor{comment}{//\ or,}}
\DoxyCodeLine{00065\ \textcolor{comment}{//}}
\DoxyCodeLine{00066\ \textcolor{comment}{//\ \ \ //\ Verifies\ that\ the\ value\ of\ some\_expression\ is\ even.}}
\DoxyCodeLine{00067\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(some\_expression,\ IsEven());}}
\DoxyCodeLine{00068\ \textcolor{comment}{//}}
\DoxyCodeLine{00069\ \textcolor{comment}{//\ If\ the\ above\ assertion\ fails,\ it\ will\ print\ something\ like:}}
\DoxyCodeLine{00070\ \textcolor{comment}{//}}
\DoxyCodeLine{00071\ \textcolor{comment}{//\ \ \ Value\ of:\ some\_expression}}
\DoxyCodeLine{00072\ \textcolor{comment}{//\ \ \ Expected:\ is\ even}}
\DoxyCodeLine{00073\ \textcolor{comment}{//\ \ \ \ \ Actual:\ 7}}
\DoxyCodeLine{00074\ \textcolor{comment}{//}}
\DoxyCodeLine{00075\ \textcolor{comment}{//\ where\ the\ description\ "{}is\ even"{}\ is\ automatically\ calculated\ from\ the}}
\DoxyCodeLine{00076\ \textcolor{comment}{//\ matcher\ name\ IsEven.}}
\DoxyCodeLine{00077\ \textcolor{comment}{//}}
\DoxyCodeLine{00078\ \textcolor{comment}{//\ Argument\ Type}}
\DoxyCodeLine{00079\ \textcolor{comment}{//\ =============}}
\DoxyCodeLine{00080\ \textcolor{comment}{//}}
\DoxyCodeLine{00081\ \textcolor{comment}{//\ Note\ that\ the\ type\ of\ the\ value\ being\ matched\ (arg\_type)\ is}}
\DoxyCodeLine{00082\ \textcolor{comment}{//\ determined\ by\ the\ context\ in\ which\ you\ use\ the\ matcher\ and\ is}}
\DoxyCodeLine{00083\ \textcolor{comment}{//\ supplied\ to\ you\ by\ the\ compiler,\ so\ you\ don't\ need\ to\ worry\ about}}
\DoxyCodeLine{00084\ \textcolor{comment}{//\ declaring\ it\ (nor\ can\ you).\ \ This\ allows\ the\ matcher\ to\ be}}
\DoxyCodeLine{00085\ \textcolor{comment}{//\ polymorphic.\ \ For\ example,\ IsEven()\ can\ be\ used\ to\ match\ any\ type}}
\DoxyCodeLine{00086\ \textcolor{comment}{//\ where\ the\ value\ of\ "{}(arg\ \%\ 2)\ ==\ 0"{}\ can\ be\ implicitly\ converted\ to}}
\DoxyCodeLine{00087\ \textcolor{comment}{//\ a\ bool.\ \ In\ the\ "{}Bar(IsEven())"{}\ example\ above,\ if\ method\ Bar()}}
\DoxyCodeLine{00088\ \textcolor{comment}{//\ takes\ an\ int,\ 'arg\_type'\ will\ be\ int;\ if\ it\ takes\ an\ unsigned\ long,}}
\DoxyCodeLine{00089\ \textcolor{comment}{//\ 'arg\_type'\ will\ be\ unsigned\ long;\ and\ so\ on.}}
\DoxyCodeLine{00090\ \textcolor{comment}{//}}
\DoxyCodeLine{00091\ \textcolor{comment}{//\ Parameterizing\ Matchers}}
\DoxyCodeLine{00092\ \textcolor{comment}{//\ =======================}}
\DoxyCodeLine{00093\ \textcolor{comment}{//}}
\DoxyCodeLine{00094\ \textcolor{comment}{//\ Sometimes\ you'll\ want\ to\ parameterize\ the\ matcher.\ \ For\ that\ you}}
\DoxyCodeLine{00095\ \textcolor{comment}{//\ can\ use\ another\ macro:}}
\DoxyCodeLine{00096\ \textcolor{comment}{//}}
\DoxyCodeLine{00097\ \textcolor{comment}{//\ \ \ MATCHER\_P(name,\ param\_name,\ description\_string)\ \{\ statements;\ \}}}
\DoxyCodeLine{00098\ \textcolor{comment}{//}}
\DoxyCodeLine{00099\ \textcolor{comment}{//\ For\ example:}}
\DoxyCodeLine{00100\ \textcolor{comment}{//}}
\DoxyCodeLine{00101\ \textcolor{comment}{//\ \ \ MATCHER\_P(HasAbsoluteValue,\ value,\ "{}"{})\ \{\ return\ abs(arg)\ ==\ value;\ \}}}
\DoxyCodeLine{00102\ \textcolor{comment}{//}}
\DoxyCodeLine{00103\ \textcolor{comment}{//\ will\ allow\ you\ to\ write:}}
\DoxyCodeLine{00104\ \textcolor{comment}{//}}
\DoxyCodeLine{00105\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(Blah("{}a"{}),\ HasAbsoluteValue(n));}}
\DoxyCodeLine{00106\ \textcolor{comment}{//}}
\DoxyCodeLine{00107\ \textcolor{comment}{//\ which\ may\ lead\ to\ this\ message\ (assuming\ n\ is\ 10):}}
\DoxyCodeLine{00108\ \textcolor{comment}{//}}
\DoxyCodeLine{00109\ \textcolor{comment}{//\ \ \ Value\ of:\ Blah("{}a"{})}}
\DoxyCodeLine{00110\ \textcolor{comment}{//\ \ \ Expected:\ has\ absolute\ value\ 10}}
\DoxyCodeLine{00111\ \textcolor{comment}{//\ \ \ \ \ Actual:\ -\/9}}
\DoxyCodeLine{00112\ \textcolor{comment}{//}}
\DoxyCodeLine{00113\ \textcolor{comment}{//\ Note\ that\ both\ the\ matcher\ description\ and\ its\ parameter\ are}}
\DoxyCodeLine{00114\ \textcolor{comment}{//\ printed,\ making\ the\ message\ human-\/friendly.}}
\DoxyCodeLine{00115\ \textcolor{comment}{//}}
\DoxyCodeLine{00116\ \textcolor{comment}{//\ In\ the\ matcher\ definition\ body,\ you\ can\ write\ 'foo\_type'\ to}}
\DoxyCodeLine{00117\ \textcolor{comment}{//\ reference\ the\ type\ of\ a\ parameter\ named\ 'foo'.\ \ For\ example,\ in\ the}}
\DoxyCodeLine{00118\ \textcolor{comment}{//\ body\ of\ MATCHER\_P(HasAbsoluteValue,\ value)\ above,\ you\ can\ write}}
\DoxyCodeLine{00119\ \textcolor{comment}{//\ 'value\_type'\ to\ refer\ to\ the\ type\ of\ 'value'.}}
\DoxyCodeLine{00120\ \textcolor{comment}{//}}
\DoxyCodeLine{00121\ \textcolor{comment}{//\ We\ also\ provide\ MATCHER\_P2,\ MATCHER\_P3,\ ...,\ up\ to\ MATCHER\_P\$n\ to}}
\DoxyCodeLine{00122\ \textcolor{comment}{//\ support\ multi-\/parameter\ matchers.}}
\DoxyCodeLine{00123\ \textcolor{comment}{//}}
\DoxyCodeLine{00124\ \textcolor{comment}{//\ Describing\ Parameterized\ Matchers}}
\DoxyCodeLine{00125\ \textcolor{comment}{//\ =================================}}
\DoxyCodeLine{00126\ \textcolor{comment}{//}}
\DoxyCodeLine{00127\ \textcolor{comment}{//\ The\ last\ argument\ to\ MATCHER*()\ is\ a\ string-\/typed\ expression.\ \ The}}
\DoxyCodeLine{00128\ \textcolor{comment}{//\ expression\ can\ reference\ all\ of\ the\ matcher's\ parameters\ and\ a}}
\DoxyCodeLine{00129\ \textcolor{comment}{//\ special\ bool-\/typed\ variable\ named\ 'negation'.\ \ When\ 'negation'\ is}}
\DoxyCodeLine{00130\ \textcolor{comment}{//\ false,\ the\ expression\ should\ evaluate\ to\ the\ matcher's\ description;}}
\DoxyCodeLine{00131\ \textcolor{comment}{//\ otherwise\ it\ should\ evaluate\ to\ the\ description\ of\ the\ negation\ of}}
\DoxyCodeLine{00132\ \textcolor{comment}{//\ the\ matcher.\ \ For\ example,}}
\DoxyCodeLine{00133\ \textcolor{comment}{//}}
\DoxyCodeLine{00134\ \textcolor{comment}{//\ \ \ using\ testing::PrintToString;}}
\DoxyCodeLine{00135\ \textcolor{comment}{//}}
\DoxyCodeLine{00136\ \textcolor{comment}{//\ \ \ MATCHER\_P2(InClosedRange,\ low,\ hi,}}
\DoxyCodeLine{00137\ \textcolor{comment}{//\ \ \ \ \ \ \ std::string(negation\ ?\ "{}is\ not"{}\ :\ "{}is"{})\ +\ "{}\ in\ range\ ["{}\ +}}
\DoxyCodeLine{00138\ \textcolor{comment}{//\ \ \ \ \ \ \ PrintToString(low)\ +\ "{},\ "{}\ +\ PrintToString(hi)\ +\ "{}]"{})\ \{}}
\DoxyCodeLine{00139\ \textcolor{comment}{//\ \ \ \ \ return\ low\ <=\ arg\ \&\&\ arg\ <=\ hi;}}
\DoxyCodeLine{00140\ \textcolor{comment}{//\ \ \ \}}}
\DoxyCodeLine{00141\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00142\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ InClosedRange(4,\ 6));}}
\DoxyCodeLine{00143\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ Not(InClosedRange(2,\ 4)));}}
\DoxyCodeLine{00144\ \textcolor{comment}{//}}
\DoxyCodeLine{00145\ \textcolor{comment}{//\ would\ generate\ two\ failures\ that\ contain\ the\ text:}}
\DoxyCodeLine{00146\ \textcolor{comment}{//}}
\DoxyCodeLine{00147\ \textcolor{comment}{//\ \ \ Expected:\ is\ in\ range\ [4,\ 6]}}
\DoxyCodeLine{00148\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00149\ \textcolor{comment}{//\ \ \ Expected:\ is\ not\ in\ range\ [2,\ 4]}}
\DoxyCodeLine{00150\ \textcolor{comment}{//}}
\DoxyCodeLine{00151\ \textcolor{comment}{//\ If\ you\ specify\ "{}"{}\ as\ the\ description,\ the\ failure\ message\ will}}
\DoxyCodeLine{00152\ \textcolor{comment}{//\ contain\ the\ sequence\ of\ words\ in\ the\ matcher\ name\ followed\ by\ the}}
\DoxyCodeLine{00153\ \textcolor{comment}{//\ parameter\ values\ printed\ as\ a\ tuple.\ \ For\ example,}}
\DoxyCodeLine{00154\ \textcolor{comment}{//}}
\DoxyCodeLine{00155\ \textcolor{comment}{//\ \ \ MATCHER\_P2(InClosedRange,\ low,\ hi,\ "{}"{})\ \{\ ...\ \}}}
\DoxyCodeLine{00156\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00157\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ InClosedRange(4,\ 6));}}
\DoxyCodeLine{00158\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ Not(InClosedRange(2,\ 4)));}}
\DoxyCodeLine{00159\ \textcolor{comment}{//}}
\DoxyCodeLine{00160\ \textcolor{comment}{//\ would\ generate\ two\ failures\ that\ contain\ the\ text:}}
\DoxyCodeLine{00161\ \textcolor{comment}{//}}
\DoxyCodeLine{00162\ \textcolor{comment}{//\ \ \ Expected:\ in\ closed\ range\ (4,\ 6)}}
\DoxyCodeLine{00163\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00164\ \textcolor{comment}{//\ \ \ Expected:\ not\ (in\ closed\ range\ (2,\ 4))}}
\DoxyCodeLine{00165\ \textcolor{comment}{//}}
\DoxyCodeLine{00166\ \textcolor{comment}{//\ Types\ of\ Matcher\ Parameters}}
\DoxyCodeLine{00167\ \textcolor{comment}{//\ ===========================}}
\DoxyCodeLine{00168\ \textcolor{comment}{//}}
\DoxyCodeLine{00169\ \textcolor{comment}{//\ For\ the\ purpose\ of\ typing,\ you\ can\ view}}
\DoxyCodeLine{00170\ \textcolor{comment}{//}}
\DoxyCodeLine{00171\ \textcolor{comment}{//\ \ \ MATCHER\_Pk(Foo,\ p1,\ ...,\ pk,\ description\_string)\ \{\ ...\ \}}}
\DoxyCodeLine{00172\ \textcolor{comment}{//}}
\DoxyCodeLine{00173\ \textcolor{comment}{//\ as\ shorthand\ for}}
\DoxyCodeLine{00174\ \textcolor{comment}{//}}
\DoxyCodeLine{00175\ \textcolor{comment}{//\ \ \ template\ <typename\ p1\_type,\ ...,\ typename\ pk\_type>}}
\DoxyCodeLine{00176\ \textcolor{comment}{//\ \ \ FooMatcherPk<p1\_type,\ ...,\ pk\_type>}}
\DoxyCodeLine{00177\ \textcolor{comment}{//\ \ \ Foo(p1\_type\ p1,\ ...,\ pk\_type\ pk)\ \{\ ...\ \}}}
\DoxyCodeLine{00178\ \textcolor{comment}{//}}
\DoxyCodeLine{00179\ \textcolor{comment}{//\ When\ you\ write\ Foo(v1,\ ...,\ vk),\ the\ compiler\ infers\ the\ types\ of}}
\DoxyCodeLine{00180\ \textcolor{comment}{//\ the\ parameters\ v1,\ ...,\ and\ vk\ for\ you.\ \ If\ you\ are\ not\ happy\ with}}
\DoxyCodeLine{00181\ \textcolor{comment}{//\ the\ result\ of\ the\ type\ inference,\ you\ can\ specify\ the\ types\ by}}
\DoxyCodeLine{00182\ \textcolor{comment}{//\ explicitly\ instantiating\ the\ template,\ as\ in\ Foo<long,\ bool>(5,}}
\DoxyCodeLine{00183\ \textcolor{comment}{//\ false).\ \ As\ said\ earlier,\ you\ don't\ get\ to\ (or\ need\ to)\ specify}}
\DoxyCodeLine{00184\ \textcolor{comment}{//\ 'arg\_type'\ as\ that's\ determined\ by\ the\ context\ in\ which\ the\ matcher}}
\DoxyCodeLine{00185\ \textcolor{comment}{//\ is\ used.\ \ You\ can\ assign\ the\ result\ of\ expression\ Foo(p1,\ ...,\ pk)}}
\DoxyCodeLine{00186\ \textcolor{comment}{//\ to\ a\ variable\ of\ type\ FooMatcherPk<p1\_type,\ ...,\ pk\_type>.\ \ This}}
\DoxyCodeLine{00187\ \textcolor{comment}{//\ can\ be\ useful\ when\ composing\ matchers.}}
\DoxyCodeLine{00188\ \textcolor{comment}{//}}
\DoxyCodeLine{00189\ \textcolor{comment}{//\ While\ you\ can\ instantiate\ a\ matcher\ template\ with\ reference\ types,}}
\DoxyCodeLine{00190\ \textcolor{comment}{//\ passing\ the\ parameters\ by\ pointer\ usually\ makes\ your\ code\ more}}
\DoxyCodeLine{00191\ \textcolor{comment}{//\ readable.\ \ If,\ however,\ you\ still\ want\ to\ pass\ a\ parameter\ by}}
\DoxyCodeLine{00192\ \textcolor{comment}{//\ reference,\ be\ aware\ that\ in\ the\ failure\ message\ generated\ by\ the}}
\DoxyCodeLine{00193\ \textcolor{comment}{//\ matcher\ you\ will\ see\ the\ value\ of\ the\ referenced\ object\ but\ not\ its}}
\DoxyCodeLine{00194\ \textcolor{comment}{//\ address.}}
\DoxyCodeLine{00195\ \textcolor{comment}{//}}
\DoxyCodeLine{00196\ \textcolor{comment}{//\ Explaining\ Match\ Results}}
\DoxyCodeLine{00197\ \textcolor{comment}{//\ ========================}}
\DoxyCodeLine{00198\ \textcolor{comment}{//}}
\DoxyCodeLine{00199\ \textcolor{comment}{//\ Sometimes\ the\ matcher\ description\ alone\ isn't\ enough\ to\ explain\ why}}
\DoxyCodeLine{00200\ \textcolor{comment}{//\ the\ match\ has\ failed\ or\ succeeded.\ \ For\ example,\ when\ expecting\ a}}
\DoxyCodeLine{00201\ \textcolor{comment}{//\ long\ string,\ it\ can\ be\ very\ helpful\ to\ also\ print\ the\ diff\ between}}
\DoxyCodeLine{00202\ \textcolor{comment}{//\ the\ expected\ string\ and\ the\ actual\ one.\ \ To\ achieve\ that,\ you\ can}}
\DoxyCodeLine{00203\ \textcolor{comment}{//\ optionally\ stream\ additional\ information\ to\ a\ special\ variable}}
\DoxyCodeLine{00204\ \textcolor{comment}{//\ named\ result\_listener,\ whose\ type\ is\ a\ pointer\ to\ class}}
\DoxyCodeLine{00205\ \textcolor{comment}{//\ MatchResultListener:}}
\DoxyCodeLine{00206\ \textcolor{comment}{//}}
\DoxyCodeLine{00207\ \textcolor{comment}{//\ \ \ MATCHER\_P(EqualsLongString,\ str,\ "{}"{})\ \{}}
\DoxyCodeLine{00208\ \textcolor{comment}{//\ \ \ \ \ if\ (arg\ ==\ str)\ return\ true;}}
\DoxyCodeLine{00209\ \textcolor{comment}{//}}
\DoxyCodeLine{00210\ \textcolor{comment}{//\ \ \ \ \ *result\_listener\ <<\ "{}the\ difference:\ "{}}}
\DoxyCodeLine{00212\ \textcolor{comment}{//\ \ \ \ \ return\ false;}}
\DoxyCodeLine{00213\ \textcolor{comment}{//\ \ \ \}}}
\DoxyCodeLine{00214\ \textcolor{comment}{//}}
\DoxyCodeLine{00215\ \textcolor{comment}{//\ Overloading\ Matchers}}
\DoxyCodeLine{00216\ \textcolor{comment}{//\ ====================}}
\DoxyCodeLine{00217\ \textcolor{comment}{//}}
\DoxyCodeLine{00218\ \textcolor{comment}{//\ You\ can\ overload\ matchers\ with\ different\ numbers\ of\ parameters:}}
\DoxyCodeLine{00219\ \textcolor{comment}{//}}
\DoxyCodeLine{00220\ \textcolor{comment}{//\ \ \ MATCHER\_P(Blah,\ a,\ description\_string1)\ \{\ ...\ \}}}
\DoxyCodeLine{00221\ \textcolor{comment}{//\ \ \ MATCHER\_P2(Blah,\ a,\ b,\ description\_string2)\ \{\ ...\ \}}}
\DoxyCodeLine{00222\ \textcolor{comment}{//}}
\DoxyCodeLine{00223\ \textcolor{comment}{//\ Caveats}}
\DoxyCodeLine{00224\ \textcolor{comment}{//\ =======}}
\DoxyCodeLine{00225\ \textcolor{comment}{//}}
\DoxyCodeLine{00226\ \textcolor{comment}{//\ When\ defining\ a\ new\ matcher,\ you\ should\ also\ consider\ implementing}}
\DoxyCodeLine{00227\ \textcolor{comment}{//\ MatcherInterface\ or\ using\ MakePolymorphicMatcher().\ \ These}}
\DoxyCodeLine{00228\ \textcolor{comment}{//\ approaches\ require\ more\ work\ than\ the\ MATCHER*\ macros,\ but\ also}}
\DoxyCodeLine{00229\ \textcolor{comment}{//\ give\ you\ more\ control\ on\ the\ types\ of\ the\ value\ being\ matched\ and}}
\DoxyCodeLine{00230\ \textcolor{comment}{//\ the\ matcher\ parameters,\ which\ may\ leads\ to\ better\ compiler\ error}}
\DoxyCodeLine{00231\ \textcolor{comment}{//\ messages\ when\ the\ matcher\ is\ used\ wrong.\ \ They\ also\ allow}}
\DoxyCodeLine{00232\ \textcolor{comment}{//\ overloading\ matchers\ based\ on\ parameter\ types\ (as\ opposed\ to\ just}}
\DoxyCodeLine{00233\ \textcolor{comment}{//\ based\ on\ the\ number\ of\ parameters).}}
\DoxyCodeLine{00234\ \textcolor{comment}{//}}
\DoxyCodeLine{00235\ \textcolor{comment}{//\ MATCHER*()\ can\ only\ be\ used\ in\ a\ namespace\ scope\ as\ templates\ cannot\ be}}
\DoxyCodeLine{00236\ \textcolor{comment}{//\ declared\ inside\ of\ a\ local\ class.}}
\DoxyCodeLine{00237\ \textcolor{comment}{//}}
\DoxyCodeLine{00238\ \textcolor{comment}{//\ More\ Information}}
\DoxyCodeLine{00239\ \textcolor{comment}{//\ ================}}
\DoxyCodeLine{00240\ \textcolor{comment}{//}}
\DoxyCodeLine{00241\ \textcolor{comment}{//\ To\ learn\ more\ about\ using\ these\ macros,\ please\ search\ for\ 'MATCHER'}}
\DoxyCodeLine{00242\ \textcolor{comment}{//\ on}}
\DoxyCodeLine{00243\ \textcolor{comment}{//\ https://github.com/google/googletest/blob/main/docs/gmock\_cook\_book.md}}
\DoxyCodeLine{00244\ \textcolor{comment}{//}}
\DoxyCodeLine{00245\ \textcolor{comment}{//\ This\ file\ also\ implements\ some\ commonly\ used\ argument\ matchers.\ \ More}}
\DoxyCodeLine{00246\ \textcolor{comment}{//\ matchers\ can\ be\ defined\ by\ the\ user\ implementing\ the}}
\DoxyCodeLine{00247\ \textcolor{comment}{//\ MatcherInterface<T>\ interface\ if\ necessary.}}
\DoxyCodeLine{00248\ \textcolor{comment}{//}}
\DoxyCodeLine{00249\ \textcolor{comment}{//\ See\ googletest/include/gtest/gtest-\/matchers.h\ for\ the\ definition\ of\ class}}
\DoxyCodeLine{00250\ \textcolor{comment}{//\ Matcher,\ class\ MatcherInterface,\ and\ others.}}
\DoxyCodeLine{00251\ }
\DoxyCodeLine{00252\ \textcolor{comment}{//\ IWYU\ pragma:\ private,\ include\ "{}gmock/gmock.h"{}}}
\DoxyCodeLine{00253\ \textcolor{comment}{//\ IWYU\ pragma:\ friend\ gmock/.*}}
\DoxyCodeLine{00254\ }
\DoxyCodeLine{00255\ \textcolor{preprocessor}{\#ifndef\ GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{00256\ \textcolor{preprocessor}{\#define\ GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{00257\ }
\DoxyCodeLine{00258\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00259\ \textcolor{preprocessor}{\#include\ <cmath>}}
\DoxyCodeLine{00260\ \textcolor{preprocessor}{\#include\ <cstddef>}}
\DoxyCodeLine{00261\ \textcolor{preprocessor}{\#include\ <functional>}}
\DoxyCodeLine{00262\ \textcolor{preprocessor}{\#include\ <initializer\_list>}}
\DoxyCodeLine{00263\ \textcolor{preprocessor}{\#include\ <ios>}}
\DoxyCodeLine{00264\ \textcolor{preprocessor}{\#include\ <iterator>}}
\DoxyCodeLine{00265\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00266\ \textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{00267\ \textcolor{preprocessor}{\#include\ <ostream>}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00268\ \textcolor{preprocessor}{\#include\ <sstream>}}
\DoxyCodeLine{00269\ \textcolor{preprocessor}{\#include\ <string>}}
\DoxyCodeLine{00270\ \textcolor{preprocessor}{\#include\ <tuple>}}
\DoxyCodeLine{00271\ \textcolor{preprocessor}{\#include\ <type\_traits>}}
\DoxyCodeLine{00272\ \textcolor{preprocessor}{\#include\ <utility>}}
\DoxyCodeLine{00273\ \textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{00274\ }
\DoxyCodeLine{00275\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/gmock-\/internal-\/utils.h"{}}}
\DoxyCodeLine{00276\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/gmock-\/pp.h"{}}}
\DoxyCodeLine{00277\ \textcolor{preprocessor}{\#include\ "{}gtest/gtest.h"{}}}
\DoxyCodeLine{00278\ }
\DoxyCodeLine{00279\ \textcolor{comment}{//\ MSVC\ warning\ C5046\ is\ new\ as\ of\ VS2017\ version\ 15.8.}}
\DoxyCodeLine{00280\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ \_MSC\_VER\ >=\ 1915}}
\DoxyCodeLine{00281\ \textcolor{preprocessor}{\#define\ GMOCK\_MAYBE\_5046\_\ 5046}}
\DoxyCodeLine{00282\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00283\ \textcolor{preprocessor}{\#define\ GMOCK\_MAYBE\_5046\_}}
\DoxyCodeLine{00284\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00285\ }
\DoxyCodeLine{00286\ GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_(}
\DoxyCodeLine{00287\ \ \ \ \ 4251\ GMOCK\_MAYBE\_5046\_\ \textcolor{comment}{/*\ class\ A\ needs\ to\ have\ dll-\/interface\ to\ be\ used\ by}}
\DoxyCodeLine{00288\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ clients\ of\ class\ B\ */}}
\DoxyCodeLine{00289\ \ \ \ \ \textcolor{comment}{/*\ Symbol\ involving\ type\ with\ internal\ linkage\ not\ defined\ */})}
\DoxyCodeLine{00290\ }
\DoxyCodeLine{00291\ \textcolor{keyword}{namespace\ }testing\ \{}
\DoxyCodeLine{00292\ }
\DoxyCodeLine{00293\ \textcolor{comment}{//\ To\ implement\ a\ matcher\ Foo\ for\ type\ T,\ define:}}
\DoxyCodeLine{00294\ \textcolor{comment}{//\ \ \ 1.\ a\ class\ FooMatcherImpl\ that\ implements\ the}}
\DoxyCodeLine{00295\ \textcolor{comment}{//\ \ \ \ \ \ MatcherInterface<T>\ interface,\ and}}
\DoxyCodeLine{00296\ \textcolor{comment}{//\ \ \ 2.\ a\ factory\ function\ that\ creates\ a\ Matcher<T>\ object\ from\ a}}
\DoxyCodeLine{00297\ \textcolor{comment}{//\ \ \ \ \ \ FooMatcherImpl*.}}
\DoxyCodeLine{00298\ \textcolor{comment}{//}}
\DoxyCodeLine{00299\ \textcolor{comment}{//\ The\ two-\/level\ delegation\ design\ makes\ it\ possible\ to\ allow\ a\ user}}
\DoxyCodeLine{00300\ \textcolor{comment}{//\ to\ write\ "{}v"{}\ instead\ of\ "{}Eq(v)"{}\ where\ a\ Matcher\ is\ expected,\ which}}
\DoxyCodeLine{00301\ \textcolor{comment}{//\ is\ impossible\ if\ we\ pass\ matchers\ by\ pointers.\ \ It\ also\ eases}}
\DoxyCodeLine{00302\ \textcolor{comment}{//\ ownership\ management\ as\ Matcher\ objects\ can\ now\ be\ copied\ like}}
\DoxyCodeLine{00303\ \textcolor{comment}{//\ plain\ values.}}
\DoxyCodeLine{00304\ }
\DoxyCodeLine{00305\ \textcolor{comment}{//\ A\ match\ result\ listener\ that\ stores\ the\ explanation\ in\ a\ string.}}
\DoxyCodeLine{00306\ \textcolor{keyword}{class\ }StringMatchResultListener\ :\ \textcolor{keyword}{public}\ MatchResultListener\ \{}
\DoxyCodeLine{00307\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00308\ \ \ StringMatchResultListener()\ :\ MatchResultListener(\&ss\_)\ \{\}}
\DoxyCodeLine{00309\ }
\DoxyCodeLine{00310\ \ \ \textcolor{comment}{//\ Returns\ the\ explanation\ accumulated\ so\ far.}}
\DoxyCodeLine{00311\ \ \ std::string\ str()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ ss\_.str();\ \}}
\DoxyCodeLine{00312\ }
\DoxyCodeLine{00313\ \ \ \textcolor{comment}{//\ Clears\ the\ explanation\ accumulated\ so\ far.}}
\DoxyCodeLine{00314\ \ \ \textcolor{keywordtype}{void}\ Clear()\ \{\ ss\_.str(\textcolor{stringliteral}{"{}"{}});\ \}}
\DoxyCodeLine{00315\ }
\DoxyCodeLine{00316\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00317\ \ \ ::std::stringstream\ ss\_;}
\DoxyCodeLine{00318\ }
\DoxyCodeLine{00319\ \ \ StringMatchResultListener(\textcolor{keyword}{const}\ StringMatchResultListener\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{00320\ \ \ StringMatchResultListener\&\ operator=(\textcolor{keyword}{const}\ StringMatchResultListener\&)\ =}
\DoxyCodeLine{00321\ \ \ \ \ \ \ \textcolor{keyword}{delete};}
\DoxyCodeLine{00322\ \};}
\DoxyCodeLine{00323\ }
\DoxyCodeLine{00324\ \textcolor{comment}{//\ Anything\ inside\ the\ 'internal'\ namespace\ IS\ INTERNAL\ IMPLEMENTATION}}
\DoxyCodeLine{00325\ \textcolor{comment}{//\ and\ MUST\ NOT\ BE\ USED\ IN\ USER\ CODE!!!}}
\DoxyCodeLine{00326\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00327\ }
\DoxyCodeLine{00328\ \textcolor{comment}{//\ The\ MatcherCastImpl\ class\ template\ is\ a\ helper\ for\ implementing}}
\DoxyCodeLine{00329\ \textcolor{comment}{//\ MatcherCast().\ \ We\ need\ this\ helper\ in\ order\ to\ partially}}
\DoxyCodeLine{00330\ \textcolor{comment}{//\ specialize\ the\ implementation\ of\ MatcherCast()\ (C++\ allows}}
\DoxyCodeLine{00331\ \textcolor{comment}{//\ class/struct\ templates\ to\ be\ partially\ specialized,\ but\ not}}
\DoxyCodeLine{00332\ \textcolor{comment}{//\ function\ templates.).}}
\DoxyCodeLine{00333\ }
\DoxyCodeLine{00334\ \textcolor{comment}{//\ This\ general\ version\ is\ used\ when\ MatcherCast()'s\ argument\ is\ a}}
\DoxyCodeLine{00335\ \textcolor{comment}{//\ polymorphic\ matcher\ (i.e.\ something\ that\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{00336\ \textcolor{comment}{//\ Matcher\ but\ is\ not\ one\ yet;\ for\ example,\ Eq(value))\ or\ a\ value\ (for}}
\DoxyCodeLine{00337\ \textcolor{comment}{//\ example,\ "{}hello"{}).}}
\DoxyCodeLine{00338\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{00339\ \textcolor{keyword}{class\ }MatcherCastImpl\ \{}
\DoxyCodeLine{00340\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00341\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ Cast(\textcolor{keyword}{const}\ M\&\ polymorphic\_matcher\_or\_value)\ \{}
\DoxyCodeLine{00342\ \ \ \ \ \textcolor{comment}{//\ M\ can\ be\ a\ polymorphic\ matcher,\ in\ which\ case\ we\ want\ to\ use}}
\DoxyCodeLine{00343\ \ \ \ \ \textcolor{comment}{//\ its\ conversion\ operator\ to\ create\ Matcher<T>.\ \ Or\ it\ can\ be\ a\ value}}
\DoxyCodeLine{00344\ \ \ \ \ \textcolor{comment}{//\ that\ should\ be\ passed\ to\ the\ Matcher<T>'s\ constructor.}}
\DoxyCodeLine{00345\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00346\ \ \ \ \ \textcolor{comment}{//\ We\ can't\ call\ Matcher<T>(polymorphic\_matcher\_or\_value)\ when\ M\ is\ a}}
\DoxyCodeLine{00347\ \ \ \ \ \textcolor{comment}{//\ polymorphic\ matcher\ because\ it'll\ be\ ambiguous\ if\ T\ has\ an\ implicit}}
\DoxyCodeLine{00348\ \ \ \ \ \textcolor{comment}{//\ constructor\ from\ M\ (this\ usually\ happens\ when\ T\ has\ an\ implicit}}
\DoxyCodeLine{00349\ \ \ \ \ \textcolor{comment}{//\ constructor\ from\ any\ type).}}
\DoxyCodeLine{00350\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00351\ \ \ \ \ \textcolor{comment}{//\ It\ won't\ work\ to\ unconditionally\ implicit\_cast}}
\DoxyCodeLine{00352\ \ \ \ \ \textcolor{comment}{//\ polymorphic\_matcher\_or\_value\ to\ Matcher<T>\ because\ it\ won't\ trigger}}
\DoxyCodeLine{00353\ \ \ \ \ \textcolor{comment}{//\ a\ user-\/defined\ conversion\ from\ M\ to\ T\ if\ one\ exists\ (assuming\ M\ is}}
\DoxyCodeLine{00354\ \ \ \ \ \textcolor{comment}{//\ a\ value).}}
\DoxyCodeLine{00355\ \ \ \ \ \textcolor{keywordflow}{return}\ CastImpl(polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{00356\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_convertible<M,\ Matcher<T>>\{\},}
\DoxyCodeLine{00357\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_convertible<M,\ T>\{\});}
\DoxyCodeLine{00358\ \ \ \}}
\DoxyCodeLine{00359\ }
\DoxyCodeLine{00360\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00361\ \ \ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{bool}\ Ignore>}
\DoxyCodeLine{00362\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ CastImpl(\textcolor{keyword}{const}\ M\&\ polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{00363\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::true\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{00364\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::integral\_constant<bool,\ Ignore>)\ \{}
\DoxyCodeLine{00365\ \ \ \ \ \textcolor{comment}{//\ M\ is\ implicitly\ convertible\ to\ Matcher<T>,\ which\ means\ that\ either}}
\DoxyCodeLine{00366\ \ \ \ \ \textcolor{comment}{//\ M\ is\ a\ polymorphic\ matcher\ or\ Matcher<T>\ has\ an\ implicit\ constructor}}
\DoxyCodeLine{00367\ \ \ \ \ \textcolor{comment}{//\ from\ M.\ \ In\ both\ cases\ using\ the\ implicit\ conversion\ will\ produce\ a}}
\DoxyCodeLine{00368\ \ \ \ \ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{00369\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00370\ \ \ \ \ \textcolor{comment}{//\ Even\ if\ T\ has\ an\ implicit\ constructor\ from\ M,\ it\ won't\ be\ called\ because}}
\DoxyCodeLine{00371\ \ \ \ \ \textcolor{comment}{//\ creating\ Matcher<T>\ would\ require\ a\ chain\ of\ two\ user-\/defined\ conversions}}
\DoxyCodeLine{00372\ \ \ \ \ \textcolor{comment}{//\ (first\ to\ create\ T\ from\ M\ and\ then\ to\ create\ Matcher<T>\ from\ T).}}
\DoxyCodeLine{00373\ \ \ \ \ \textcolor{keywordflow}{return}\ polymorphic\_matcher\_or\_value;}
\DoxyCodeLine{00374\ \ \ \}}
\DoxyCodeLine{00375\ }
\DoxyCodeLine{00376\ \ \ \textcolor{comment}{//\ M\ can't\ be\ implicitly\ converted\ to\ Matcher<T>,\ so\ M\ isn't\ a\ polymorphic}}
\DoxyCodeLine{00377\ \ \ \textcolor{comment}{//\ matcher.\ It's\ a\ value\ of\ a\ type\ implicitly\ convertible\ to\ T.\ Use\ direct}}
\DoxyCodeLine{00378\ \ \ \textcolor{comment}{//\ initialization\ or\ \`{}ImplicitCastEqMatcher`\ to\ create\ a\ matcher.}}
\DoxyCodeLine{00379\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ CastImpl(\textcolor{keyword}{const}\ M\&\ value,}
\DoxyCodeLine{00380\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{00381\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::true\_type\ \textcolor{comment}{/*\ convertible\_to\_T\ */})\ \{}
\DoxyCodeLine{00382\ \ \ \ \ \textcolor{keyword}{using\ }NoRefT\ =\ std::remove\_cv\_t<std::remove\_reference\_t<T>>;}
\DoxyCodeLine{00383\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (std::is\_same\_v<M,\ NoRefT>)\ \{}
\DoxyCodeLine{00384\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(value);}
\DoxyCodeLine{00385\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00386\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ImplicitCastEqMatcher<NoRefT,\ std::decay\_t<const\ M\&>>(value);}
\DoxyCodeLine{00387\ \ \ \ \ \}}
\DoxyCodeLine{00388\ \ \ \}}
\DoxyCodeLine{00389\ }
\DoxyCodeLine{00390\ \ \ \textcolor{comment}{//\ M\ can't\ be\ implicitly\ converted\ to\ either\ Matcher<T>\ or\ T.\ Attempt\ to\ use}}
\DoxyCodeLine{00391\ \ \ \textcolor{comment}{//\ polymorphic\ matcher\ Eq(value)\ in\ this\ case.}}
\DoxyCodeLine{00392\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00393\ \ \ \textcolor{comment}{//\ Note\ that\ we\ first\ attempt\ to\ perform\ an\ implicit\ cast\ on\ the\ value\ and}}
\DoxyCodeLine{00394\ \ \ \textcolor{comment}{//\ only\ fall\ back\ to\ the\ polymorphic\ Eq()\ matcher\ afterwards\ because\ the}}
\DoxyCodeLine{00395\ \ \ \textcolor{comment}{//\ latter\ calls\ bool\ operator==(const\ Lhs\&\ lhs,\ const\ Rhs\&\ rhs)\ in\ the\ end}}
\DoxyCodeLine{00396\ \ \ \textcolor{comment}{//\ which\ might\ be\ undefined\ even\ when\ Rhs\ is\ implicitly\ convertible\ to\ Lhs}}
\DoxyCodeLine{00397\ \ \ \textcolor{comment}{//\ (e.g.\ std::pair<const\ int,\ int>\ vs.\ std::pair<int,\ int>).}}
\DoxyCodeLine{00398\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ CastImpl(\textcolor{keyword}{const}\ M\&\ value,}
\DoxyCodeLine{00399\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{00400\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_T\ */})\ \{}
\DoxyCodeLine{00401\ \ \ \ \ \textcolor{keywordflow}{return}\ Eq(value);}
\DoxyCodeLine{00402\ \ \ \}}
\DoxyCodeLine{00403\ \};}
\DoxyCodeLine{00404\ }
\DoxyCodeLine{00405\ \textcolor{comment}{//\ This\ more\ specialized\ version\ is\ used\ when\ MatcherCast()'s\ argument}}
\DoxyCodeLine{00406\ \textcolor{comment}{//\ is\ already\ a\ Matcher.\ \ This\ only\ compiles\ when\ type\ T\ can\ be}}
\DoxyCodeLine{00407\ \textcolor{comment}{//\ statically\ converted\ to\ type\ U.}}
\DoxyCodeLine{00408\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00409\ \textcolor{keyword}{class\ }MatcherCastImpl<T,\ Matcher<U>>\ \{}
\DoxyCodeLine{00410\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00411\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ Cast(\textcolor{keyword}{const}\ Matcher<U>\&\ source\_matcher)\ \{}
\DoxyCodeLine{00412\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ Impl(source\_matcher));}
\DoxyCodeLine{00413\ \ \ \}}
\DoxyCodeLine{00414\ }
\DoxyCodeLine{00415\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00416\ \ \ \textcolor{comment}{//\ If\ it's\ possible\ to\ implicitly\ convert\ a\ \`{}const\ T\&`\ to\ U,\ then\ \`{}Impl`\ can}}
\DoxyCodeLine{00417\ \ \ \textcolor{comment}{//\ take\ that\ as\ input\ to\ avoid\ a\ copy.\ Otherwise,\ such\ as\ when\ \`{}T`\ is\ a}}
\DoxyCodeLine{00418\ \ \ \textcolor{comment}{//\ non-\/const\ reference\ type\ or\ a\ type\ explicitly\ constructible\ only\ from\ a}}
\DoxyCodeLine{00419\ \ \ \textcolor{comment}{//\ non-\/const\ reference,\ then\ \`{}Impl`\ must\ use\ \`{}T`\ as-\/is\ (potentially\ copying).}}
\DoxyCodeLine{00420\ \ \ \textcolor{keyword}{using\ }ImplArgT\ =}
\DoxyCodeLine{00421\ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::conditional<std::is\_convertible<const\ T\&,\ const\ U\&>::value,}
\DoxyCodeLine{00422\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ T\&,\ T>::type;}
\DoxyCodeLine{00423\ }
\DoxyCodeLine{00424\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<ImplArgT>\ \{}
\DoxyCodeLine{00425\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00426\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ Matcher<U>\&\ source\_matcher)}
\DoxyCodeLine{00427\ \ \ \ \ \ \ \ \ :\ source\_matcher\_(source\_matcher)\ \{\}}
\DoxyCodeLine{00428\ }
\DoxyCodeLine{00429\ \ \ \ \ \textcolor{comment}{//\ We\ delegate\ the\ matching\ logic\ to\ the\ source\ matcher.}}
\DoxyCodeLine{00430\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(ImplArgT\ x,}
\DoxyCodeLine{00431\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00432\ \ \ \ \ \ \ \textcolor{keyword}{using\ }FromType\ =\ \textcolor{keyword}{typename}\ std::remove\_cv<\textcolor{keyword}{typename}\ std::remove\_pointer<}
\DoxyCodeLine{00433\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_reference<T>::type>::type>::type;}
\DoxyCodeLine{00434\ \ \ \ \ \ \ \textcolor{keyword}{using\ }ToType\ =\ \textcolor{keyword}{typename}\ std::remove\_cv<\textcolor{keyword}{typename}\ std::remove\_pointer<}
\DoxyCodeLine{00435\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_reference<U>::type>::type>::type;}
\DoxyCodeLine{00436\ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ not\ allow\ implicitly\ converting\ base*/\&\ to\ derived*/\&.}}
\DoxyCodeLine{00437\ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{00438\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ not\ trigger\ if\ only\ one\ of\ them\ is\ a\ pointer.\ That\ implies\ a}}
\DoxyCodeLine{00439\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ regular\ conversion\ and\ not\ a\ down\_cast.}}
\DoxyCodeLine{00440\ \ \ \ \ \ \ \ \ \ \ (std::is\_pointer<typename\ std::remove\_reference<T>::type>::value\ !=}
\DoxyCodeLine{00441\ \ \ \ \ \ \ \ \ \ \ \ std::is\_pointer<typename\ std::remove\_reference<U>::type>::value)\ ||}
\DoxyCodeLine{00442\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<FromType,\ ToType>::value\ ||}
\DoxyCodeLine{00443\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_base\_of<FromType,\ ToType>::value,}
\DoxyCodeLine{00444\ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Can't\ implicitly\ convert\ from\ <base>\ to\ <derived>"{}});}
\DoxyCodeLine{00445\ }
\DoxyCodeLine{00446\ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ the\ cast\ to\ \`{}U`\ explicitly\ if\ necessary.}}
\DoxyCodeLine{00447\ \ \ \ \ \ \ \textcolor{comment}{//\ Otherwise,\ let\ implicit\ conversions\ do\ the\ trick.}}
\DoxyCodeLine{00448\ \ \ \ \ \ \ \textcolor{keyword}{using\ }CastType\ =\ \textcolor{keyword}{typename}\ std::conditional<}
\DoxyCodeLine{00449\ \ \ \ \ \ \ \ \ \ \ std::is\_convertible<ImplArgT\&,\ const\ U\&>::value,\ ImplArgT\&,\ U>::type;}
\DoxyCodeLine{00450\ }
\DoxyCodeLine{00451\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ source\_matcher\_.MatchAndExplain(\textcolor{keyword}{static\_cast<}CastType\textcolor{keyword}{>}(x),}
\DoxyCodeLine{00452\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ listener);}
\DoxyCodeLine{00453\ \ \ \ \ \}}
\DoxyCodeLine{00454\ }
\DoxyCodeLine{00455\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00456\ \ \ \ \ \ \ source\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{00457\ \ \ \ \ \}}
\DoxyCodeLine{00458\ }
\DoxyCodeLine{00459\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00460\ \ \ \ \ \ \ source\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{00461\ \ \ \ \ \}}
\DoxyCodeLine{00462\ }
\DoxyCodeLine{00463\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00464\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<U>\ source\_matcher\_;}
\DoxyCodeLine{00465\ \ \ \};}
\DoxyCodeLine{00466\ \};}
\DoxyCodeLine{00467\ }
\DoxyCodeLine{00468\ \textcolor{comment}{//\ This\ even\ more\ specialized\ version\ is\ used\ for\ efficiently\ casting}}
\DoxyCodeLine{00469\ \textcolor{comment}{//\ a\ matcher\ to\ its\ own\ type.}}
\DoxyCodeLine{00470\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00471\ \textcolor{keyword}{class\ }MatcherCastImpl<T,\ Matcher<T>>\ \{}
\DoxyCodeLine{00472\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00473\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ Cast(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)\ \{\ \textcolor{keywordflow}{return}\ matcher;\ \}}
\DoxyCodeLine{00474\ \};}
\DoxyCodeLine{00475\ }
\DoxyCodeLine{00476\ \textcolor{comment}{//\ Template\ specialization\ for\ parameterless\ Matcher.}}
\DoxyCodeLine{00477\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived>}
\DoxyCodeLine{00478\ \textcolor{keyword}{class\ }MatcherBaseImpl\ \{}
\DoxyCodeLine{00479\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00480\ \ \ MatcherBaseImpl()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{00481\ }
\DoxyCodeLine{00482\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00483\ \ \ operator\ ::testing::Matcher<T>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT(runtime/explicit)}}
\DoxyCodeLine{00484\ \ \ \ \ return\ ::testing::Matcher<T>(\textcolor{keyword}{new}}
\DoxyCodeLine{00485\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ Derived::template\ gmock\_Impl<T>());}
\DoxyCodeLine{00486\ \ \ \}}
\DoxyCodeLine{00487\ \};}
\DoxyCodeLine{00488\ }
\DoxyCodeLine{00489\ \textcolor{comment}{//\ Template\ specialization\ for\ Matcher\ with\ parameters.}}
\DoxyCodeLine{00490\ \textcolor{keyword}{template}\ <\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...>\ \textcolor{keyword}{class\ }Derived,\ \textcolor{keyword}{typename}...\ Ts>}
\DoxyCodeLine{00491\ \textcolor{keyword}{class\ }MatcherBaseImpl<Derived<Ts...>>\ \{}
\DoxyCodeLine{00492\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00493\ \ \ \textcolor{comment}{//\ Mark\ the\ constructor\ explicit\ for\ single\ argument\ T\ to\ avoid\ implicit}}
\DoxyCodeLine{00494\ \ \ \textcolor{comment}{//\ conversions.}}
\DoxyCodeLine{00495\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ E\ =\ std::enable\_if<\textcolor{keyword}{sizeof}...(Ts)\ ==\ 1>,}
\DoxyCodeLine{00496\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ E::type*\ =\ \textcolor{keyword}{nullptr}>}
\DoxyCodeLine{00497\ \ \ \textcolor{keyword}{explicit}\ MatcherBaseImpl(Ts...\ params)}
\DoxyCodeLine{00498\ \ \ \ \ \ \ :\ params\_(std::forward<Ts>(params)...)\ \{\}}
\DoxyCodeLine{00499\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ E\ =\ std::enable\_if<\textcolor{keyword}{sizeof}...(Ts)\ !=\ 1>,}
\DoxyCodeLine{00500\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ =\ \textcolor{keyword}{typename}\ E::type>}
\DoxyCodeLine{00501\ \ \ MatcherBaseImpl(Ts...\ params)\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00502\ \ \ \ \ \ \ :\ params\_(std::forward<Ts>(params)...)\ \{\}}
\DoxyCodeLine{00503\ }
\DoxyCodeLine{00504\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ F>}
\DoxyCodeLine{00505\ \ \ operator\ ::testing::Matcher<F>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT(runtime/explicit)}}
\DoxyCodeLine{00506\ \ \ \ \ \textcolor{keywordflow}{return}\ Apply<F>(std::make\_index\_sequence<\textcolor{keyword}{sizeof}...(Ts)>\{\});}
\DoxyCodeLine{00507\ \ \ \}}
\DoxyCodeLine{00508\ }
\DoxyCodeLine{00509\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00510\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ F,\ std::size\_t...\ tuple\_ids>}
\DoxyCodeLine{00511\ \ \ \mbox{\hyperlink{classtesting_1_1Matcher}{::testing::Matcher<F>}}\ Apply(std::index\_sequence<tuple\_ids...>)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00512\ \ \ \ \ return\ ::testing::Matcher<F>(}
\DoxyCodeLine{00513\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ \textcolor{keyword}{typename}\ Derived<Ts...>::template\ gmock\_Impl<F>(}
\DoxyCodeLine{00514\ \ \ \ \ \ \ \ \ \ \ \ \ std::get<tuple\_ids>(params\_)...));}
\DoxyCodeLine{00515\ \ \ \}}
\DoxyCodeLine{00516\ }
\DoxyCodeLine{00517\ \ \ \textcolor{keyword}{const}\ std::tuple<Ts...>\ params\_;}
\DoxyCodeLine{00518\ \};}
\DoxyCodeLine{00519\ }
\DoxyCodeLine{00520\ \}\ \ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{00521\ }
\DoxyCodeLine{00522\ \textcolor{comment}{//\ In\ order\ to\ be\ safe\ and\ clear,\ casting\ between\ different\ matcher}}
\DoxyCodeLine{00523\ \textcolor{comment}{//\ types\ is\ done\ explicitly\ via\ MatcherCast<T>(m),\ which\ takes\ a}}
\DoxyCodeLine{00524\ \textcolor{comment}{//\ matcher\ m\ and\ returns\ a\ Matcher<T>.\ \ It\ compiles\ only\ when\ T\ can\ be}}
\DoxyCodeLine{00525\ \textcolor{comment}{//\ statically\ converted\ to\ the\ argument\ type\ of\ m.}}
\DoxyCodeLine{00526\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{00527\ \textcolor{keyword}{inline}\ Matcher<T>\ MatcherCast(\textcolor{keyword}{const}\ M\&\ matcher)\ \{}
\DoxyCodeLine{00528\ \ \ \textcolor{keywordflow}{return}\ internal::MatcherCastImpl<T,\ M>::Cast(matcher);}
\DoxyCodeLine{00529\ \}}
\DoxyCodeLine{00530\ }
\DoxyCodeLine{00531\ \textcolor{comment}{//\ This\ overload\ handles\ polymorphic\ matchers\ and\ values\ only\ since}}
\DoxyCodeLine{00532\ \textcolor{comment}{//\ monomorphic\ matchers\ are\ handled\ by\ the\ next\ one.}}
\DoxyCodeLine{00533\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{00534\ \textcolor{keyword}{inline}\ Matcher<T>\ SafeMatcherCast(\textcolor{keyword}{const}\ M\&\ polymorphic\_matcher\_or\_value)\ \{}
\DoxyCodeLine{00535\ \ \ \textcolor{keywordflow}{return}\ MatcherCast<T>(polymorphic\_matcher\_or\_value);}
\DoxyCodeLine{00536\ \}}
\DoxyCodeLine{00537\ }
\DoxyCodeLine{00538\ \textcolor{comment}{//\ This\ overload\ handles\ monomorphic\ matchers.}}
\DoxyCodeLine{00539\ \textcolor{comment}{//}}
\DoxyCodeLine{00540\ \textcolor{comment}{//\ In\ general,\ if\ type\ T\ can\ be\ implicitly\ converted\ to\ type\ U,\ we\ can}}
\DoxyCodeLine{00541\ \textcolor{comment}{//\ safely\ convert\ a\ Matcher<U>\ to\ a\ Matcher<T>\ (i.e.\ Matcher\ is}}
\DoxyCodeLine{00542\ \textcolor{comment}{//\ contravariant):\ just\ keep\ a\ copy\ of\ the\ original\ Matcher<U>,\ convert\ the}}
\DoxyCodeLine{00543\ \textcolor{comment}{//\ argument\ from\ type\ T\ to\ U,\ and\ then\ pass\ it\ to\ the\ underlying\ Matcher<U>.}}
\DoxyCodeLine{00544\ \textcolor{comment}{//\ The\ only\ exception\ is\ when\ U\ is\ a\ non-\/const\ reference\ and\ T\ is\ not,\ as\ the}}
\DoxyCodeLine{00545\ \textcolor{comment}{//\ underlying\ Matcher<U>\ may\ be\ interested\ in\ the\ argument's\ address,\ which}}
\DoxyCodeLine{00546\ \textcolor{comment}{//\ cannot\ be\ preserved\ in\ the\ conversion\ from\ T\ to\ U\ (since\ a\ copy\ of\ the\ input}}
\DoxyCodeLine{00547\ \textcolor{comment}{//\ T\ argument\ would\ be\ required\ to\ provide\ a\ non-\/const\ reference\ U).}}
\DoxyCodeLine{00548\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00549\ \textcolor{keyword}{inline}\ Matcher<T>\ SafeMatcherCast(\textcolor{keyword}{const}\ Matcher<U>\&\ matcher)\ \{}
\DoxyCodeLine{00550\ \ \ \textcolor{comment}{//\ Enforce\ that\ T\ can\ be\ implicitly\ converted\ to\ U.}}
\DoxyCodeLine{00551\ \ \ \textcolor{keyword}{static\_assert}(std::is\_convertible<const\ T\&,\ const\ U\&>::value,}
\DoxyCodeLine{00552\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}T\ must\ be\ implicitly\ convertible\ to\ U\ (and\ T\ must\ be\ a\ "{}}}
\DoxyCodeLine{00553\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}non-\/const\ reference\ if\ U\ is\ a\ non-\/const\ reference)"{}});}
\DoxyCodeLine{00554\ \ \ \textcolor{comment}{//\ In\ case\ both\ T\ and\ U\ are\ arithmetic\ types,\ enforce\ that\ the}}
\DoxyCodeLine{00555\ \ \ \textcolor{comment}{//\ conversion\ is\ not\ lossy.}}
\DoxyCodeLine{00556\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(T)\ RawT;}
\DoxyCodeLine{00557\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(U)\ RawU;}
\DoxyCodeLine{00558\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ kTIsOther\ =\ GMOCK\_KIND\_OF\_(RawT)\ ==\ internal::kOther;}
\DoxyCodeLine{00559\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ kUIsOther\ =\ GMOCK\_KIND\_OF\_(RawU)\ ==\ internal::kOther;}
\DoxyCodeLine{00560\ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{00561\ \ \ \ \ \ \ kTIsOther\ ||\ kUIsOther\ ||}
\DoxyCodeLine{00562\ \ \ \ \ \ \ \ \ \ \ (internal::LosslessArithmeticConvertible<RawT,\ RawU>::value),}
\DoxyCodeLine{00563\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}conversion\ of\ arithmetic\ types\ must\ be\ lossless"{}});}
\DoxyCodeLine{00564\ \ \ \textcolor{keywordflow}{return}\ MatcherCast<T>(matcher);}
\DoxyCodeLine{00565\ \}}
\DoxyCodeLine{00566\ }
\DoxyCodeLine{00567\ \textcolor{comment}{//\ A<T>()\ returns\ a\ matcher\ that\ matches\ any\ value\ of\ type\ T.}}
\DoxyCodeLine{00568\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00569\ Matcher<T>\ A();}
\DoxyCodeLine{00570\ }
\DoxyCodeLine{00571\ \textcolor{comment}{//\ Anything\ inside\ the\ 'internal'\ namespace\ IS\ INTERNAL\ IMPLEMENTATION}}
\DoxyCodeLine{00572\ \textcolor{comment}{//\ and\ MUST\ NOT\ BE\ USED\ IN\ USER\ CODE!!!}}
\DoxyCodeLine{00573\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00574\ }
\DoxyCodeLine{00575\ \textcolor{comment}{//\ Used\ per\ go/ranked-\/overloads\ for\ dispatching.}}
\DoxyCodeLine{00576\ \textcolor{keyword}{struct\ }Rank0\ \{\};}
\DoxyCodeLine{00577\ \textcolor{keyword}{struct\ }Rank1\ :\ Rank0\ \{\};}
\DoxyCodeLine{00578\ \textcolor{keyword}{using\ }HighestRank\ =\ Rank1;}
\DoxyCodeLine{00579\ }
\DoxyCodeLine{00580\ \textcolor{comment}{//\ If\ the\ explanation\ is\ not\ empty,\ prints\ it\ to\ the\ ostream.}}
\DoxyCodeLine{00581\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ PrintIfNotEmpty(\textcolor{keyword}{const}\ std::string\&\ explanation,}
\DoxyCodeLine{00582\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ os)\ \{}
\DoxyCodeLine{00583\ \ \ \textcolor{keywordflow}{if}\ (!explanation.empty()\ \&\&\ os\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00584\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ "{}}\ <<\ explanation;}
\DoxyCodeLine{00585\ \ \ \}}
\DoxyCodeLine{00586\ \}}
\DoxyCodeLine{00587\ }
\DoxyCodeLine{00588\ \textcolor{comment}{//\ Returns\ true\ if\ the\ given\ type\ name\ is\ easy\ to\ read\ by\ a\ human.}}
\DoxyCodeLine{00589\ \textcolor{comment}{//\ This\ is\ used\ to\ decide\ whether\ printing\ the\ type\ of\ a\ value\ might}}
\DoxyCodeLine{00590\ \textcolor{comment}{//\ be\ helpful.}}
\DoxyCodeLine{00591\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ IsReadableTypeName(\textcolor{keyword}{const}\ std::string\&\ type\_name)\ \{}
\DoxyCodeLine{00592\ \ \ \textcolor{comment}{//\ We\ consider\ a\ type\ name\ readable\ if\ it's\ short\ or\ doesn't\ contain}}
\DoxyCodeLine{00593\ \ \ \textcolor{comment}{//\ a\ template\ or\ function\ type.}}
\DoxyCodeLine{00594\ \ \ \textcolor{keywordflow}{return}\ (type\_name.length()\ <=\ 20\ ||}
\DoxyCodeLine{00595\ \ \ \ \ \ \ \ \ \ \ type\_name.find\_first\_of(\textcolor{stringliteral}{"{}<("{}})\ ==\ std::string::npos);}
\DoxyCodeLine{00596\ \}}
\DoxyCodeLine{00597\ }
\DoxyCodeLine{00598\ \textcolor{comment}{//\ Matches\ the\ value\ against\ the\ given\ matcher,\ prints\ the\ value\ and\ explains}}
\DoxyCodeLine{00599\ \textcolor{comment}{//\ the\ match\ result\ to\ the\ listener.\ Returns\ the\ match\ result.}}
\DoxyCodeLine{00600\ \textcolor{comment}{//\ 'listener'\ must\ not\ be\ NULL.}}
\DoxyCodeLine{00601\ \textcolor{comment}{//\ Value\ cannot\ be\ passed\ by\ const\ reference,\ because\ some\ matchers\ take\ a}}
\DoxyCodeLine{00602\ \textcolor{comment}{//\ non-\/const\ argument.}}
\DoxyCodeLine{00603\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Value,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00604\ \textcolor{keywordtype}{bool}\ MatchPrintAndExplain(Value\&\ value,\ \textcolor{keyword}{const}\ Matcher<T>\&\ matcher,}
\DoxyCodeLine{00605\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \{}
\DoxyCodeLine{00606\ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{00607\ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ do\ not\ need\ to\ construct\ the}}
\DoxyCodeLine{00608\ \ \ \ \ \textcolor{comment}{//\ inner\ explanation.}}
\DoxyCodeLine{00609\ \ \ \ \ \textcolor{keywordflow}{return}\ matcher.Matches(value);}
\DoxyCodeLine{00610\ \ \ \}}
\DoxyCodeLine{00611\ }
\DoxyCodeLine{00612\ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{00613\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher.MatchAndExplain(value,\ \&inner\_listener);}
\DoxyCodeLine{00614\ }
\DoxyCodeLine{00615\ \ \ UniversalPrint(value,\ listener-\/>stream());}
\DoxyCodeLine{00616\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{00617\ \ \ \textcolor{keyword}{const}\ std::string\&\ type\_name\ =\ GetTypeName<Value>();}
\DoxyCodeLine{00618\ \ \ \textcolor{keywordflow}{if}\ (IsReadableTypeName(type\_name))}
\DoxyCodeLine{00619\ \ \ \ \ *listener-\/>stream()\ <<\ \textcolor{stringliteral}{"{}\ (of\ type\ "{}}\ <<\ type\_name\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00620\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00621\ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{00622\ }
\DoxyCodeLine{00623\ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{00624\ \}}
\DoxyCodeLine{00625\ }
\DoxyCodeLine{00626\ \textcolor{comment}{//\ An\ internal\ helper\ class\ for\ doing\ compile-\/time\ loop\ on\ a\ tuple's}}
\DoxyCodeLine{00627\ \textcolor{comment}{//\ fields.}}
\DoxyCodeLine{00628\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{00629\ \textcolor{keyword}{class\ }TuplePrefix\ \{}
\DoxyCodeLine{00630\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00631\ \ \ \textcolor{comment}{//\ TuplePrefix<N>::Matches(matcher\_tuple,\ value\_tuple)\ returns\ true}}
\DoxyCodeLine{00632\ \ \ \textcolor{comment}{//\ if\ and\ only\ if\ the\ first\ N\ fields\ of\ matcher\_tuple\ matches}}
\DoxyCodeLine{00633\ \ \ \textcolor{comment}{//\ the\ first\ N\ fields\ of\ value\_tuple,\ respectively.}}
\DoxyCodeLine{00634\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00635\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{bool}\ Matches(\textcolor{keyword}{const}\ MatcherTuple\&\ matcher\_tuple,}
\DoxyCodeLine{00636\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ value\_tuple)\ \{}
\DoxyCodeLine{00637\ \ \ \ \ \textcolor{keywordflow}{return}\ TuplePrefix<N\ -\/\ 1>::Matches(matcher\_tuple,\ value\_tuple)\ \&\&}
\DoxyCodeLine{00638\ \ \ \ \ \ \ \ \ \ \ \ std::get<N\ -\/\ 1>(matcher\_tuple).Matches(std::get<N\ -\/\ 1>(value\_tuple));}
\DoxyCodeLine{00639\ \ \ \}}
\DoxyCodeLine{00640\ }
\DoxyCodeLine{00641\ \ \ \textcolor{comment}{//\ TuplePrefix<N>::ExplainMatchFailuresTo(matchers,\ values,\ os)}}
\DoxyCodeLine{00642\ \ \ \textcolor{comment}{//\ describes\ failures\ in\ matching\ the\ first\ N\ fields\ of\ matchers}}
\DoxyCodeLine{00643\ \ \ \textcolor{comment}{//\ against\ the\ first\ N\ fields\ of\ values.\ \ If\ there\ is\ no\ failure,}}
\DoxyCodeLine{00644\ \ \ \textcolor{comment}{//\ nothing\ will\ be\ streamed\ to\ os.}}
\DoxyCodeLine{00645\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00646\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ ExplainMatchFailuresTo(\textcolor{keyword}{const}\ MatcherTuple\&\ matchers,}
\DoxyCodeLine{00647\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ values,}
\DoxyCodeLine{00648\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ os)\ \{}
\DoxyCodeLine{00649\ \ \ \ \ \textcolor{comment}{//\ First,\ describes\ failures\ in\ the\ first\ N\ -\/\ 1\ fields.}}
\DoxyCodeLine{00650\ \ \ \ \ TuplePrefix<N\ -\/\ 1>::ExplainMatchFailuresTo(matchers,\ values,\ os);}
\DoxyCodeLine{00651\ }
\DoxyCodeLine{00652\ \ \ \ \ \textcolor{comment}{//\ Then\ describes\ the\ failure\ (if\ any)\ in\ the\ (N\ -\/\ 1)-\/th\ (0-\/based)}}
\DoxyCodeLine{00653\ \ \ \ \ \textcolor{comment}{//\ field.}}
\DoxyCodeLine{00654\ \ \ \ \ \textcolor{keyword}{typename}\ std::tuple\_element<N\ -\/\ 1,\ MatcherTuple>::type\ matcher\ =}
\DoxyCodeLine{00655\ \ \ \ \ \ \ \ \ std::get<N\ -\/\ 1>(matchers);}
\DoxyCodeLine{00656\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ std::tuple\_element<N\ -\/\ 1,\ ValueTuple>::type\ Value;}
\DoxyCodeLine{00657\ \ \ \ \ \textcolor{keyword}{const}\ Value\&\ value\ =\ std::get<N\ -\/\ 1>(values);}
\DoxyCodeLine{00658\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{00659\ \ \ \ \ \textcolor{keywordflow}{if}\ (!matcher.MatchAndExplain(value,\ \&listener))\ \{}
\DoxyCodeLine{00660\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ \ Expected\ arg\ \#"{}}\ <<\ N\ -\/\ 1\ <<\ \textcolor{stringliteral}{"{}:\ "{}};}
\DoxyCodeLine{00661\ \ \ \ \ \ \ std::get<N\ -\/\ 1>(matchers).DescribeTo(os);}
\DoxyCodeLine{00662\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\ \ \ \ \ \ \ \ \ \ \ Actual:\ "{}};}
\DoxyCodeLine{00663\ \ \ \ \ \ \ \textcolor{comment}{//\ We\ remove\ the\ reference\ in\ type\ Value\ to\ prevent\ the}}
\DoxyCodeLine{00664\ \ \ \ \ \ \ \textcolor{comment}{//\ universal\ printer\ from\ printing\ the\ address\ of\ value,\ which}}
\DoxyCodeLine{00665\ \ \ \ \ \ \ \textcolor{comment}{//\ isn't\ interesting\ to\ the\ user\ most\ of\ the\ time.\ \ The}}
\DoxyCodeLine{00666\ \ \ \ \ \ \ \textcolor{comment}{//\ matcher's\ MatchAndExplain()\ method\ handles\ the\ case\ when}}
\DoxyCodeLine{00667\ \ \ \ \ \ \ \textcolor{comment}{//\ the\ address\ is\ interesting.}}
\DoxyCodeLine{00668\ \ \ \ \ \ \ internal::UniversalPrint(value,\ os);}
\DoxyCodeLine{00669\ \ \ \ \ \ \ PrintIfNotEmpty(listener.str(),\ os);}
\DoxyCodeLine{00670\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{00671\ \ \ \ \ \}}
\DoxyCodeLine{00672\ \ \ \}}
\DoxyCodeLine{00673\ \};}
\DoxyCodeLine{00674\ }
\DoxyCodeLine{00675\ \textcolor{comment}{//\ The\ base\ case.}}
\DoxyCodeLine{00676\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00677\ \textcolor{keyword}{class\ }TuplePrefix<0>\ \{}
\DoxyCodeLine{00678\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00679\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00680\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{bool}\ Matches(\textcolor{keyword}{const}\ MatcherTuple\&\ \textcolor{comment}{/*\ matcher\_tuple\ */},}
\DoxyCodeLine{00681\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ \textcolor{comment}{/*\ value\_tuple\ */})\ \{}
\DoxyCodeLine{00682\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00683\ \ \ \}}
\DoxyCodeLine{00684\ }
\DoxyCodeLine{00685\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00686\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ ExplainMatchFailuresTo(\textcolor{keyword}{const}\ MatcherTuple\&\ \textcolor{comment}{/*\ matchers\ */},}
\DoxyCodeLine{00687\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ \textcolor{comment}{/*\ values\ */},}
\DoxyCodeLine{00688\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ \textcolor{comment}{/*\ os\ */})\ \{\}}
\DoxyCodeLine{00689\ \};}
\DoxyCodeLine{00690\ }
\DoxyCodeLine{00691\ \textcolor{comment}{//\ TupleMatches(matcher\_tuple,\ value\_tuple)\ returns\ true\ if\ and\ only\ if}}
\DoxyCodeLine{00692\ \textcolor{comment}{//\ all\ matchers\ in\ matcher\_tuple\ match\ the\ corresponding\ fields\ in}}
\DoxyCodeLine{00693\ \textcolor{comment}{//\ value\_tuple.\ \ It\ is\ a\ compiler\ error\ if\ matcher\_tuple\ and}}
\DoxyCodeLine{00694\ \textcolor{comment}{//\ value\_tuple\ have\ different\ number\ of\ fields\ or\ incompatible\ field}}
\DoxyCodeLine{00695\ \textcolor{comment}{//\ types.}}
\DoxyCodeLine{00696\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00697\ \textcolor{keywordtype}{bool}\ TupleMatches(\textcolor{keyword}{const}\ MatcherTuple\&\ matcher\_tuple,}
\DoxyCodeLine{00698\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ value\_tuple)\ \{}
\DoxyCodeLine{00699\ \ \ \textcolor{comment}{//\ Makes\ sure\ that\ matcher\_tuple\ and\ value\_tuple\ have\ the\ same}}
\DoxyCodeLine{00700\ \ \ \textcolor{comment}{//\ number\ of\ fields.}}
\DoxyCodeLine{00701\ \ \ \textcolor{keyword}{static\_assert}(std::tuple\_size<MatcherTuple>::value\ ==}
\DoxyCodeLine{00702\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::tuple\_size<ValueTuple>::value,}
\DoxyCodeLine{00703\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}matcher\ and\ value\ have\ different\ numbers\ of\ fields"{}});}
\DoxyCodeLine{00704\ \ \ \textcolor{keywordflow}{return}\ TuplePrefix<std::tuple\_size<ValueTuple>::value>::Matches(matcher\_tuple,}
\DoxyCodeLine{00705\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ value\_tuple);}
\DoxyCodeLine{00706\ \}}
\DoxyCodeLine{00707\ }
\DoxyCodeLine{00708\ \textcolor{comment}{//\ Describes\ failures\ in\ matching\ matchers\ against\ values.\ \ If\ there}}
\DoxyCodeLine{00709\ \textcolor{comment}{//\ is\ no\ failure,\ nothing\ will\ be\ streamed\ to\ os.}}
\DoxyCodeLine{00710\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00711\ \textcolor{keywordtype}{void}\ ExplainMatchFailureTupleTo(\textcolor{keyword}{const}\ MatcherTuple\&\ matchers,}
\DoxyCodeLine{00712\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ values,\ ::std::ostream*\ os)\ \{}
\DoxyCodeLine{00713\ \ \ TuplePrefix<std::tuple\_size<MatcherTuple>::value>::ExplainMatchFailuresTo(}
\DoxyCodeLine{00714\ \ \ \ \ \ \ matchers,\ values,\ os);}
\DoxyCodeLine{00715\ \}}
\DoxyCodeLine{00716\ }
\DoxyCodeLine{00717\ \textcolor{comment}{//\ TransformTupleValues\ and\ its\ helper.}}
\DoxyCodeLine{00718\ \textcolor{comment}{//}}
\DoxyCodeLine{00719\ \textcolor{comment}{//\ TransformTupleValuesHelper\ hides\ the\ internal\ machinery\ that}}
\DoxyCodeLine{00720\ \textcolor{comment}{//\ TransformTupleValues\ uses\ to\ implement\ a\ tuple\ traversal.}}
\DoxyCodeLine{00721\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple,\ \textcolor{keyword}{typename}\ Func,\ \textcolor{keyword}{typename}\ OutIter>}
\DoxyCodeLine{00722\ \textcolor{keyword}{class\ }TransformTupleValuesHelper\ \{}
\DoxyCodeLine{00723\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00724\ \ \ typedef\ ::std::tuple\_size<Tuple>\ TupleSize;}
\DoxyCodeLine{00725\ }
\DoxyCodeLine{00726\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00727\ \ \ \textcolor{comment}{//\ For\ each\ member\ of\ tuple\ 't',\ taken\ in\ order,\ evaluates\ '*out++\ =\ f(t)'.}}
\DoxyCodeLine{00728\ \ \ \textcolor{comment}{//\ Returns\ the\ final\ value\ of\ 'out'\ in\ case\ the\ caller\ needs\ it.}}
\DoxyCodeLine{00729\ \ \ \textcolor{keyword}{static}\ OutIter\ Run(Func\ f,\ \textcolor{keyword}{const}\ Tuple\&\ t,\ OutIter\ out)\ \{}
\DoxyCodeLine{00730\ \ \ \ \ \textcolor{keywordflow}{return}\ IterateOverTuple<Tuple,\ TupleSize::value>()(f,\ t,\ out);}
\DoxyCodeLine{00731\ \ \ \}}
\DoxyCodeLine{00732\ }
\DoxyCodeLine{00733\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00734\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tup,\ \textcolor{keywordtype}{size\_t}\ kRemainingSize>}
\DoxyCodeLine{00735\ \ \ \textcolor{keyword}{struct\ }IterateOverTuple\ \{}
\DoxyCodeLine{00736\ \ \ \ \ OutIter\ operator()(Func\ f,\ \textcolor{keyword}{const}\ Tup\&\ t,\ OutIter\ out)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00737\ \ \ \ \ \ \ *out++\ =\ f(::std::get<TupleSize::value\ -\/\ kRemainingSize>(t));}
\DoxyCodeLine{00738\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ IterateOverTuple<Tup,\ kRemainingSize\ -\/\ 1>()(f,\ t,\ out);}
\DoxyCodeLine{00739\ \ \ \ \ \}}
\DoxyCodeLine{00740\ \ \ \};}
\DoxyCodeLine{00741\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tup>}
\DoxyCodeLine{00742\ \ \ \textcolor{keyword}{struct\ }IterateOverTuple<Tup,\ 0>\ \{}
\DoxyCodeLine{00743\ \ \ \ \ OutIter\ operator()(Func\ \textcolor{comment}{/*\ f\ */},\ \textcolor{keyword}{const}\ Tup\&\ \textcolor{comment}{/*\ t\ */},\ OutIter\ out)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00744\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ out;}
\DoxyCodeLine{00745\ \ \ \ \ \}}
\DoxyCodeLine{00746\ \ \ \};}
\DoxyCodeLine{00747\ \};}
\DoxyCodeLine{00748\ }
\DoxyCodeLine{00749\ \textcolor{comment}{//\ Successively\ invokes\ 'f(element)'\ on\ each\ element\ of\ the\ tuple\ 't',}}
\DoxyCodeLine{00750\ \textcolor{comment}{//\ appending\ each\ result\ to\ the\ 'out'\ iterator.\ Returns\ the\ final\ value}}
\DoxyCodeLine{00751\ \textcolor{comment}{//\ of\ 'out'.}}
\DoxyCodeLine{00752\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple,\ \textcolor{keyword}{typename}\ Func,\ \textcolor{keyword}{typename}\ OutIter>}
\DoxyCodeLine{00753\ OutIter\ TransformTupleValues(Func\ f,\ \textcolor{keyword}{const}\ Tuple\&\ t,\ OutIter\ out)\ \{}
\DoxyCodeLine{00754\ \ \ \textcolor{keywordflow}{return}\ TransformTupleValuesHelper<Tuple,\ Func,\ OutIter>::Run(f,\ t,\ out);}
\DoxyCodeLine{00755\ \}}
\DoxyCodeLine{00756\ }
\DoxyCodeLine{00757\ \textcolor{comment}{//\ Implements\ \_,\ a\ matcher\ that\ matches\ any\ value\ of\ any}}
\DoxyCodeLine{00758\ \textcolor{comment}{//\ type.\ \ This\ is\ a\ polymorphic\ matcher,\ so\ we\ need\ a\ template\ type}}
\DoxyCodeLine{00759\ \textcolor{comment}{//\ conversion\ operator\ to\ make\ it\ appearing\ as\ a\ Matcher<T>\ for\ any}}
\DoxyCodeLine{00760\ \textcolor{comment}{//\ type\ T.}}
\DoxyCodeLine{00761\ \textcolor{keyword}{class\ }AnythingMatcher\ \{}
\DoxyCodeLine{00762\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00763\ \ \ \textcolor{keyword}{using\ }is\_gtest\_matcher\ =\ void;}
\DoxyCodeLine{00764\ }
\DoxyCodeLine{00765\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00766\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ \textcolor{comment}{/*\ x\ */},\ std::ostream*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00767\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00768\ \ \ \}}
\DoxyCodeLine{00769\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ anything"{}};\ \}}
\DoxyCodeLine{00770\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00771\ \ \ \ \ \textcolor{comment}{//\ This\ is\ mostly\ for\ completeness'\ sake,\ as\ it's\ not\ very\ useful}}
\DoxyCodeLine{00772\ \ \ \ \ \textcolor{comment}{//\ to\ write\ Not(A<bool>()).\ \ However\ we\ cannot\ completely\ rule\ out}}
\DoxyCodeLine{00773\ \ \ \ \ \textcolor{comment}{//\ such\ a\ possibility,\ and\ it\ doesn't\ hurt\ to\ be\ prepared.}}
\DoxyCodeLine{00774\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}never\ matches"{}};}
\DoxyCodeLine{00775\ \ \ \}}
\DoxyCodeLine{00776\ \};}
\DoxyCodeLine{00777\ }
\DoxyCodeLine{00778\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ IsNull()\ matcher,\ which\ matches\ any\ raw\ or\ smart}}
\DoxyCodeLine{00779\ \textcolor{comment}{//\ pointer\ that\ is\ NULL.}}
\DoxyCodeLine{00780\ \textcolor{keyword}{class\ }IsNullMatcher\ \{}
\DoxyCodeLine{00781\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00782\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{00783\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Pointer\&\ p,}
\DoxyCodeLine{00784\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00785\ \ \ \ \ \textcolor{keywordflow}{return}\ p\ ==\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00786\ \ \ \}}
\DoxyCodeLine{00787\ }
\DoxyCodeLine{00788\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ NULL"{}};\ \}}
\DoxyCodeLine{00789\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NULL"{}};\ \}}
\DoxyCodeLine{00790\ \};}
\DoxyCodeLine{00791\ }
\DoxyCodeLine{00792\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ NotNull()\ matcher,\ which\ matches\ any\ raw\ or\ smart}}
\DoxyCodeLine{00793\ \textcolor{comment}{//\ pointer\ that\ is\ not\ NULL.}}
\DoxyCodeLine{00794\ \textcolor{keyword}{class\ }NotNullMatcher\ \{}
\DoxyCodeLine{00795\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00796\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{00797\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Pointer\&\ p,}
\DoxyCodeLine{00798\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00799\ \ \ \ \ \textcolor{keywordflow}{return}\ p\ !=\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00800\ \ \ \}}
\DoxyCodeLine{00801\ }
\DoxyCodeLine{00802\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NULL"{}};\ \}}
\DoxyCodeLine{00803\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ NULL"{}};\ \}}
\DoxyCodeLine{00804\ \};}
\DoxyCodeLine{00805\ }
\DoxyCodeLine{00806\ \textcolor{comment}{//\ Ref(variable)\ matches\ any\ argument\ that\ is\ a\ reference\ to}}
\DoxyCodeLine{00807\ \textcolor{comment}{//\ 'variable'.\ \ This\ matcher\ is\ polymorphic\ as\ it\ can\ match\ any}}
\DoxyCodeLine{00808\ \textcolor{comment}{//\ super\ type\ of\ the\ type\ of\ 'variable'.}}
\DoxyCodeLine{00809\ \textcolor{comment}{//}}
\DoxyCodeLine{00810\ \textcolor{comment}{//\ The\ RefMatcher\ template\ class\ implements\ Ref(variable).\ \ It\ can}}
\DoxyCodeLine{00811\ \textcolor{comment}{//\ only\ be\ instantiated\ with\ a\ reference\ type.\ \ This\ prevents\ a\ user}}
\DoxyCodeLine{00812\ \textcolor{comment}{//\ from\ mistakenly\ using\ Ref(x)\ to\ match\ a\ non-\/reference\ function}}
\DoxyCodeLine{00813\ \textcolor{comment}{//\ argument.\ \ For\ example,\ the\ following\ will\ righteously\ cause\ a}}
\DoxyCodeLine{00814\ \textcolor{comment}{//\ compiler\ error:}}
\DoxyCodeLine{00815\ \textcolor{comment}{//}}
\DoxyCodeLine{00816\ \textcolor{comment}{//\ \ \ int\ n;}}
\DoxyCodeLine{00817\ \textcolor{comment}{//\ \ \ Matcher<int>\ m1\ =\ Ref(n);\ \ \ //\ This\ won't\ compile.}}
\DoxyCodeLine{00818\ \textcolor{comment}{//\ \ \ Matcher<int\&>\ m2\ =\ Ref(n);\ \ //\ This\ will\ compile.}}
\DoxyCodeLine{00819\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00820\ \textcolor{keyword}{class\ }RefMatcher;}
\DoxyCodeLine{00821\ }
\DoxyCodeLine{00822\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00823\ \textcolor{keyword}{class\ }RefMatcher<T\&>\ \{}
\DoxyCodeLine{00824\ \ \ \textcolor{comment}{//\ Google\ Mock\ is\ a\ generic\ framework\ and\ thus\ needs\ to\ support}}
\DoxyCodeLine{00825\ \ \ \textcolor{comment}{//\ mocking\ any\ function\ types,\ including\ those\ that\ take\ non-\/const}}
\DoxyCodeLine{00826\ \ \ \textcolor{comment}{//\ reference\ arguments.\ \ Therefore\ the\ template\ parameter\ T\ (and}}
\DoxyCodeLine{00827\ \ \ \textcolor{comment}{//\ Super\ below)\ can\ be\ instantiated\ to\ either\ a\ const\ type\ or\ a}}
\DoxyCodeLine{00828\ \ \ \textcolor{comment}{//\ non-\/const\ type.}}
\DoxyCodeLine{00829\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00830\ \ \ \textcolor{comment}{//\ RefMatcher()\ takes\ a\ T\&\ instead\ of\ const\ T\&,\ as\ we\ want\ the}}
\DoxyCodeLine{00831\ \ \ \textcolor{comment}{//\ compiler\ to\ catch\ using\ Ref(const\_value)\ as\ a\ matcher\ for\ a}}
\DoxyCodeLine{00832\ \ \ \textcolor{comment}{//\ non-\/const\ reference.}}
\DoxyCodeLine{00833\ \ \ \textcolor{keyword}{explicit}\ RefMatcher(T\&\ x)\ :\ object\_(x)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00834\ }
\DoxyCodeLine{00835\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Super>}
\DoxyCodeLine{00836\ \ \ \textcolor{keyword}{operator}\ Matcher<Super\&>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00837\ \ \ \ \ \textcolor{comment}{//\ By\ passing\ object\_\ (type\ T\&)\ to\ Impl(),\ which\ expects\ a\ Super\&,}}
\DoxyCodeLine{00838\ \ \ \ \ \textcolor{comment}{//\ we\ make\ sure\ that\ Super\ is\ a\ super\ type\ of\ T.\ \ In\ particular,}}
\DoxyCodeLine{00839\ \ \ \ \ \textcolor{comment}{//\ this\ catches\ using\ Ref(const\_value)\ as\ a\ matcher\ for\ a}}
\DoxyCodeLine{00840\ \ \ \ \ \textcolor{comment}{//\ non-\/const\ reference,\ as\ you\ cannot\ implicitly\ convert\ a\ const}}
\DoxyCodeLine{00841\ \ \ \ \ \textcolor{comment}{//\ reference\ to\ a\ non-\/const\ reference.}}
\DoxyCodeLine{00842\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<Super>(object\_));}
\DoxyCodeLine{00843\ \ \ \}}
\DoxyCodeLine{00844\ }
\DoxyCodeLine{00845\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00846\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Super>}
\DoxyCodeLine{00847\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Super\&>\ \{}
\DoxyCodeLine{00848\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00849\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(Super\&\ x)\ :\ object\_(x)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00850\ }
\DoxyCodeLine{00851\ \ \ \ \ \textcolor{comment}{//\ MatchAndExplain()\ takes\ a\ Super\&\ (as\ opposed\ to\ const\ Super\&)}}
\DoxyCodeLine{00852\ \ \ \ \ \textcolor{comment}{//\ in\ order\ to\ match\ the\ interface\ MatcherInterface<Super\&>.}}
\DoxyCodeLine{00853\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Super\&\ x,}
\DoxyCodeLine{00854\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00855\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ located\ @"{}}\ <<\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{00856\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \&x\ ==\ \&object\_;}
\DoxyCodeLine{00857\ \ \ \ \ \}}
\DoxyCodeLine{00858\ }
\DoxyCodeLine{00859\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00860\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}references\ the\ variable\ "{}};}
\DoxyCodeLine{00861\ \ \ \ \ \ \ UniversalPrinter<Super\&>::Print(object\_,\ os);}
\DoxyCodeLine{00862\ \ \ \ \ \}}
\DoxyCodeLine{00863\ }
\DoxyCodeLine{00864\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00865\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ reference\ the\ variable\ "{}};}
\DoxyCodeLine{00866\ \ \ \ \ \ \ UniversalPrinter<Super\&>::Print(object\_,\ os);}
\DoxyCodeLine{00867\ \ \ \ \ \}}
\DoxyCodeLine{00868\ }
\DoxyCodeLine{00869\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00870\ \ \ \ \ \textcolor{keyword}{const}\ Super\&\ object\_;}
\DoxyCodeLine{00871\ \ \ \};}
\DoxyCodeLine{00872\ }
\DoxyCodeLine{00873\ \ \ T\&\ object\_;}
\DoxyCodeLine{00874\ \};}
\DoxyCodeLine{00875\ }
\DoxyCodeLine{00876\ \textcolor{comment}{//\ Polymorphic\ helper\ functions\ for\ narrow\ and\ wide\ string\ matchers.}}
\DoxyCodeLine{00877\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ CaseInsensitiveCStringEquals(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ lhs,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ rhs)\ \{}
\DoxyCodeLine{00878\ \ \ \textcolor{keywordflow}{return}\ String::CaseInsensitiveCStringEquals(lhs,\ rhs);}
\DoxyCodeLine{00879\ \}}
\DoxyCodeLine{00880\ }
\DoxyCodeLine{00881\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ CaseInsensitiveCStringEquals(\textcolor{keyword}{const}\ \textcolor{keywordtype}{wchar\_t}*\ lhs,}
\DoxyCodeLine{00882\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{wchar\_t}*\ rhs)\ \{}
\DoxyCodeLine{00883\ \ \ \textcolor{keywordflow}{return}\ String::CaseInsensitiveWideCStringEquals(lhs,\ rhs);}
\DoxyCodeLine{00884\ \}}
\DoxyCodeLine{00885\ }
\DoxyCodeLine{00886\ \textcolor{comment}{//\ String\ comparison\ for\ narrow\ or\ wide\ strings\ that\ can\ have\ embedded\ NUL}}
\DoxyCodeLine{00887\ \textcolor{comment}{//\ characters.}}
\DoxyCodeLine{00888\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{00889\ \textcolor{keywordtype}{bool}\ CaseInsensitiveStringEquals(\textcolor{keyword}{const}\ StringType\&\ s1,\ \textcolor{keyword}{const}\ StringType\&\ s2)\ \{}
\DoxyCodeLine{00890\ \ \ \textcolor{comment}{//\ Are\ the\ heads\ equal?}}
\DoxyCodeLine{00891\ \ \ \textcolor{keywordflow}{if}\ (!CaseInsensitiveCStringEquals(s1.c\_str(),\ s2.c\_str()))\ \{}
\DoxyCodeLine{00892\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00893\ \ \ \}}
\DoxyCodeLine{00894\ }
\DoxyCodeLine{00895\ \ \ \textcolor{comment}{//\ Skip\ the\ equal\ heads.}}
\DoxyCodeLine{00896\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{typename}\ StringType::value\_type\ nul\ =\ 0;}
\DoxyCodeLine{00897\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ i1\ =\ s1.find(nul),\ i2\ =\ s2.find(nul);}
\DoxyCodeLine{00898\ }
\DoxyCodeLine{00899\ \ \ \textcolor{comment}{//\ Are\ we\ at\ the\ end\ of\ either\ s1\ or\ s2?}}
\DoxyCodeLine{00900\ \ \ \textcolor{keywordflow}{if}\ (i1\ ==\ StringType::npos\ ||\ i2\ ==\ StringType::npos)\ \{}
\DoxyCodeLine{00901\ \ \ \ \ \textcolor{keywordflow}{return}\ i1\ ==\ i2;}
\DoxyCodeLine{00902\ \ \ \}}
\DoxyCodeLine{00903\ }
\DoxyCodeLine{00904\ \ \ \textcolor{comment}{//\ Are\ the\ tails\ equal?}}
\DoxyCodeLine{00905\ \ \ \textcolor{keywordflow}{return}\ CaseInsensitiveStringEquals(s1.substr(i1\ +\ 1),\ s2.substr(i2\ +\ 1));}
\DoxyCodeLine{00906\ \}}
\DoxyCodeLine{00907\ }
\DoxyCodeLine{00908\ \textcolor{comment}{//\ String\ matchers.}}
\DoxyCodeLine{00909\ }
\DoxyCodeLine{00910\ \textcolor{comment}{//\ Implements\ equality-\/based\ string\ matchers\ like\ StrEq,\ StrCaseNe,\ and\ etc.}}
\DoxyCodeLine{00911\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{00912\ \textcolor{keyword}{class\ }StrEqualityMatcher\ \{}
\DoxyCodeLine{00913\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00914\ \ \ StrEqualityMatcher(StringType\ str,\ \textcolor{keywordtype}{bool}\ expect\_eq,\ \textcolor{keywordtype}{bool}\ case\_sensitive)}
\DoxyCodeLine{00915\ \ \ \ \ \ \ :\ string\_(std::move(str)),}
\DoxyCodeLine{00916\ \ \ \ \ \ \ \ \ expect\_eq\_(expect\_eq),}
\DoxyCodeLine{00917\ \ \ \ \ \ \ \ \ case\_sensitive\_(case\_sensitive)\ \{\}}
\DoxyCodeLine{00918\ }
\DoxyCodeLine{00919\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00920\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{00921\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00922\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{00923\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{00924\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{00925\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{00926\ \ \ \}}
\DoxyCodeLine{00927\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00928\ }
\DoxyCodeLine{00929\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{00930\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{00931\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{00932\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{00933\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{00934\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{00935\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00936\ \ \ \ \ \textcolor{keywordflow}{if}\ (s\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00937\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !expect\_eq\_;}
\DoxyCodeLine{00938\ \ \ \ \ \}}
\DoxyCodeLine{00939\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{00940\ \ \ \}}
\DoxyCodeLine{00941\ }
\DoxyCodeLine{00942\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{00943\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00944\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{00945\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{00946\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{00947\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{00948\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00949\ \ \ \ \ \textcolor{keyword}{const}\ StringType\ s2(s);}
\DoxyCodeLine{00950\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ eq\ =\ case\_sensitive\_\ ?\ s2\ ==\ string\_}
\DoxyCodeLine{00951\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ CaseInsensitiveStringEquals(s2,\ string\_);}
\DoxyCodeLine{00952\ \ \ \ \ \textcolor{keywordflow}{return}\ expect\_eq\_\ ==\ eq;}
\DoxyCodeLine{00953\ \ \ \}}
\DoxyCodeLine{00954\ }
\DoxyCodeLine{00955\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00956\ \ \ \ \ DescribeToHelper(expect\_eq\_,\ os);}
\DoxyCodeLine{00957\ \ \ \}}
\DoxyCodeLine{00958\ }
\DoxyCodeLine{00959\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00960\ \ \ \ \ DescribeToHelper(!expect\_eq\_,\ os);}
\DoxyCodeLine{00961\ \ \ \}}
\DoxyCodeLine{00962\ }
\DoxyCodeLine{00963\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00964\ \ \ \textcolor{keywordtype}{void}\ DescribeToHelper(\textcolor{keywordtype}{bool}\ expect\_eq,\ ::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00965\ \ \ \ \ *os\ <<\ (expect\_eq\ ?\ \textcolor{stringliteral}{"{}is\ "{}}\ :\ \textcolor{stringliteral}{"{}isn't\ "{}});}
\DoxyCodeLine{00966\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}equal\ to\ "{}};}
\DoxyCodeLine{00967\ \ \ \ \ \textcolor{keywordflow}{if}\ (!case\_sensitive\_)\ \{}
\DoxyCodeLine{00968\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}(ignoring\ case)\ "{}};}
\DoxyCodeLine{00969\ \ \ \ \ \}}
\DoxyCodeLine{00970\ \ \ \ \ UniversalPrint(string\_,\ os);}
\DoxyCodeLine{00971\ \ \ \}}
\DoxyCodeLine{00972\ }
\DoxyCodeLine{00973\ \ \ \textcolor{keyword}{const}\ StringType\ string\_;}
\DoxyCodeLine{00974\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ expect\_eq\_;}
\DoxyCodeLine{00975\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ case\_sensitive\_;}
\DoxyCodeLine{00976\ \};}
\DoxyCodeLine{00977\ }
\DoxyCodeLine{00978\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ HasSubstr(substring)\ matcher,\ which}}
\DoxyCodeLine{00979\ \textcolor{comment}{//\ can\ be\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{00980\ \textcolor{comment}{//\ string.}}
\DoxyCodeLine{00981\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{00982\ \textcolor{keyword}{class\ }HasSubstrMatcher\ \{}
\DoxyCodeLine{00983\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00984\ \ \ \textcolor{keyword}{explicit}\ HasSubstrMatcher(\textcolor{keyword}{const}\ StringType\&\ substring)}
\DoxyCodeLine{00985\ \ \ \ \ \ \ :\ substring\_(substring)\ \{\}}
\DoxyCodeLine{00986\ }
\DoxyCodeLine{00987\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00988\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{00989\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00990\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{00991\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{00992\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{00993\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{00994\ \ \ \}}
\DoxyCodeLine{00995\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00996\ }
\DoxyCodeLine{00997\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{00998\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{00999\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{01000\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{01001\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{01002\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{01003\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01004\ \ \ \ \ \textcolor{keywordflow}{return}\ s\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{01005\ \ \ \}}
\DoxyCodeLine{01006\ }
\DoxyCodeLine{01007\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{01008\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01009\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{01010\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{01011\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01012\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01013\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01014\ \ \ \ \ \textcolor{keywordflow}{return}\ StringType(s).find(substring\_)\ !=\ StringType::npos;}
\DoxyCodeLine{01015\ \ \ \}}
\DoxyCodeLine{01016\ }
\DoxyCodeLine{01017\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ matches.}}
\DoxyCodeLine{01018\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01019\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ substring\ "{}};}
\DoxyCodeLine{01020\ \ \ \ \ UniversalPrint(substring\_,\ os);}
\DoxyCodeLine{01021\ \ \ \}}
\DoxyCodeLine{01022\ }
\DoxyCodeLine{01023\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01024\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ no\ substring\ "{}};}
\DoxyCodeLine{01025\ \ \ \ \ UniversalPrint(substring\_,\ os);}
\DoxyCodeLine{01026\ \ \ \}}
\DoxyCodeLine{01027\ }
\DoxyCodeLine{01028\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01029\ \ \ \textcolor{keyword}{const}\ StringType\ substring\_;}
\DoxyCodeLine{01030\ \};}
\DoxyCodeLine{01031\ }
\DoxyCodeLine{01032\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ StartsWith(substring)\ matcher,\ which}}
\DoxyCodeLine{01033\ \textcolor{comment}{//\ can\ be\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{01034\ \textcolor{comment}{//\ string.}}
\DoxyCodeLine{01035\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{01036\ \textcolor{keyword}{class\ }StartsWithMatcher\ \{}
\DoxyCodeLine{01037\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01038\ \ \ \textcolor{keyword}{explicit}\ StartsWithMatcher(\textcolor{keyword}{const}\ StringType\&\ prefix)\ :\ prefix\_(prefix)\ \{\}}
\DoxyCodeLine{01039\ }
\DoxyCodeLine{01040\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01041\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{01042\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01043\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{01044\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{01045\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{01046\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{01047\ \ \ \}}
\DoxyCodeLine{01048\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01049\ }
\DoxyCodeLine{01050\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{01051\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{01052\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{01053\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{01054\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{01055\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{01056\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01057\ \ \ \ \ \textcolor{keywordflow}{return}\ s\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{01058\ \ \ \}}
\DoxyCodeLine{01059\ }
\DoxyCodeLine{01060\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{01061\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01062\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{01063\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{01064\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01065\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01066\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01067\ \ \ \ \ \textcolor{keyword}{const}\ StringType\ s2(s);}
\DoxyCodeLine{01068\ \ \ \ \ \textcolor{keywordflow}{return}\ s2.length()\ >=\ prefix\_.length()\ \&\&}
\DoxyCodeLine{01069\ \ \ \ \ \ \ \ \ \ \ \ s2.substr(0,\ prefix\_.length())\ ==\ prefix\_;}
\DoxyCodeLine{01070\ \ \ \}}
\DoxyCodeLine{01071\ }
\DoxyCodeLine{01072\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01073\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}starts\ with\ "{}};}
\DoxyCodeLine{01074\ \ \ \ \ UniversalPrint(prefix\_,\ os);}
\DoxyCodeLine{01075\ \ \ \}}
\DoxyCodeLine{01076\ }
\DoxyCodeLine{01077\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01078\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ start\ with\ "{}};}
\DoxyCodeLine{01079\ \ \ \ \ UniversalPrint(prefix\_,\ os);}
\DoxyCodeLine{01080\ \ \ \}}
\DoxyCodeLine{01081\ }
\DoxyCodeLine{01082\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01083\ \ \ \textcolor{keyword}{const}\ StringType\ prefix\_;}
\DoxyCodeLine{01084\ \};}
\DoxyCodeLine{01085\ }
\DoxyCodeLine{01086\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ EndsWith(substring)\ matcher,\ which}}
\DoxyCodeLine{01087\ \textcolor{comment}{//\ can\ be\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{01088\ \textcolor{comment}{//\ string.}}
\DoxyCodeLine{01089\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{01090\ \textcolor{keyword}{class\ }EndsWithMatcher\ \{}
\DoxyCodeLine{01091\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01092\ \ \ \textcolor{keyword}{explicit}\ EndsWithMatcher(\textcolor{keyword}{const}\ StringType\&\ suffix)\ :\ suffix\_(suffix)\ \{\}}
\DoxyCodeLine{01093\ }
\DoxyCodeLine{01094\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01095\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{01096\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01097\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{01098\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{01099\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{01100\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{01101\ \ \ \}}
\DoxyCodeLine{01102\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01103\ }
\DoxyCodeLine{01104\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{01105\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{01106\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{01107\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{01108\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{01109\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{01110\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01111\ \ \ \ \ \textcolor{keywordflow}{return}\ s\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{01112\ \ \ \}}
\DoxyCodeLine{01113\ }
\DoxyCodeLine{01114\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{01115\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01116\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{01117\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{01118\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01119\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01120\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01121\ \ \ \ \ \textcolor{keyword}{const}\ StringType\ s2(s);}
\DoxyCodeLine{01122\ \ \ \ \ \textcolor{keywordflow}{return}\ s2.length()\ >=\ suffix\_.length()\ \&\&}
\DoxyCodeLine{01123\ \ \ \ \ \ \ \ \ \ \ \ s2.substr(s2.length()\ -\/\ suffix\_.length())\ ==\ suffix\_;}
\DoxyCodeLine{01124\ \ \ \}}
\DoxyCodeLine{01125\ }
\DoxyCodeLine{01126\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01127\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}ends\ with\ "{}};}
\DoxyCodeLine{01128\ \ \ \ \ UniversalPrint(suffix\_,\ os);}
\DoxyCodeLine{01129\ \ \ \}}
\DoxyCodeLine{01130\ }
\DoxyCodeLine{01131\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01132\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ end\ with\ "{}};}
\DoxyCodeLine{01133\ \ \ \ \ UniversalPrint(suffix\_,\ os);}
\DoxyCodeLine{01134\ \ \ \}}
\DoxyCodeLine{01135\ }
\DoxyCodeLine{01136\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01137\ \ \ \textcolor{keyword}{const}\ StringType\ suffix\_;}
\DoxyCodeLine{01138\ \};}
\DoxyCodeLine{01139\ }
\DoxyCodeLine{01140\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ WhenBase64Unescaped(matcher)\ matcher,\ which\ can\ be}}
\DoxyCodeLine{01141\ \textcolor{comment}{//\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a\ string.}}
\DoxyCodeLine{01142\ \textcolor{keyword}{class\ }WhenBase64UnescapedMatcher\ \{}
\DoxyCodeLine{01143\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01144\ \ \ \textcolor{keyword}{using\ }is\_gtest\_matcher\ =\ void;}
\DoxyCodeLine{01145\ }
\DoxyCodeLine{01146\ \ \ \textcolor{keyword}{explicit}\ WhenBase64UnescapedMatcher(}
\DoxyCodeLine{01147\ \ \ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\&\ internal\_matcher)}
\DoxyCodeLine{01148\ \ \ \ \ \ \ :\ internal\_matcher\_(internal\_matcher)\ \{\}}
\DoxyCodeLine{01149\ }
\DoxyCodeLine{01150\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ std::string.}}
\DoxyCodeLine{01151\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01152\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01153\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01154\ \ \ \ \ \textcolor{keyword}{const}\ std::string\ s2(s);\ \ \textcolor{comment}{//\ NOLINT\ (needed\ for\ working\ with\ string\_view).}}
\DoxyCodeLine{01155\ \ \ \ \ std::string\ unescaped;}
\DoxyCodeLine{01156\ \ \ \ \ \textcolor{keywordflow}{if}\ (!internal::Base64Unescape(s2,\ \&unescaped))\ \{}
\DoxyCodeLine{01157\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01158\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}is\ not\ a\ valid\ base64\ escaped\ string"{}};}
\DoxyCodeLine{01159\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01160\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01161\ \ \ \ \ \}}
\DoxyCodeLine{01162\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(unescaped,\ internal\_matcher\_,\ listener);}
\DoxyCodeLine{01163\ \ \ \}}
\DoxyCodeLine{01164\ }
\DoxyCodeLine{01165\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01166\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}matches\ after\ Base64Unescape\ "{}};}
\DoxyCodeLine{01167\ \ \ \ \ internal\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{01168\ \ \ \}}
\DoxyCodeLine{01169\ }
\DoxyCodeLine{01170\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01171\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ match\ after\ Base64Unescape\ "{}};}
\DoxyCodeLine{01172\ \ \ \ \ internal\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{01173\ \ \ \}}
\DoxyCodeLine{01174\ }
\DoxyCodeLine{01175\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01176\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ internal\_matcher\_;}
\DoxyCodeLine{01177\ \};}
\DoxyCodeLine{01178\ }
\DoxyCodeLine{01179\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ compares\ the\ two\ fields\ of\ a\ 2-\/tuple}}
\DoxyCodeLine{01180\ \textcolor{comment}{//\ using\ one\ of\ the\ ==,\ <=,\ <,\ etc,\ operators.\ \ The\ two\ fields\ being}}
\DoxyCodeLine{01181\ \textcolor{comment}{//\ compared\ don't\ have\ to\ have\ the\ same\ type.}}
\DoxyCodeLine{01182\ \textcolor{comment}{//}}
\DoxyCodeLine{01183\ \textcolor{comment}{//\ The\ matcher\ defined\ here\ is\ polymorphic\ (for\ example,\ Eq()\ can\ be}}
\DoxyCodeLine{01184\ \textcolor{comment}{//\ used\ to\ match\ a\ std::tuple<int,\ short>,\ a\ std::tuple<const\ long\&,\ double>,}}
\DoxyCodeLine{01185\ \textcolor{comment}{//\ etc).\ \ Therefore\ we\ use\ a\ template\ type\ conversion\ operator\ in\ the}}
\DoxyCodeLine{01186\ \textcolor{comment}{//\ implementation.}}
\DoxyCodeLine{01187\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ D,\ \textcolor{keyword}{typename}\ Op>}
\DoxyCodeLine{01188\ \textcolor{keyword}{class\ }PairMatchBase\ \{}
\DoxyCodeLine{01189\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01190\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01191\ \ \ \textcolor{keyword}{operator}\ Matcher<::std::tuple<T1,\ T2>>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01192\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<::std::tuple<T1,\ T2>>(\textcolor{keyword}{new}\ Impl<const\ ::std::tuple<T1,\ T2>\&>);}
\DoxyCodeLine{01193\ \ \ \}}
\DoxyCodeLine{01194\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01195\ \ \ \textcolor{keyword}{operator}\ Matcher<const\ ::std::tuple<T1,\ T2>\&>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01196\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<const\ ::std::tuple<T1,\ T2>\&>);}
\DoxyCodeLine{01197\ \ \ \}}
\DoxyCodeLine{01198\ }
\DoxyCodeLine{01199\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01200\ \ \ static\ ::std::ostream\&\ GetDesc(::std::ostream\&\ os)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01201\ \ \ \ \ \textcolor{keywordflow}{return}\ os\ <<\ D::Desc();}
\DoxyCodeLine{01202\ \ \ \}}
\DoxyCodeLine{01203\ }
\DoxyCodeLine{01204\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple>}
\DoxyCodeLine{01205\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Tuple>\ \{}
\DoxyCodeLine{01206\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01207\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Tuple\ args,}
\DoxyCodeLine{01208\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01209\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ Op()(::std::get<0>(args),\ ::std::get<1>(args));}
\DoxyCodeLine{01210\ \ \ \ \ \}}
\DoxyCodeLine{01211\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01212\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01213\ \ \ \ \ \}}
\DoxyCodeLine{01214\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01215\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}aren't\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01216\ \ \ \ \ \}}
\DoxyCodeLine{01217\ \ \ \};}
\DoxyCodeLine{01218\ \};}
\DoxyCodeLine{01219\ }
\DoxyCodeLine{01220\ \textcolor{keyword}{class\ }Eq2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Eq2Matcher,\ std::equal\_to<>>\ \{}
\DoxyCodeLine{01221\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01222\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}an\ equal\ pair"{}};\ \}}
\DoxyCodeLine{01223\ \};}
\DoxyCodeLine{01224\ \textcolor{keyword}{class\ }Ne2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Ne2Matcher,\ std::not\_equal\_to<>>\ \{}
\DoxyCodeLine{01225\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01226\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}an\ unequal\ pair"{}};\ \}}
\DoxyCodeLine{01227\ \};}
\DoxyCodeLine{01228\ \textcolor{keyword}{class\ }Lt2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Lt2Matcher,\ std::less<>>\ \{}
\DoxyCodeLine{01229\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01230\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ <\ the\ second"{}};\ \}}
\DoxyCodeLine{01231\ \};}
\DoxyCodeLine{01232\ \textcolor{keyword}{class\ }Gt2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Gt2Matcher,\ std::greater<>>\ \{}
\DoxyCodeLine{01233\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01234\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ >\ the\ second"{}};\ \}}
\DoxyCodeLine{01235\ \};}
\DoxyCodeLine{01236\ \textcolor{keyword}{class\ }Le2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Le2Matcher,\ std::less\_equal<>>\ \{}
\DoxyCodeLine{01237\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01238\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ <=\ the\ second"{}};\ \}}
\DoxyCodeLine{01239\ \};}
\DoxyCodeLine{01240\ \textcolor{keyword}{class\ }Ge2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Ge2Matcher,\ std::greater\_equal<>>\ \{}
\DoxyCodeLine{01241\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01242\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ >=\ the\ second"{}};\ \}}
\DoxyCodeLine{01243\ \};}
\DoxyCodeLine{01244\ }
\DoxyCodeLine{01245\ \textcolor{comment}{//\ Implements\ the\ Not(...)\ matcher\ for\ a\ particular\ argument\ type\ T.}}
\DoxyCodeLine{01246\ \textcolor{comment}{//\ We\ do\ not\ nest\ it\ inside\ the\ NotMatcher\ class\ template,\ as\ that}}
\DoxyCodeLine{01247\ \textcolor{comment}{//\ will\ prevent\ different\ instantiations\ of\ NotMatcher\ from\ sharing}}
\DoxyCodeLine{01248\ \textcolor{comment}{//\ the\ same\ NotMatcherImpl<T>\ class.}}
\DoxyCodeLine{01249\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01250\ \textcolor{keyword}{class\ }NotMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<const\ T\&>\ \{}
\DoxyCodeLine{01251\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01252\ \ \ \textcolor{keyword}{explicit}\ NotMatcherImpl(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01253\ }
\DoxyCodeLine{01254\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{01255\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01256\ \ \ \ \ \textcolor{keywordflow}{return}\ !matcher\_.MatchAndExplain(x,\ listener);}
\DoxyCodeLine{01257\ \ \ \}}
\DoxyCodeLine{01258\ }
\DoxyCodeLine{01259\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01260\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{01261\ \ \ \}}
\DoxyCodeLine{01262\ }
\DoxyCodeLine{01263\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01264\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01265\ \ \ \}}
\DoxyCodeLine{01266\ }
\DoxyCodeLine{01267\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01268\ \ \ \textcolor{keyword}{const}\ Matcher<T>\ matcher\_;}
\DoxyCodeLine{01269\ \};}
\DoxyCodeLine{01270\ }
\DoxyCodeLine{01271\ \textcolor{comment}{//\ Implements\ the\ Not(m)\ matcher,\ which\ matches\ a\ value\ that\ doesn't}}
\DoxyCodeLine{01272\ \textcolor{comment}{//\ match\ matcher\ m.}}
\DoxyCodeLine{01273\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{01274\ \textcolor{keyword}{class\ }NotMatcher\ \{}
\DoxyCodeLine{01275\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01276\ \ \ \textcolor{keyword}{explicit}\ NotMatcher(InnerMatcher\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01277\ }
\DoxyCodeLine{01278\ \ \ \textcolor{comment}{//\ This\ template\ type\ conversion\ operator\ allows\ Not(m)\ to\ be\ used}}
\DoxyCodeLine{01279\ \ \ \textcolor{comment}{//\ to\ match\ any\ type\ m\ can\ match.}}
\DoxyCodeLine{01280\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01281\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01282\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ NotMatcherImpl<T>(SafeMatcherCast<T>(matcher\_)));}
\DoxyCodeLine{01283\ \ \ \}}
\DoxyCodeLine{01284\ }
\DoxyCodeLine{01285\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01286\ \ \ InnerMatcher\ matcher\_;}
\DoxyCodeLine{01287\ \};}
\DoxyCodeLine{01288\ }
\DoxyCodeLine{01289\ \textcolor{comment}{//\ Implements\ the\ AllOf(m1,\ m2)\ matcher\ for\ a\ particular\ argument\ type}}
\DoxyCodeLine{01290\ \textcolor{comment}{//\ T.\ We\ do\ not\ nest\ it\ inside\ the\ BothOfMatcher\ class\ template,\ as}}
\DoxyCodeLine{01291\ \textcolor{comment}{//\ that\ will\ prevent\ different\ instantiations\ of\ BothOfMatcher\ from}}
\DoxyCodeLine{01292\ \textcolor{comment}{//\ sharing\ the\ same\ BothOfMatcherImpl<T>\ class.}}
\DoxyCodeLine{01293\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01294\ \textcolor{keyword}{class\ }AllOfMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<const\ T\&>\ \{}
\DoxyCodeLine{01295\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01296\ \ \ \textcolor{keyword}{explicit}\ AllOfMatcherImpl(std::vector<Matcher<T>>\ matchers)}
\DoxyCodeLine{01297\ \ \ \ \ \ \ :\ matchers\_(std::move(matchers))\ \{\}}
\DoxyCodeLine{01298\ }
\DoxyCodeLine{01299\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01300\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01301\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01302\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ and\ ("{}};}
\DoxyCodeLine{01303\ \ \ \ \ \ \ matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{01304\ \ \ \ \ \}}
\DoxyCodeLine{01305\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01306\ \ \ \}}
\DoxyCodeLine{01307\ }
\DoxyCodeLine{01308\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01309\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01310\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01311\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ or\ ("{}};}
\DoxyCodeLine{01312\ \ \ \ \ \ \ matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{01313\ \ \ \ \ \}}
\DoxyCodeLine{01314\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01315\ \ \ \}}
\DoxyCodeLine{01316\ }
\DoxyCodeLine{01317\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{01318\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01319\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{01320\ \ \ \ \ \ \ \textcolor{comment}{//\ Fast\ path\ to\ avoid\ unnecessary\ formatting.}}
\DoxyCodeLine{01321\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ Matcher<T>\&\ matcher\ :\ matchers\_)\ \{}
\DoxyCodeLine{01322\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!matcher.Matches(x))\ \{}
\DoxyCodeLine{01323\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01324\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01325\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01326\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01327\ \ \ \ \ \}}
\DoxyCodeLine{01328\ \ \ \ \ \textcolor{comment}{//\ This\ method\ uses\ matcher's\ explanation\ when\ explaining\ the\ result.}}
\DoxyCodeLine{01329\ \ \ \ \ \textcolor{comment}{//\ However,\ if\ matcher\ doesn't\ provide\ one,\ this\ method\ uses\ matcher's}}
\DoxyCodeLine{01330\ \ \ \ \ \textcolor{comment}{//\ description.}}
\DoxyCodeLine{01331\ \ \ \ \ std::string\ all\_match\_result;}
\DoxyCodeLine{01332\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ Matcher<T>\&\ matcher\ :\ matchers\_)\ \{}
\DoxyCodeLine{01333\ \ \ \ \ \ \ StringMatchResultListener\ slistener;}
\DoxyCodeLine{01334\ \ \ \ \ \ \ \textcolor{comment}{//\ Return\ explanation\ for\ first\ failed\ matcher.}}
\DoxyCodeLine{01335\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!matcher.MatchAndExplain(x,\ \&slistener))\ \{}
\DoxyCodeLine{01336\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\ explanation\ =\ slistener.str();}
\DoxyCodeLine{01337\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!explanation.empty())\ \{}
\DoxyCodeLine{01338\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ explanation;}
\DoxyCodeLine{01339\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01340\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ doesn't\ match\ ("{}}\ <<\ Describe(matcher)\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01341\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01342\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01343\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01344\ \ \ \ \ \ \ \textcolor{comment}{//\ Keep\ track\ of\ explanations\ in\ case\ all\ matchers\ succeed.}}
\DoxyCodeLine{01345\ \ \ \ \ \ \ std::string\ explanation\ =\ slistener.str();}
\DoxyCodeLine{01346\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (explanation.empty())\ \{}
\DoxyCodeLine{01347\ \ \ \ \ \ \ \ \ explanation\ =\ Describe(matcher);}
\DoxyCodeLine{01348\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01349\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (all\_match\_result.empty())\ \{}
\DoxyCodeLine{01350\ \ \ \ \ \ \ \ \ all\_match\_result\ =\ explanation;}
\DoxyCodeLine{01351\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01352\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!explanation.empty())\ \{}
\DoxyCodeLine{01353\ \ \ \ \ \ \ \ \ \ \ all\_match\_result\ +=\ \textcolor{stringliteral}{"{},\ and\ "{}};}
\DoxyCodeLine{01354\ \ \ \ \ \ \ \ \ \ \ all\_match\_result\ +=\ explanation;}
\DoxyCodeLine{01355\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01356\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01357\ \ \ \ \ \}}
\DoxyCodeLine{01358\ }
\DoxyCodeLine{01359\ \ \ \ \ *listener\ <<\ all\_match\_result;}
\DoxyCodeLine{01360\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01361\ \ \ \}}
\DoxyCodeLine{01362\ }
\DoxyCodeLine{01363\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01364\ \ \ \textcolor{comment}{//\ Returns\ matcher\ description\ as\ a\ string.}}
\DoxyCodeLine{01365\ \ \ std::string\ Describe(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01366\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{01367\ \ \ \ \ matcher.DescribeTo(listener.stream());}
\DoxyCodeLine{01368\ \ \ \ \ \textcolor{keywordflow}{return}\ listener.str();}
\DoxyCodeLine{01369\ \ \ \}}
\DoxyCodeLine{01370\ \ \ \textcolor{keyword}{const}\ std::vector<Matcher<T>>\ matchers\_;}
\DoxyCodeLine{01371\ \};}
\DoxyCodeLine{01372\ }
\DoxyCodeLine{01373\ \textcolor{comment}{//\ VariadicMatcher\ is\ used\ for\ the\ variadic\ implementation\ of}}
\DoxyCodeLine{01374\ \textcolor{comment}{//\ AllOf(m\_1,\ m\_2,\ ...)\ and\ AnyOf(m\_1,\ m\_2,\ ...).}}
\DoxyCodeLine{01375\ \textcolor{comment}{//\ CombiningMatcher<T>\ is\ used\ to\ recursively\ combine\ the\ provided\ matchers}}
\DoxyCodeLine{01376\ \textcolor{comment}{//\ (of\ type\ Args...).}}
\DoxyCodeLine{01377\ \textcolor{keyword}{template}\ <\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{class\ }CombiningMatcher,\ \textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{01378\ \textcolor{keyword}{class\ }VariadicMatcher\ \{}
\DoxyCodeLine{01379\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01380\ \ \ VariadicMatcher(\textcolor{keyword}{const}\ Args\&...\ matchers)\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01381\ \ \ \ \ \ \ :\ matchers\_(matchers...)\ \{}
\DoxyCodeLine{01382\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}...(Args)\ >\ 0,\ \textcolor{stringliteral}{"{}Must\ have\ at\ least\ one\ matcher."{}});}
\DoxyCodeLine{01383\ \ \ \}}
\DoxyCodeLine{01384\ }
\DoxyCodeLine{01385\ \ \ VariadicMatcher(\textcolor{keyword}{const}\ VariadicMatcher\&)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{01386\ \ \ VariadicMatcher\&\ operator=(\textcolor{keyword}{const}\ VariadicMatcher\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{01387\ }
\DoxyCodeLine{01388\ \ \ \textcolor{comment}{//\ This\ template\ type\ conversion\ operator\ allows\ an}}
\DoxyCodeLine{01389\ \ \ \textcolor{comment}{//\ VariadicMatcher<Matcher1,\ Matcher2...>\ object\ to\ match\ any\ type\ that}}
\DoxyCodeLine{01390\ \ \ \textcolor{comment}{//\ all\ of\ the\ provided\ matchers\ (Matcher1,\ Matcher2,\ ...)\ can\ match.}}
\DoxyCodeLine{01391\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01392\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01393\ \ \ \ \ std::vector<Matcher<T>>\ values;}
\DoxyCodeLine{01394\ \ \ \ \ CreateVariadicMatcher<T>(\&values,\ std::integral\_constant<size\_t,\ 0>());}
\DoxyCodeLine{01395\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ CombiningMatcher<T>(std::move(values)));}
\DoxyCodeLine{01396\ \ \ \}}
\DoxyCodeLine{01397\ }
\DoxyCodeLine{01398\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01399\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ I>}
\DoxyCodeLine{01400\ \ \ \textcolor{keywordtype}{void}\ CreateVariadicMatcher(std::vector<Matcher<T>>*\ values,}
\DoxyCodeLine{01401\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::integral\_constant<size\_t,\ I>)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01402\ \ \ \ \ values-\/>push\_back(SafeMatcherCast<T>(std::get<I>(matchers\_)));}
\DoxyCodeLine{01403\ \ \ \ \ CreateVariadicMatcher<T>(values,\ std::integral\_constant<size\_t,\ I\ +\ 1>());}
\DoxyCodeLine{01404\ \ \ \}}
\DoxyCodeLine{01405\ }
\DoxyCodeLine{01406\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01407\ \ \ \textcolor{keywordtype}{void}\ CreateVariadicMatcher(}
\DoxyCodeLine{01408\ \ \ \ \ \ \ std::vector<Matcher<T>>*,}
\DoxyCodeLine{01409\ \ \ \ \ \ \ std::integral\_constant<\textcolor{keywordtype}{size\_t},\ \textcolor{keyword}{sizeof}...(Args)>)\textcolor{keyword}{\ const\ }\{\}}
\DoxyCodeLine{01410\ }
\DoxyCodeLine{01411\ \ \ std::tuple<Args...>\ matchers\_;}
\DoxyCodeLine{01412\ \};}
\DoxyCodeLine{01413\ }
\DoxyCodeLine{01414\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{01415\ \textcolor{keyword}{using\ }AllOfMatcher\ =\ VariadicMatcher<AllOfMatcherImpl,\ Args...>;}
\DoxyCodeLine{01416\ }
\DoxyCodeLine{01417\ \textcolor{comment}{//\ Implements\ the\ AnyOf(m1,\ m2)\ matcher\ for\ a\ particular\ argument\ type}}
\DoxyCodeLine{01418\ \textcolor{comment}{//\ T.\ \ We\ do\ not\ nest\ it\ inside\ the\ AnyOfMatcher\ class\ template,\ as}}
\DoxyCodeLine{01419\ \textcolor{comment}{//\ that\ will\ prevent\ different\ instantiations\ of\ AnyOfMatcher\ from}}
\DoxyCodeLine{01420\ \textcolor{comment}{//\ sharing\ the\ same\ EitherOfMatcherImpl<T>\ class.}}
\DoxyCodeLine{01421\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01422\ \textcolor{keyword}{class\ }AnyOfMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<const\ T\&>\ \{}
\DoxyCodeLine{01423\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01424\ \ \ \textcolor{keyword}{explicit}\ AnyOfMatcherImpl(std::vector<Matcher<T>>\ matchers)}
\DoxyCodeLine{01425\ \ \ \ \ \ \ :\ matchers\_(std::move(matchers))\ \{\}}
\DoxyCodeLine{01426\ }
\DoxyCodeLine{01427\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01428\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01429\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01430\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ or\ ("{}};}
\DoxyCodeLine{01431\ \ \ \ \ \ \ matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{01432\ \ \ \ \ \}}
\DoxyCodeLine{01433\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01434\ \ \ \}}
\DoxyCodeLine{01435\ }
\DoxyCodeLine{01436\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01437\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01438\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01439\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ and\ ("{}};}
\DoxyCodeLine{01440\ \ \ \ \ \ \ matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{01441\ \ \ \ \ \}}
\DoxyCodeLine{01442\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01443\ \ \ \}}
\DoxyCodeLine{01444\ }
\DoxyCodeLine{01445\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{01446\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01447\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{01448\ \ \ \ \ \ \ \textcolor{comment}{//\ Fast\ path\ to\ avoid\ unnecessary\ formatting\ of\ match\ explanations.}}
\DoxyCodeLine{01449\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ Matcher<T>\&\ matcher\ :\ matchers\_)\ \{}
\DoxyCodeLine{01450\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matcher.Matches(x))\ \{}
\DoxyCodeLine{01451\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01452\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01453\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01454\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01455\ \ \ \ \ \}}
\DoxyCodeLine{01456\ \ \ \ \ \textcolor{comment}{//\ This\ method\ uses\ matcher's\ explanation\ when\ explaining\ the\ result.}}
\DoxyCodeLine{01457\ \ \ \ \ \textcolor{comment}{//\ However,\ if\ matcher\ doesn't\ provide\ one,\ this\ method\ uses\ matcher's}}
\DoxyCodeLine{01458\ \ \ \ \ \textcolor{comment}{//\ description.}}
\DoxyCodeLine{01459\ \ \ \ \ std::string\ no\_match\_result;}
\DoxyCodeLine{01460\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ Matcher<T>\&\ matcher\ :\ matchers\_)\ \{}
\DoxyCodeLine{01461\ \ \ \ \ \ \ StringMatchResultListener\ slistener;}
\DoxyCodeLine{01462\ \ \ \ \ \ \ \textcolor{comment}{//\ Return\ explanation\ for\ first\ match.}}
\DoxyCodeLine{01463\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matcher.MatchAndExplain(x,\ \&slistener))\ \{}
\DoxyCodeLine{01464\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\ explanation\ =\ slistener.str();}
\DoxyCodeLine{01465\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!explanation.empty())\ \{}
\DoxyCodeLine{01466\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ explanation;}
\DoxyCodeLine{01467\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01468\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ matches\ ("{}}\ <<\ Describe(matcher)\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01469\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01470\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01471\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01472\ \ \ \ \ \ \ \textcolor{comment}{//\ Keep\ track\ of\ explanations\ in\ case\ there\ is\ no\ match.}}
\DoxyCodeLine{01473\ \ \ \ \ \ \ std::string\ explanation\ =\ slistener.str();}
\DoxyCodeLine{01474\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (explanation.empty())\ \{}
\DoxyCodeLine{01475\ \ \ \ \ \ \ \ \ explanation\ =\ DescribeNegation(matcher);}
\DoxyCodeLine{01476\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01477\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (no\_match\_result.empty())\ \{}
\DoxyCodeLine{01478\ \ \ \ \ \ \ \ \ no\_match\_result\ =\ explanation;}
\DoxyCodeLine{01479\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01480\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!explanation.empty())\ \{}
\DoxyCodeLine{01481\ \ \ \ \ \ \ \ \ \ \ no\_match\_result\ +=\ \textcolor{stringliteral}{"{},\ and\ "{}};}
\DoxyCodeLine{01482\ \ \ \ \ \ \ \ \ \ \ no\_match\_result\ +=\ explanation;}
\DoxyCodeLine{01483\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01484\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01485\ \ \ \ \ \}}
\DoxyCodeLine{01486\ }
\DoxyCodeLine{01487\ \ \ \ \ *listener\ <<\ no\_match\_result;}
\DoxyCodeLine{01488\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01489\ \ \ \}}
\DoxyCodeLine{01490\ }
\DoxyCodeLine{01491\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01492\ \ \ \textcolor{comment}{//\ Returns\ matcher\ description\ as\ a\ string.}}
\DoxyCodeLine{01493\ \ \ std::string\ Describe(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01494\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{01495\ \ \ \ \ matcher.DescribeTo(listener.stream());}
\DoxyCodeLine{01496\ \ \ \ \ \textcolor{keywordflow}{return}\ listener.str();}
\DoxyCodeLine{01497\ \ \ \}}
\DoxyCodeLine{01498\ }
\DoxyCodeLine{01499\ \ \ std::string\ DescribeNegation(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01500\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{01501\ \ \ \ \ matcher.DescribeNegationTo(listener.stream());}
\DoxyCodeLine{01502\ \ \ \ \ \textcolor{keywordflow}{return}\ listener.str();}
\DoxyCodeLine{01503\ \ \ \}}
\DoxyCodeLine{01504\ }
\DoxyCodeLine{01505\ \ \ \textcolor{keyword}{const}\ std::vector<Matcher<T>>\ matchers\_;}
\DoxyCodeLine{01506\ \};}
\DoxyCodeLine{01507\ }
\DoxyCodeLine{01508\ \textcolor{comment}{//\ AnyOfMatcher\ is\ used\ for\ the\ variadic\ implementation\ of\ AnyOf(m\_1,\ m\_2,\ ...).}}
\DoxyCodeLine{01509\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{01510\ \textcolor{keyword}{using\ }AnyOfMatcher\ =\ VariadicMatcher<AnyOfMatcherImpl,\ Args...>;}
\DoxyCodeLine{01511\ }
\DoxyCodeLine{01512\ \textcolor{comment}{//\ ConditionalMatcher\ is\ the\ implementation\ of\ Conditional(cond,\ m1,\ m2)}}
\DoxyCodeLine{01513\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTrue,\ \textcolor{keyword}{typename}\ MatcherFalse>}
\DoxyCodeLine{01514\ \textcolor{keyword}{class\ }ConditionalMatcher\ \{}
\DoxyCodeLine{01515\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01516\ \ \ ConditionalMatcher(\textcolor{keywordtype}{bool}\ condition,\ MatcherTrue\ matcher\_true,}
\DoxyCodeLine{01517\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatcherFalse\ matcher\_false)}
\DoxyCodeLine{01518\ \ \ \ \ \ \ :\ condition\_(condition),}
\DoxyCodeLine{01519\ \ \ \ \ \ \ \ \ matcher\_true\_(std::move(matcher\_true)),}
\DoxyCodeLine{01520\ \ \ \ \ \ \ \ \ matcher\_false\_(std::move(matcher\_false))\ \{\}}
\DoxyCodeLine{01521\ }
\DoxyCodeLine{01522\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01523\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT(runtime/explicit)}}
\DoxyCodeLine{01524\ \ \ \ \ \textcolor{keywordflow}{return}\ condition\_\ ?\ SafeMatcherCast<T>(matcher\_true\_)}
\DoxyCodeLine{01525\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ SafeMatcherCast<T>(matcher\_false\_);}
\DoxyCodeLine{01526\ \ \ \}}
\DoxyCodeLine{01527\ }
\DoxyCodeLine{01528\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01529\ \ \ \textcolor{keywordtype}{bool}\ condition\_;}
\DoxyCodeLine{01530\ \ \ MatcherTrue\ matcher\_true\_;}
\DoxyCodeLine{01531\ \ \ MatcherFalse\ matcher\_false\_;}
\DoxyCodeLine{01532\ \};}
\DoxyCodeLine{01533\ }
\DoxyCodeLine{01534\ \textcolor{comment}{//\ Wrapper\ for\ implementation\ of\ Any/AllOfArray().}}
\DoxyCodeLine{01535\ \textcolor{keyword}{template}\ <\textcolor{keyword}{template}\ <\textcolor{keyword}{class}>\ \textcolor{keyword}{class\ }MatcherImpl,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01536\ \textcolor{keyword}{class\ }SomeOfArrayMatcher\ \{}
\DoxyCodeLine{01537\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01538\ \ \ \textcolor{comment}{//\ Constructs\ the\ matcher\ from\ a\ sequence\ of\ element\ values\ or}}
\DoxyCodeLine{01539\ \ \ \textcolor{comment}{//\ element\ matchers.}}
\DoxyCodeLine{01540\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{01541\ \ \ SomeOfArrayMatcher(Iter\ first,\ Iter\ last)\ :\ matchers\_(first,\ last)\ \{\}}
\DoxyCodeLine{01542\ }
\DoxyCodeLine{01543\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01544\ \ \ \textcolor{keyword}{operator}\ Matcher<U>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01545\ \ \ \ \ \textcolor{keyword}{using\ }RawU\ =\ \textcolor{keyword}{typename}\ std::decay<U>::type;}
\DoxyCodeLine{01546\ \ \ \ \ std::vector<Matcher<RawU>>\ matchers;}
\DoxyCodeLine{01547\ \ \ \ \ matchers.reserve(matchers\_.size());}
\DoxyCodeLine{01548\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ matcher\ :\ matchers\_)\ \{}
\DoxyCodeLine{01549\ \ \ \ \ \ \ matchers.push\_back(MatcherCast<RawU>(matcher));}
\DoxyCodeLine{01550\ \ \ \ \ \}}
\DoxyCodeLine{01551\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<U>(\textcolor{keyword}{new}\ MatcherImpl<RawU>(std::move(matchers)));}
\DoxyCodeLine{01552\ \ \ \}}
\DoxyCodeLine{01553\ }
\DoxyCodeLine{01554\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01555\ \ \ \textcolor{keyword}{const}\ std::vector<std::remove\_const\_t<T>>\ matchers\_;}
\DoxyCodeLine{01556\ \};}
\DoxyCodeLine{01557\ }
\DoxyCodeLine{01558\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01559\ \textcolor{keyword}{using\ }AllOfArrayMatcher\ =\ SomeOfArrayMatcher<AllOfMatcherImpl,\ T>;}
\DoxyCodeLine{01560\ }
\DoxyCodeLine{01561\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01562\ \textcolor{keyword}{using\ }AnyOfArrayMatcher\ =\ SomeOfArrayMatcher<AnyOfMatcherImpl,\ T>;}
\DoxyCodeLine{01563\ }
\DoxyCodeLine{01564\ \textcolor{comment}{//\ Used\ for\ implementing\ Truly(pred),\ which\ turns\ a\ predicate\ into\ a}}
\DoxyCodeLine{01565\ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{01566\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Predicate>}
\DoxyCodeLine{01567\ \textcolor{keyword}{class\ }TrulyMatcher\ \{}
\DoxyCodeLine{01568\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01569\ \ \ \textcolor{keyword}{explicit}\ TrulyMatcher(Predicate\ pred)\ :\ predicate\_(pred)\ \{\}}
\DoxyCodeLine{01570\ }
\DoxyCodeLine{01571\ \ \ \textcolor{comment}{//\ This\ method\ template\ allows\ Truly(pred)\ to\ be\ used\ as\ a\ matcher}}
\DoxyCodeLine{01572\ \ \ \textcolor{comment}{//\ for\ type\ T\ where\ T\ is\ the\ argument\ type\ of\ predicate\ 'pred'.\ \ The}}
\DoxyCodeLine{01573\ \ \ \textcolor{comment}{//\ argument\ is\ passed\ by\ reference\ as\ the\ predicate\ may\ be}}
\DoxyCodeLine{01574\ \ \ \textcolor{comment}{//\ interested\ in\ the\ address\ of\ the\ argument.}}
\DoxyCodeLine{01575\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01576\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\&\ x,\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01577\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01578\ \ \ \ \ \textcolor{comment}{//\ Without\ the\ if-\/statement,\ MSVC\ sometimes\ warns\ about\ converting}}
\DoxyCodeLine{01579\ \ \ \ \ \textcolor{comment}{//\ a\ value\ to\ bool\ (warning\ 4800).}}
\DoxyCodeLine{01580\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01581\ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ write\ 'return\ !!predicate\_(x);'\ as\ that\ doesn't\ work}}
\DoxyCodeLine{01582\ \ \ \ \ \textcolor{comment}{//\ when\ predicate\_(x)\ returns\ a\ class\ convertible\ to\ bool\ but}}
\DoxyCodeLine{01583\ \ \ \ \ \textcolor{comment}{//\ having\ no\ operator!().}}
\DoxyCodeLine{01584\ \ \ \ \ \textcolor{keywordflow}{if}\ (predicate\_(x))\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01585\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}didn't\ satisfy\ the\ given\ predicate"{}};}
\DoxyCodeLine{01586\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01587\ \ \ \}}
\DoxyCodeLine{01588\ }
\DoxyCodeLine{01589\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01590\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}satisfies\ the\ given\ predicate"{}};}
\DoxyCodeLine{01591\ \ \ \}}
\DoxyCodeLine{01592\ }
\DoxyCodeLine{01593\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01594\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ satisfy\ the\ given\ predicate"{}};}
\DoxyCodeLine{01595\ \ \ \}}
\DoxyCodeLine{01596\ }
\DoxyCodeLine{01597\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01598\ \ \ Predicate\ predicate\_;}
\DoxyCodeLine{01599\ \};}
\DoxyCodeLine{01600\ }
\DoxyCodeLine{01601\ \textcolor{comment}{//\ Used\ for\ implementing\ Matches(matcher),\ which\ turns\ a\ matcher\ into}}
\DoxyCodeLine{01602\ \textcolor{comment}{//\ a\ predicate.}}
\DoxyCodeLine{01603\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{01604\ \textcolor{keyword}{class\ }MatcherAsPredicate\ \{}
\DoxyCodeLine{01605\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01606\ \ \ \textcolor{keyword}{explicit}\ MatcherAsPredicate(M\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01607\ }
\DoxyCodeLine{01608\ \ \ \textcolor{comment}{//\ This\ template\ operator()\ allows\ Matches(m)\ to\ be\ used\ as\ a}}
\DoxyCodeLine{01609\ \ \ \textcolor{comment}{//\ predicate\ on\ type\ T\ where\ m\ is\ a\ matcher\ on\ type\ T.}}
\DoxyCodeLine{01610\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01611\ \ \ \textcolor{comment}{//\ The\ argument\ x\ is\ passed\ by\ reference\ instead\ of\ by\ value,\ as}}
\DoxyCodeLine{01612\ \ \ \textcolor{comment}{//\ some\ matcher\ may\ be\ interested\ in\ its\ address\ (e.g.\ as\ in}}
\DoxyCodeLine{01613\ \ \ \textcolor{comment}{//\ Matches(Ref(n))(x)).}}
\DoxyCodeLine{01614\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01615\ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keyword}{const}\ T\&\ x)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01616\ \ \ \ \ \textcolor{comment}{//\ We\ let\ matcher\_\ commit\ to\ a\ particular\ type\ here\ instead\ of}}
\DoxyCodeLine{01617\ \ \ \ \ \textcolor{comment}{//\ when\ the\ MatcherAsPredicate\ object\ was\ constructed.\ \ This}}
\DoxyCodeLine{01618\ \ \ \ \ \textcolor{comment}{//\ allows\ us\ to\ write\ Matches(m)\ where\ m\ is\ a\ polymorphic\ matcher}}
\DoxyCodeLine{01619\ \ \ \ \ \textcolor{comment}{//\ (e.g.\ Eq(5)).}}
\DoxyCodeLine{01620\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01621\ \ \ \ \ \textcolor{comment}{//\ If\ we\ write\ Matcher<T>(matcher\_).Matches(x)\ here,\ it\ won't}}
\DoxyCodeLine{01622\ \ \ \ \ \textcolor{comment}{//\ compile\ when\ matcher\_\ has\ type\ Matcher<const\ T\&>;\ if\ we\ write}}
\DoxyCodeLine{01623\ \ \ \ \ \textcolor{comment}{//\ Matcher<const\ T\&>(matcher\_).Matches(x)\ here,\ it\ won't\ compile}}
\DoxyCodeLine{01624\ \ \ \ \ \textcolor{comment}{//\ when\ matcher\_\ has\ type\ Matcher<T>;\ if\ we\ just\ write}}
\DoxyCodeLine{01625\ \ \ \ \ \textcolor{comment}{//\ matcher\_.Matches(x),\ it\ won't\ compile\ when\ matcher\_\ is}}
\DoxyCodeLine{01626\ \ \ \ \ \textcolor{comment}{//\ polymorphic,\ e.g.\ Eq(5).}}
\DoxyCodeLine{01627\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01628\ \ \ \ \ \textcolor{comment}{//\ MatcherCast<const\ T\&>()\ is\ necessary\ for\ making\ the\ code\ work}}
\DoxyCodeLine{01629\ \ \ \ \ \textcolor{comment}{//\ in\ all\ of\ the\ above\ situations.}}
\DoxyCodeLine{01630\ \ \ \ \ \textcolor{keywordflow}{return}\ MatcherCast<const\ T\&>(matcher\_).Matches(x);}
\DoxyCodeLine{01631\ \ \ \}}
\DoxyCodeLine{01632\ }
\DoxyCodeLine{01633\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01634\ \ \ M\ matcher\_;}
\DoxyCodeLine{01635\ \};}
\DoxyCodeLine{01636\ }
\DoxyCodeLine{01637\ \textcolor{comment}{//\ For\ implementing\ ASSERT\_THAT()\ and\ EXPECT\_THAT().\ \ The\ template}}
\DoxyCodeLine{01638\ \textcolor{comment}{//\ argument\ M\ must\ be\ a\ type\ that\ can\ be\ converted\ to\ a\ matcher.}}
\DoxyCodeLine{01639\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{01640\ \textcolor{keyword}{class\ }PredicateFormatterFromMatcher\ \{}
\DoxyCodeLine{01641\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01642\ \ \ \textcolor{keyword}{explicit}\ PredicateFormatterFromMatcher(M\ m)\ :\ matcher\_(std::move(m))\ \{\}}
\DoxyCodeLine{01643\ }
\DoxyCodeLine{01644\ \ \ \textcolor{comment}{//\ This\ template\ ()\ operator\ allows\ a\ PredicateFormatterFromMatcher}}
\DoxyCodeLine{01645\ \ \ \textcolor{comment}{//\ object\ to\ act\ as\ a\ predicate-\/formatter\ suitable\ for\ using\ with}}
\DoxyCodeLine{01646\ \ \ \textcolor{comment}{//\ Google\ Test's\ EXPECT\_PRED\_FORMAT1()\ macro.}}
\DoxyCodeLine{01647\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01648\ \ \ AssertionResult\ operator()(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ value\_text,\ \textcolor{keyword}{const}\ T\&\ x)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01649\ \ \ \ \ \textcolor{comment}{//\ We\ convert\ matcher\_\ to\ a\ Matcher<const\ T\&>\ *now*\ instead\ of}}
\DoxyCodeLine{01650\ \ \ \ \ \textcolor{comment}{//\ when\ the\ PredicateFormatterFromMatcher\ object\ was\ constructed,}}
\DoxyCodeLine{01651\ \ \ \ \ \textcolor{comment}{//\ as\ matcher\_\ may\ be\ polymorphic\ (e.g.\ NotNull())\ and\ we\ won't}}
\DoxyCodeLine{01652\ \ \ \ \ \textcolor{comment}{//\ know\ which\ type\ to\ instantiate\ it\ to\ until\ we\ actually\ see\ the}}
\DoxyCodeLine{01653\ \ \ \ \ \textcolor{comment}{//\ type\ of\ x\ here.}}
\DoxyCodeLine{01654\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01655\ \ \ \ \ \textcolor{comment}{//\ We\ write\ SafeMatcherCast<const\ T\&>(matcher\_)\ instead\ of}}
\DoxyCodeLine{01656\ \ \ \ \ \textcolor{comment}{//\ Matcher<const\ T\&>(matcher\_),\ as\ the\ latter\ won't\ compile\ when}}
\DoxyCodeLine{01657\ \ \ \ \ \textcolor{comment}{//\ matcher\_\ has\ type\ Matcher<T>\ (e.g.\ An<int>()).}}
\DoxyCodeLine{01658\ \ \ \ \ \textcolor{comment}{//\ We\ don't\ write\ MatcherCast<const\ T\&>\ either,\ as\ that\ allows}}
\DoxyCodeLine{01659\ \ \ \ \ \textcolor{comment}{//\ potentially\ unsafe\ downcasting\ of\ the\ matcher\ argument.}}
\DoxyCodeLine{01660\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ T\&>\ matcher\ =\ SafeMatcherCast<const\ T\&>(matcher\_);}
\DoxyCodeLine{01661\ }
\DoxyCodeLine{01662\ \ \ \ \ \textcolor{comment}{//\ The\ expected\ path\ here\ is\ that\ the\ matcher\ should\ match\ (i.e.\ that\ most}}
\DoxyCodeLine{01663\ \ \ \ \ \textcolor{comment}{//\ tests\ pass)\ so\ optimize\ for\ this\ case.}}
\DoxyCodeLine{01664\ \ \ \ \ \textcolor{keywordflow}{if}\ (matcher.Matches(x))\ \{}
\DoxyCodeLine{01665\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ AssertionSuccess();}
\DoxyCodeLine{01666\ \ \ \ \ \}}
\DoxyCodeLine{01667\ }
\DoxyCodeLine{01668\ \ \ \ \ ::std::stringstream\ ss;}
\DoxyCodeLine{01669\ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}Value\ of:\ "{}}\ <<\ value\_text\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{01670\ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}Expected:\ "{}};}
\DoxyCodeLine{01671\ \ \ \ \ matcher.DescribeTo(\&ss);}
\DoxyCodeLine{01672\ }
\DoxyCodeLine{01673\ \ \ \ \ \textcolor{comment}{//\ Rerun\ the\ matcher\ to\ "{}PrintAndExplain"{}\ the\ failure.}}
\DoxyCodeLine{01674\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{01675\ \ \ \ \ \textcolor{keywordflow}{if}\ (MatchPrintAndExplain(x,\ matcher,\ \&listener))\ \{}
\DoxyCodeLine{01676\ \ \ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\ \ The\ matcher\ failed\ on\ the\ initial\ attempt;\ but\ passed\ when\ "{}}}
\DoxyCodeLine{01677\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}rerun\ to\ generate\ the\ explanation."{}};}
\DoxyCodeLine{01678\ \ \ \ \ \}}
\DoxyCodeLine{01679\ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\ \ Actual:\ "{}}\ <<\ listener.str();}
\DoxyCodeLine{01680\ \ \ \ \ \textcolor{keywordflow}{return}\ AssertionFailure()\ <<\ ss.str();}
\DoxyCodeLine{01681\ \ \ \}}
\DoxyCodeLine{01682\ }
\DoxyCodeLine{01683\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01684\ \ \ \textcolor{keyword}{const}\ M\ matcher\_;}
\DoxyCodeLine{01685\ \};}
\DoxyCodeLine{01686\ }
\DoxyCodeLine{01687\ \textcolor{comment}{//\ A\ helper\ function\ for\ converting\ a\ matcher\ to\ a\ predicate-\/formatter}}
\DoxyCodeLine{01688\ \textcolor{comment}{//\ without\ the\ user\ needing\ to\ explicitly\ write\ the\ type.\ \ This\ is}}
\DoxyCodeLine{01689\ \textcolor{comment}{//\ used\ for\ implementing\ ASSERT\_THAT()\ and\ EXPECT\_THAT().}}
\DoxyCodeLine{01690\ \textcolor{comment}{//\ Implementation\ detail:\ 'matcher'\ is\ received\ by-\/value\ to\ force\ decaying.}}
\DoxyCodeLine{01691\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{01692\ \textcolor{keyword}{inline}\ PredicateFormatterFromMatcher<M>\ MakePredicateFormatterFromMatcher(}
\DoxyCodeLine{01693\ \ \ \ \ M\ matcher)\ \{}
\DoxyCodeLine{01694\ \ \ \textcolor{keywordflow}{return}\ PredicateFormatterFromMatcher<M>(std::move(matcher));}
\DoxyCodeLine{01695\ \}}
\DoxyCodeLine{01696\ }
\DoxyCodeLine{01697\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ IsNan()\ matcher,\ which\ matches\ any\ floating\ type}}
\DoxyCodeLine{01698\ \textcolor{comment}{//\ value\ that\ is\ Nan.}}
\DoxyCodeLine{01699\ \textcolor{keyword}{class\ }IsNanMatcher\ \{}
\DoxyCodeLine{01700\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01701\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>}
\DoxyCodeLine{01702\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ FloatType\&\ f,}
\DoxyCodeLine{01703\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01704\ \ \ \ \ \textcolor{keywordflow}{return}\ (::std::isnan)(f);}
\DoxyCodeLine{01705\ \ \ \}}
\DoxyCodeLine{01706\ }
\DoxyCodeLine{01707\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ NaN"{}};\ \}}
\DoxyCodeLine{01708\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NaN"{}};\ \}}
\DoxyCodeLine{01709\ \};}
\DoxyCodeLine{01710\ }
\DoxyCodeLine{01711\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ floating\ point\ equality\ matcher,\ which\ matches}}
\DoxyCodeLine{01712\ \textcolor{comment}{//\ two\ float\ values\ using\ ULP-\/based\ approximation\ or,\ optionally,\ a}}
\DoxyCodeLine{01713\ \textcolor{comment}{//\ user-\/specified\ epsilon.\ \ The\ template\ is\ meant\ to\ be\ instantiated\ with}}
\DoxyCodeLine{01714\ \textcolor{comment}{//\ FloatType\ being\ either\ float\ or\ double.}}
\DoxyCodeLine{01715\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>}
\DoxyCodeLine{01716\ \textcolor{keyword}{class\ }FloatingEqMatcher\ \{}
\DoxyCodeLine{01717\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01718\ \ \ \textcolor{comment}{//\ Constructor\ for\ FloatingEqMatcher.}}
\DoxyCodeLine{01719\ \ \ \textcolor{comment}{//\ The\ matcher's\ input\ will\ be\ compared\ with\ expected.\ \ The\ matcher\ treats\ two}}
\DoxyCodeLine{01720\ \ \ \textcolor{comment}{//\ NANs\ as\ equal\ if\ nan\_eq\_nan\ is\ true.\ \ Otherwise,\ under\ IEEE\ standards,}}
\DoxyCodeLine{01721\ \ \ \textcolor{comment}{//\ equality\ comparisons\ between\ NANs\ will\ always\ return\ false.\ \ We\ specify\ a}}
\DoxyCodeLine{01722\ \ \ \textcolor{comment}{//\ negative\ max\_abs\_error\_\ term\ to\ indicate\ that\ ULP-\/based\ approximation\ will}}
\DoxyCodeLine{01723\ \ \ \textcolor{comment}{//\ be\ used\ for\ comparison.}}
\DoxyCodeLine{01724\ \ \ FloatingEqMatcher(FloatType\ expected,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan)}
\DoxyCodeLine{01725\ \ \ \ \ \ \ :\ expected\_(expected),\ nan\_eq\_nan\_(nan\_eq\_nan),\ max\_abs\_error\_(-\/1)\ \{\}}
\DoxyCodeLine{01726\ }
\DoxyCodeLine{01727\ \ \ \textcolor{comment}{//\ Constructor\ that\ supports\ a\ user-\/specified\ max\_abs\_error\ that\ will\ be\ used}}
\DoxyCodeLine{01728\ \ \ \textcolor{comment}{//\ for\ comparison\ instead\ of\ ULP-\/based\ approximation.\ \ The\ max\ absolute}}
\DoxyCodeLine{01729\ \ \ \textcolor{comment}{//\ should\ be\ non-\/negative.}}
\DoxyCodeLine{01730\ \ \ FloatingEqMatcher(FloatType\ expected,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan,}
\DoxyCodeLine{01731\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FloatType\ max\_abs\_error)}
\DoxyCodeLine{01732\ \ \ \ \ \ \ :\ expected\_(expected),}
\DoxyCodeLine{01733\ \ \ \ \ \ \ \ \ nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{01734\ \ \ \ \ \ \ \ \ max\_abs\_error\_(max\_abs\_error)\ \{}
\DoxyCodeLine{01735\ \ \ \ \ GTEST\_CHECK\_(max\_abs\_error\ >=\ 0)}
\DoxyCodeLine{01736\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{},\ where\ max\_abs\_error\ is"{}}\ <<\ max\_abs\_error;}
\DoxyCodeLine{01737\ \ \ \}}
\DoxyCodeLine{01738\ }
\DoxyCodeLine{01739\ \ \ \textcolor{comment}{//\ Implements\ floating\ point\ equality\ matcher\ as\ a\ Matcher<T>.}}
\DoxyCodeLine{01740\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01741\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{01742\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01743\ \ \ \ \ Impl(FloatType\ expected,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan,\ FloatType\ max\_abs\_error)}
\DoxyCodeLine{01744\ \ \ \ \ \ \ \ \ :\ expected\_(expected),}
\DoxyCodeLine{01745\ \ \ \ \ \ \ \ \ \ \ nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{01746\ \ \ \ \ \ \ \ \ \ \ max\_abs\_error\_(max\_abs\_error)\ \{\}}
\DoxyCodeLine{01747\ }
\DoxyCodeLine{01748\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ value,}
\DoxyCodeLine{01749\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01750\ \ \ \ \ \ \ \textcolor{keyword}{const}\ FloatingPoint<FloatType>\ actual(value),\ expected(expected\_);}
\DoxyCodeLine{01751\ }
\DoxyCodeLine{01752\ \ \ \ \ \ \ \textcolor{comment}{//\ Compares\ NaNs\ first,\ if\ nan\_eq\_nan\_\ is\ true.}}
\DoxyCodeLine{01753\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actual.is\_nan()\ ||\ expected.is\_nan())\ \{}
\DoxyCodeLine{01754\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actual.is\_nan()\ \&\&\ expected.is\_nan())\ \{}
\DoxyCodeLine{01755\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01756\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01757\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ One\ is\ nan;\ the\ other\ is\ not\ nan.}}
\DoxyCodeLine{01758\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01759\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01760\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (HasMaxAbsError())\ \{}
\DoxyCodeLine{01761\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ perform\ an\ equality\ check\ so\ that\ inf\ will\ match\ inf,\ regardless}}
\DoxyCodeLine{01762\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ of\ error\ bounds.\ \ If\ the\ result\ of\ value\ -\/\ expected\_\ would\ result\ in}}
\DoxyCodeLine{01763\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ overflow\ or\ if\ either\ value\ is\ inf,\ the\ default\ result\ is\ infinity,}}
\DoxyCodeLine{01764\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ which\ should\ only\ match\ if\ max\_abs\_error\_\ is\ also\ infinity.}}
\DoxyCodeLine{01765\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ ==\ expected\_)\ \{}
\DoxyCodeLine{01766\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01767\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01768\ }
\DoxyCodeLine{01769\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ FloatType\ diff\ =\ value\ -\/\ expected\_;}
\DoxyCodeLine{01770\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (::std::fabs(diff)\ <=\ max\_abs\_error\_)\ \{}
\DoxyCodeLine{01771\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01772\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01773\ }
\DoxyCodeLine{01774\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{01775\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}}\ <<\ diff\ <<\ \textcolor{stringliteral}{"{}\ from\ "{}}\ <<\ expected\_;}
\DoxyCodeLine{01776\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01777\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01778\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01779\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ actual.AlmostEquals(expected);}
\DoxyCodeLine{01780\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01781\ \ \ \ \ \}}
\DoxyCodeLine{01782\ }
\DoxyCodeLine{01783\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01784\ \ \ \ \ \ \ \textcolor{comment}{//\ os-\/>precision()\ returns\ the\ previously\ set\ precision,\ which\ we}}
\DoxyCodeLine{01785\ \ \ \ \ \ \ \textcolor{comment}{//\ store\ to\ restore\ the\ ostream\ to\ its\ original\ configuration}}
\DoxyCodeLine{01786\ \ \ \ \ \ \ \textcolor{comment}{//\ after\ outputting.}}
\DoxyCodeLine{01787\ \ \ \ \ \ \ const\ ::std::streamsize\ old\_precision\ =}
\DoxyCodeLine{01788\ \ \ \ \ \ \ \ \ \ \ os-\/>precision(::std::numeric\_limits<FloatType>::digits10\ +\ 2);}
\DoxyCodeLine{01789\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (FloatingPoint<FloatType>(expected\_).is\_nan())\ \{}
\DoxyCodeLine{01790\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (nan\_eq\_nan\_)\ \{}
\DoxyCodeLine{01791\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ NaN"{}};}
\DoxyCodeLine{01792\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01793\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}never\ matches"{}};}
\DoxyCodeLine{01794\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01795\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01796\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ approximately\ "{}}\ <<\ expected\_;}
\DoxyCodeLine{01797\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (HasMaxAbsError())\ \{}
\DoxyCodeLine{01798\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ (absolute\ error\ <=\ "{}}\ <<\ max\_abs\_error\_\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01799\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01800\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01801\ \ \ \ \ \ \ os-\/>precision(old\_precision);}
\DoxyCodeLine{01802\ \ \ \ \ \}}
\DoxyCodeLine{01803\ }
\DoxyCodeLine{01804\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01805\ \ \ \ \ \ \ \textcolor{comment}{//\ As\ before,\ get\ original\ precision.}}
\DoxyCodeLine{01806\ \ \ \ \ \ \ const\ ::std::streamsize\ old\_precision\ =}
\DoxyCodeLine{01807\ \ \ \ \ \ \ \ \ \ \ os-\/>precision(::std::numeric\_limits<FloatType>::digits10\ +\ 2);}
\DoxyCodeLine{01808\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (FloatingPoint<FloatType>(expected\_).is\_nan())\ \{}
\DoxyCodeLine{01809\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (nan\_eq\_nan\_)\ \{}
\DoxyCodeLine{01810\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NaN"{}};}
\DoxyCodeLine{01811\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01812\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ anything"{}};}
\DoxyCodeLine{01813\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01814\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01815\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ approximately\ "{}}\ <<\ expected\_;}
\DoxyCodeLine{01816\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (HasMaxAbsError())\ \{}
\DoxyCodeLine{01817\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ (absolute\ error\ >\ "{}}\ <<\ max\_abs\_error\_\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01818\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01819\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01820\ \ \ \ \ \ \ \textcolor{comment}{//\ Restore\ original\ precision.}}
\DoxyCodeLine{01821\ \ \ \ \ \ \ os-\/>precision(old\_precision);}
\DoxyCodeLine{01822\ \ \ \ \ \}}
\DoxyCodeLine{01823\ }
\DoxyCodeLine{01824\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01825\ \ \ \ \ \textcolor{keywordtype}{bool}\ HasMaxAbsError()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ max\_abs\_error\_\ >=\ 0;\ \}}
\DoxyCodeLine{01826\ }
\DoxyCodeLine{01827\ \ \ \ \ \textcolor{keyword}{const}\ FloatType\ expected\_;}
\DoxyCodeLine{01828\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01829\ \ \ \ \ \textcolor{comment}{//\ max\_abs\_error\ will\ be\ used\ for\ value\ comparison\ when\ >=\ 0.}}
\DoxyCodeLine{01830\ \ \ \ \ \textcolor{keyword}{const}\ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01831\ \ \ \};}
\DoxyCodeLine{01832\ }
\DoxyCodeLine{01833\ \ \ \textcolor{comment}{//\ The\ following\ 3\ type\ conversion\ operators\ allow\ FloatEq(expected)\ and}}
\DoxyCodeLine{01834\ \ \ \textcolor{comment}{//\ NanSensitiveFloatEq(expected)\ to\ be\ used\ as\ a\ Matcher<float>,\ a}}
\DoxyCodeLine{01835\ \ \ \textcolor{comment}{//\ Matcher<const\ float\&>,\ or\ a\ Matcher<float\&>,\ but\ nothing\ else.}}
\DoxyCodeLine{01836\ \ \ \textcolor{keyword}{operator}\ Matcher<FloatType>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01837\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01838\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<FloatType>(expected\_,\ nan\_eq\_nan\_,\ max\_abs\_error\_));}
\DoxyCodeLine{01839\ \ \ \}}
\DoxyCodeLine{01840\ }
\DoxyCodeLine{01841\ \ \ \textcolor{keyword}{operator}\ Matcher<const\ FloatType\&>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01842\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01843\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ FloatType\&>(expected\_,\ nan\_eq\_nan\_,\ max\_abs\_error\_));}
\DoxyCodeLine{01844\ \ \ \}}
\DoxyCodeLine{01845\ }
\DoxyCodeLine{01846\ \ \ \textcolor{keyword}{operator}\ Matcher<FloatType\&>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01847\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01848\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<FloatType\&>(expected\_,\ nan\_eq\_nan\_,\ max\_abs\_error\_));}
\DoxyCodeLine{01849\ \ \ \}}
\DoxyCodeLine{01850\ }
\DoxyCodeLine{01851\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01852\ \ \ \textcolor{keyword}{const}\ FloatType\ expected\_;}
\DoxyCodeLine{01853\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01854\ \ \ \textcolor{comment}{//\ max\_abs\_error\ will\ be\ used\ for\ value\ comparison\ when\ >=\ 0.}}
\DoxyCodeLine{01855\ \ \ \textcolor{keyword}{const}\ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01856\ \};}
\DoxyCodeLine{01857\ }
\DoxyCodeLine{01858\ \textcolor{comment}{//\ A\ 2-\/tuple\ ("{}binary"{})\ wrapper\ around\ FloatingEqMatcher:}}
\DoxyCodeLine{01859\ \textcolor{comment}{//\ FloatingEq2Matcher()\ matches\ (x,\ y)\ by\ matching\ FloatingEqMatcher(x,\ false)}}
\DoxyCodeLine{01860\ \textcolor{comment}{//\ against\ y,\ and\ FloatingEq2Matcher(e)\ matches\ FloatingEqMatcher(x,\ false,\ e)}}
\DoxyCodeLine{01861\ \textcolor{comment}{//\ against\ y.\ The\ former\ implements\ "{}Eq"{},\ the\ latter\ "{}Near"{}.\ At\ present,\ there}}
\DoxyCodeLine{01862\ \textcolor{comment}{//\ is\ no\ version\ that\ compares\ NaNs\ as\ equal.}}
\DoxyCodeLine{01863\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>}
\DoxyCodeLine{01864\ \textcolor{keyword}{class\ }FloatingEq2Matcher\ \{}
\DoxyCodeLine{01865\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01866\ \ \ FloatingEq2Matcher()\ \{\ Init(-\/1,\ \textcolor{keyword}{false});\ \}}
\DoxyCodeLine{01867\ }
\DoxyCodeLine{01868\ \ \ \textcolor{keyword}{explicit}\ FloatingEq2Matcher(\textcolor{keywordtype}{bool}\ nan\_eq\_nan)\ \{\ Init(-\/1,\ nan\_eq\_nan);\ \}}
\DoxyCodeLine{01869\ }
\DoxyCodeLine{01870\ \ \ \textcolor{keyword}{explicit}\ FloatingEq2Matcher(FloatType\ max\_abs\_error)\ \{}
\DoxyCodeLine{01871\ \ \ \ \ Init(max\_abs\_error,\ \textcolor{keyword}{false});}
\DoxyCodeLine{01872\ \ \ \}}
\DoxyCodeLine{01873\ }
\DoxyCodeLine{01874\ \ \ FloatingEq2Matcher(FloatType\ max\_abs\_error,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan)\ \{}
\DoxyCodeLine{01875\ \ \ \ \ Init(max\_abs\_error,\ nan\_eq\_nan);}
\DoxyCodeLine{01876\ \ \ \}}
\DoxyCodeLine{01877\ }
\DoxyCodeLine{01878\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01879\ \ \ \textcolor{keyword}{operator}\ Matcher<::std::tuple<T1,\ T2>>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01880\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01881\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<::std::tuple<T1,\ T2>>(max\_abs\_error\_,\ nan\_eq\_nan\_));}
\DoxyCodeLine{01882\ \ \ \}}
\DoxyCodeLine{01883\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01884\ \ \ \textcolor{keyword}{operator}\ Matcher<const\ ::std::tuple<T1,\ T2>\&>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01885\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01886\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ ::std::tuple<T1,\ T2>\&>(max\_abs\_error\_,\ nan\_eq\_nan\_));}
\DoxyCodeLine{01887\ \ \ \}}
\DoxyCodeLine{01888\ }
\DoxyCodeLine{01889\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01890\ \ \ static\ ::std::ostream\&\ GetDesc(::std::ostream\&\ os)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01891\ \ \ \ \ \textcolor{keywordflow}{return}\ os\ <<\ \textcolor{stringliteral}{"{}an\ almost-\/equal\ pair"{}};}
\DoxyCodeLine{01892\ \ \ \}}
\DoxyCodeLine{01893\ }
\DoxyCodeLine{01894\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple>}
\DoxyCodeLine{01895\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Tuple>\ \{}
\DoxyCodeLine{01896\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01897\ \ \ \ \ Impl(FloatType\ max\_abs\_error,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan)}
\DoxyCodeLine{01898\ \ \ \ \ \ \ \ \ :\ max\_abs\_error\_(max\_abs\_error),\ nan\_eq\_nan\_(nan\_eq\_nan)\ \{\}}
\DoxyCodeLine{01899\ }
\DoxyCodeLine{01900\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Tuple\ args,}
\DoxyCodeLine{01901\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01902\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (max\_abs\_error\_\ ==\ -\/1)\ \{}
\DoxyCodeLine{01903\ \ \ \ \ \ \ \ \ FloatingEqMatcher<FloatType>\ fm(::std::get<0>(args),\ nan\_eq\_nan\_);}
\DoxyCodeLine{01904\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}Matcher<FloatType>\textcolor{keyword}{>}(fm).MatchAndExplain(}
\DoxyCodeLine{01905\ \ \ \ \ \ \ \ \ \ \ \ \ ::std::get<1>(args),\ listener);}
\DoxyCodeLine{01906\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01907\ \ \ \ \ \ \ \ \ FloatingEqMatcher<FloatType>\ fm(::std::get<0>(args),\ nan\_eq\_nan\_,}
\DoxyCodeLine{01908\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ max\_abs\_error\_);}
\DoxyCodeLine{01909\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}Matcher<FloatType>\textcolor{keyword}{>}(fm).MatchAndExplain(}
\DoxyCodeLine{01910\ \ \ \ \ \ \ \ \ \ \ \ \ ::std::get<1>(args),\ listener);}
\DoxyCodeLine{01911\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01912\ \ \ \ \ \}}
\DoxyCodeLine{01913\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01914\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01915\ \ \ \ \ \}}
\DoxyCodeLine{01916\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01917\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}aren't\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01918\ \ \ \ \ \}}
\DoxyCodeLine{01919\ }
\DoxyCodeLine{01920\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01921\ \ \ \ \ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01922\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01923\ \ \ \};}
\DoxyCodeLine{01924\ }
\DoxyCodeLine{01925\ \ \ \textcolor{keywordtype}{void}\ Init(FloatType\ max\_abs\_error\_val,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_val)\ \{}
\DoxyCodeLine{01926\ \ \ \ \ max\_abs\_error\_\ =\ max\_abs\_error\_val;}
\DoxyCodeLine{01927\ \ \ \ \ nan\_eq\_nan\_\ =\ nan\_eq\_nan\_val;}
\DoxyCodeLine{01928\ \ \ \}}
\DoxyCodeLine{01929\ \ \ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01930\ \ \ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01931\ \};}
\DoxyCodeLine{01932\ }
\DoxyCodeLine{01933\ \textcolor{comment}{//\ Implements\ the\ Pointee(m)\ matcher\ for\ matching\ a\ pointer\ whose}}
\DoxyCodeLine{01934\ \textcolor{comment}{//\ pointee\ matches\ matcher\ m.\ \ The\ pointer\ can\ be\ either\ raw\ or\ smart.}}
\DoxyCodeLine{01935\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{01936\ \textcolor{keyword}{class\ }PointeeMatcher\ \{}
\DoxyCodeLine{01937\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01938\ \ \ \textcolor{keyword}{explicit}\ PointeeMatcher(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01939\ }
\DoxyCodeLine{01940\ \ \ \textcolor{comment}{//\ This\ type\ conversion\ operator\ template\ allows\ Pointee(m)\ to\ be}}
\DoxyCodeLine{01941\ \ \ \textcolor{comment}{//\ used\ as\ a\ matcher\ for\ any\ pointer\ type\ whose\ pointee\ type\ is}}
\DoxyCodeLine{01942\ \ \ \textcolor{comment}{//\ compatible\ with\ the\ inner\ matcher,\ where\ type\ Pointer\ can\ be}}
\DoxyCodeLine{01943\ \ \ \textcolor{comment}{//\ either\ a\ raw\ pointer\ or\ a\ smart\ pointer.}}
\DoxyCodeLine{01944\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01945\ \ \ \textcolor{comment}{//\ The\ reason\ we\ do\ this\ instead\ of\ relying\ on}}
\DoxyCodeLine{01946\ \ \ \textcolor{comment}{//\ MakePolymorphicMatcher()\ is\ that\ the\ latter\ is\ not\ flexible}}
\DoxyCodeLine{01947\ \ \ \textcolor{comment}{//\ enough\ for\ implementing\ the\ DescribeTo()\ method\ of\ Pointee().}}
\DoxyCodeLine{01948\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{01949\ \ \ \textcolor{keyword}{operator}\ Matcher<Pointer>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01950\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Pointer>(\textcolor{keyword}{new}\ Impl<const\ Pointer\&>(matcher\_));}
\DoxyCodeLine{01951\ \ \ \}}
\DoxyCodeLine{01952\ }
\DoxyCodeLine{01953\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01954\ \ \ \textcolor{comment}{//\ The\ monomorphic\ implementation\ that\ works\ for\ a\ particular\ pointer\ type.}}
\DoxyCodeLine{01955\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{01956\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Pointer>\ \{}
\DoxyCodeLine{01957\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01958\ \ \ \ \ \textcolor{keyword}{using\ }Pointee\ =}
\DoxyCodeLine{01959\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::pointer\_traits<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{01960\ \ \ \ \ \ \ \ \ \ \ \ \ Pointer)>::element\_type;}
\DoxyCodeLine{01961\ }
\DoxyCodeLine{01962\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)}
\DoxyCodeLine{01963\ \ \ \ \ \ \ \ \ :\ matcher\_(MatcherCast<const\ Pointee\&>(matcher))\ \{\}}
\DoxyCodeLine{01964\ }
\DoxyCodeLine{01965\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01966\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}points\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{01967\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01968\ \ \ \ \ \}}
\DoxyCodeLine{01969\ }
\DoxyCodeLine{01970\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01971\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ point\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{01972\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01973\ \ \ \ \ \}}
\DoxyCodeLine{01974\ }
\DoxyCodeLine{01975\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Pointer\ pointer,}
\DoxyCodeLine{01976\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01977\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (GetRawPointer(pointer)\ ==\ \textcolor{keyword}{nullptr})\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01978\ }
\DoxyCodeLine{01979\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ points\ to\ "{}};}
\DoxyCodeLine{01980\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(*pointer,\ matcher\_,\ listener);}
\DoxyCodeLine{01981\ \ \ \ \ \}}
\DoxyCodeLine{01982\ }
\DoxyCodeLine{01983\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01984\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ Pointee\&>\ matcher\_;}
\DoxyCodeLine{01985\ \ \ \};}
\DoxyCodeLine{01986\ }
\DoxyCodeLine{01987\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{01988\ \};}
\DoxyCodeLine{01989\ }
\DoxyCodeLine{01990\ \textcolor{comment}{//\ Implements\ the\ Pointer(m)\ matcher}}
\DoxyCodeLine{01991\ \textcolor{comment}{//\ Implements\ the\ Pointer(m)\ matcher\ for\ matching\ a\ pointer\ that\ matches\ matcher}}
\DoxyCodeLine{01992\ \textcolor{comment}{//\ m.\ \ The\ pointer\ can\ be\ either\ raw\ or\ smart,\ and\ will\ match\ \`{}m`\ against\ the}}
\DoxyCodeLine{01993\ \textcolor{comment}{//\ raw\ pointer.}}
\DoxyCodeLine{01994\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{01995\ \textcolor{keyword}{class\ }PointerMatcher\ \{}
\DoxyCodeLine{01996\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01997\ \ \ \textcolor{keyword}{explicit}\ PointerMatcher(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01998\ }
\DoxyCodeLine{01999\ \ \ \textcolor{comment}{//\ This\ type\ conversion\ operator\ template\ allows\ Pointer(m)\ to\ be}}
\DoxyCodeLine{02000\ \ \ \textcolor{comment}{//\ used\ as\ a\ matcher\ for\ any\ pointer\ type\ whose\ pointer\ type\ is}}
\DoxyCodeLine{02001\ \ \ \textcolor{comment}{//\ compatible\ with\ the\ inner\ matcher,\ where\ type\ PointerType\ can\ be}}
\DoxyCodeLine{02002\ \ \ \textcolor{comment}{//\ either\ a\ raw\ pointer\ or\ a\ smart\ pointer.}}
\DoxyCodeLine{02003\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{02004\ \ \ \textcolor{comment}{//\ The\ reason\ we\ do\ this\ instead\ of\ relying\ on}}
\DoxyCodeLine{02005\ \ \ \textcolor{comment}{//\ MakePolymorphicMatcher()\ is\ that\ the\ latter\ is\ not\ flexible}}
\DoxyCodeLine{02006\ \ \ \textcolor{comment}{//\ enough\ for\ implementing\ the\ DescribeTo()\ method\ of\ Pointer().}}
\DoxyCodeLine{02007\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}erType>}
\DoxyCodeLine{02008\ \ \ \textcolor{keyword}{operator}\ Matcher<PointerType>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02009\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<PointerType>(\textcolor{keyword}{new}\ Impl<const\ PointerType\&>(matcher\_));}
\DoxyCodeLine{02010\ \ \ \}}
\DoxyCodeLine{02011\ }
\DoxyCodeLine{02012\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02013\ \ \ \textcolor{comment}{//\ The\ monomorphic\ implementation\ that\ works\ for\ a\ particular\ pointer\ type.}}
\DoxyCodeLine{02014\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}erType>}
\DoxyCodeLine{02015\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<PointerType>\ \{}
\DoxyCodeLine{02016\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02017\ \ \ \ \ \textcolor{keyword}{using\ }Pointer\ =}
\DoxyCodeLine{02018\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{typename}\ std::pointer\_traits<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{02019\ \ \ \ \ \ \ \ \ \ \ \ \ PointerType)>::element\_type*;}
\DoxyCodeLine{02020\ }
\DoxyCodeLine{02021\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)}
\DoxyCodeLine{02022\ \ \ \ \ \ \ \ \ :\ matcher\_(MatcherCast<Pointer>(matcher))\ \{\}}
\DoxyCodeLine{02023\ }
\DoxyCodeLine{02024\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02025\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ a\ pointer\ that\ "{}};}
\DoxyCodeLine{02026\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02027\ \ \ \ \ \}}
\DoxyCodeLine{02028\ }
\DoxyCodeLine{02029\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02030\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ not\ a\ pointer\ that\ "{}};}
\DoxyCodeLine{02031\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02032\ \ \ \ \ \}}
\DoxyCodeLine{02033\ }
\DoxyCodeLine{02034\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(PointerType\ pointer,}
\DoxyCodeLine{02035\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02036\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ a\ pointer\ that\ "{}};}
\DoxyCodeLine{02037\ \ \ \ \ \ \ Pointer\ p\ =\ GetRawPointer(pointer);}
\DoxyCodeLine{02038\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(p,\ matcher\_,\ listener);}
\DoxyCodeLine{02039\ \ \ \ \ \}}
\DoxyCodeLine{02040\ }
\DoxyCodeLine{02041\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02042\ \ \ \ \ Matcher<Pointer>\ matcher\_;}
\DoxyCodeLine{02043\ \ \ \};}
\DoxyCodeLine{02044\ }
\DoxyCodeLine{02045\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{02046\ \};}
\DoxyCodeLine{02047\ }
\DoxyCodeLine{02048\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{02049\ \textcolor{comment}{//\ Implements\ the\ WhenDynamicCastTo<T>(m)\ matcher\ that\ matches\ a\ pointer\ or}}
\DoxyCodeLine{02050\ \textcolor{comment}{//\ reference\ that\ matches\ inner\_matcher\ when\ dynamic\_cast<T>\ is\ applied.}}
\DoxyCodeLine{02051\ \textcolor{comment}{//\ The\ result\ of\ dynamic\_cast<To>\ is\ forwarded\ to\ the\ inner\ matcher.}}
\DoxyCodeLine{02052\ \textcolor{comment}{//\ If\ To\ is\ a\ pointer\ and\ the\ cast\ fails,\ the\ inner\ matcher\ will\ receive\ NULL.}}
\DoxyCodeLine{02053\ \textcolor{comment}{//\ If\ To\ is\ a\ reference\ and\ the\ cast\ fails,\ this\ matcher\ returns\ false}}
\DoxyCodeLine{02054\ \textcolor{comment}{//\ immediately.}}
\DoxyCodeLine{02055\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{02056\ \textcolor{keyword}{class\ }WhenDynamicCastToMatcherBase\ \{}
\DoxyCodeLine{02057\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02058\ \ \ \textcolor{keyword}{explicit}\ WhenDynamicCastToMatcherBase(\textcolor{keyword}{const}\ Matcher<To>\&\ matcher)}
\DoxyCodeLine{02059\ \ \ \ \ \ \ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{02060\ }
\DoxyCodeLine{02061\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02062\ \ \ \ \ GetCastTypeDescription(os);}
\DoxyCodeLine{02063\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02064\ \ \ \}}
\DoxyCodeLine{02065\ }
\DoxyCodeLine{02066\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02067\ \ \ \ \ GetCastTypeDescription(os);}
\DoxyCodeLine{02068\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02069\ \ \ \}}
\DoxyCodeLine{02070\ }
\DoxyCodeLine{02071\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{02072\ \ \ \textcolor{keyword}{const}\ Matcher<To>\ matcher\_;}
\DoxyCodeLine{02073\ }
\DoxyCodeLine{02074\ \ \ \textcolor{keyword}{static}\ std::string\ GetToName()\ \{\ \textcolor{keywordflow}{return}\ GetTypeName<To>();\ \}}
\DoxyCodeLine{02075\ }
\DoxyCodeLine{02076\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02077\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ GetCastTypeDescription(::std::ostream*\ os)\ \{}
\DoxyCodeLine{02078\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}when\ dynamic\_cast\ to\ "{}}\ <<\ GetToName()\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02079\ \ \ \}}
\DoxyCodeLine{02080\ \};}
\DoxyCodeLine{02081\ }
\DoxyCodeLine{02082\ \textcolor{comment}{//\ Primary\ template.}}
\DoxyCodeLine{02083\ \textcolor{comment}{//\ To\ is\ a\ pointer.\ Cast\ and\ forward\ the\ result.}}
\DoxyCodeLine{02084\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{02085\ \textcolor{keyword}{class\ }WhenDynamicCastToMatcher\ :\ \textcolor{keyword}{public}\ WhenDynamicCastToMatcherBase<To>\ \{}
\DoxyCodeLine{02086\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02087\ \ \ \textcolor{keyword}{explicit}\ WhenDynamicCastToMatcher(\textcolor{keyword}{const}\ Matcher<To>\&\ matcher)}
\DoxyCodeLine{02088\ \ \ \ \ \ \ :\ WhenDynamicCastToMatcherBase<To>(matcher)\ \{\}}
\DoxyCodeLine{02089\ }
\DoxyCodeLine{02090\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ From>}
\DoxyCodeLine{02091\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(From\ from,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02092\ \ \ \ \ To\ to\ =\ \textcolor{keyword}{dynamic\_cast<}To\textcolor{keyword}{>}(from);}
\DoxyCodeLine{02093\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(to,\ this-\/>matcher\_,\ listener);}
\DoxyCodeLine{02094\ \ \ \}}
\DoxyCodeLine{02095\ \};}
\DoxyCodeLine{02096\ }
\DoxyCodeLine{02097\ \textcolor{comment}{//\ Specialize\ for\ references.}}
\DoxyCodeLine{02098\ \textcolor{comment}{//\ In\ this\ case\ we\ return\ false\ if\ the\ dynamic\_cast\ fails.}}
\DoxyCodeLine{02099\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{02100\ \textcolor{keyword}{class\ }WhenDynamicCastToMatcher<To\&>\ :\ \textcolor{keyword}{public}\ WhenDynamicCastToMatcherBase<To\&>\ \{}
\DoxyCodeLine{02101\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02102\ \ \ \textcolor{keyword}{explicit}\ WhenDynamicCastToMatcher(\textcolor{keyword}{const}\ Matcher<To\&>\&\ matcher)}
\DoxyCodeLine{02103\ \ \ \ \ \ \ :\ WhenDynamicCastToMatcherBase<To\&>(matcher)\ \{\}}
\DoxyCodeLine{02104\ }
\DoxyCodeLine{02105\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ From>}
\DoxyCodeLine{02106\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(From\&\ from,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02107\ \ \ \ \ \textcolor{comment}{//\ We\ don't\ want\ an\ std::bad\_cast\ here,\ so\ do\ the\ cast\ with\ pointers.}}
\DoxyCodeLine{02108\ \ \ \ \ To*\ to\ =\ \textcolor{keyword}{dynamic\_cast<}To*\textcolor{keyword}{>}(\&from);}
\DoxyCodeLine{02109\ \ \ \ \ \textcolor{keywordflow}{if}\ (to\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02110\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ cannot\ be\ dynamic\_cast\ to\ "{}}\ <<\ this-\/>GetToName();}
\DoxyCodeLine{02111\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02112\ \ \ \ \ \}}
\DoxyCodeLine{02113\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(*to,\ this-\/>matcher\_,\ listener);}
\DoxyCodeLine{02114\ \ \ \}}
\DoxyCodeLine{02115\ \};}
\DoxyCodeLine{02116\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{02117\ }
\DoxyCodeLine{02118\ \textcolor{comment}{//\ Implements\ the\ Field()\ matcher\ for\ matching\ a\ field\ (i.e.\ member}}
\DoxyCodeLine{02119\ \textcolor{comment}{//\ variable)\ of\ an\ object.}}
\DoxyCodeLine{02120\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ FieldType>}
\DoxyCodeLine{02121\ \textcolor{keyword}{class\ }FieldMatcher\ \{}
\DoxyCodeLine{02122\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02123\ \ \ FieldMatcher(FieldType\ Class::*\ field,}
\DoxyCodeLine{02124\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Matcher<const\ FieldType\&>\&\ matcher)}
\DoxyCodeLine{02125\ \ \ \ \ \ \ :\ field\_(field),\ matcher\_(matcher),\ whose\_field\_(\textcolor{stringliteral}{"{}whose\ given\ field\ "{}})\ \{\}}
\DoxyCodeLine{02126\ }
\DoxyCodeLine{02127\ \ \ FieldMatcher(\textcolor{keyword}{const}\ std::string\&\ field\_name,\ FieldType\ Class::*\ field,}
\DoxyCodeLine{02128\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Matcher<const\ FieldType\&>\&\ matcher)}
\DoxyCodeLine{02129\ \ \ \ \ \ \ :\ field\_(field),}
\DoxyCodeLine{02130\ \ \ \ \ \ \ \ \ matcher\_(matcher),}
\DoxyCodeLine{02131\ \ \ \ \ \ \ \ \ whose\_field\_(\textcolor{stringliteral}{"{}whose\ field\ \`{}"{}}\ +\ field\_name\ +\ \textcolor{stringliteral}{"{}\`{}\ "{}})\ \{\}}
\DoxyCodeLine{02132\ }
\DoxyCodeLine{02133\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02134\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_field\_;}
\DoxyCodeLine{02135\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02136\ \ \ \}}
\DoxyCodeLine{02137\ }
\DoxyCodeLine{02138\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02139\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_field\_;}
\DoxyCodeLine{02140\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02141\ \ \ \}}
\DoxyCodeLine{02142\ }
\DoxyCodeLine{02143\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02144\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ value,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02145\ \ \ \ \ \textcolor{comment}{//\ FIXME:\ The\ dispatch\ on\ std::is\_pointer\ was\ introduced\ as\ a\ workaround\ for}}
\DoxyCodeLine{02146\ \ \ \ \ \textcolor{comment}{//\ a\ compiler\ bug,\ and\ can\ now\ be\ removed.}}
\DoxyCodeLine{02147\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(}
\DoxyCodeLine{02148\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::is\_pointer<\textcolor{keyword}{typename}\ std::remove\_const<T>::type>::type(),}
\DoxyCodeLine{02149\ \ \ \ \ \ \ \ \ value,\ listener);}
\DoxyCodeLine{02150\ \ \ \}}
\DoxyCodeLine{02151\ }
\DoxyCodeLine{02152\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02153\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::false\_type\ \textcolor{comment}{/*\ is\_not\_pointer\ */},}
\DoxyCodeLine{02154\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Class\&\ obj,}
\DoxyCodeLine{02155\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02156\ \ \ \ \ *listener\ <<\ whose\_field\_\ <<\ \textcolor{stringliteral}{"{}is\ "{}};}
\DoxyCodeLine{02157\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(obj.*field\_,\ matcher\_,\ listener);}
\DoxyCodeLine{02158\ \ \ \}}
\DoxyCodeLine{02159\ }
\DoxyCodeLine{02160\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::true\_type\ \textcolor{comment}{/*\ is\_pointer\ */},\ \textcolor{keyword}{const}\ Class*\ p,}
\DoxyCodeLine{02161\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02162\ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ ==\ \textcolor{keyword}{nullptr})\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02163\ }
\DoxyCodeLine{02164\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ "{}};}
\DoxyCodeLine{02165\ \ \ \ \ \textcolor{comment}{//\ Since\ *p\ has\ a\ field,\ it\ must\ be\ a\ class/struct/union\ type\ and}}
\DoxyCodeLine{02166\ \ \ \ \ \textcolor{comment}{//\ thus\ cannot\ be\ a\ pointer.\ \ Therefore\ we\ pass\ false\_type()\ as}}
\DoxyCodeLine{02167\ \ \ \ \ \textcolor{comment}{//\ the\ first\ argument.}}
\DoxyCodeLine{02168\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(std::false\_type(),\ *p,\ listener);}
\DoxyCodeLine{02169\ \ \ \}}
\DoxyCodeLine{02170\ }
\DoxyCodeLine{02171\ \ \ \textcolor{keyword}{const}\ FieldType\ Class::*\ field\_;}
\DoxyCodeLine{02172\ \ \ \textcolor{keyword}{const}\ Matcher<const\ FieldType\&>\ matcher\_;}
\DoxyCodeLine{02173\ }
\DoxyCodeLine{02174\ \ \ \textcolor{comment}{//\ Contains\ either\ "{}whose\ given\ field\ "{}\ if\ the\ name\ of\ the\ field\ is\ unknown}}
\DoxyCodeLine{02175\ \ \ \textcolor{comment}{//\ or\ "{}whose\ field\ \`{}name\_of\_field`\ "{}\ if\ the\ name\ is\ known.}}
\DoxyCodeLine{02176\ \ \ \textcolor{keyword}{const}\ std::string\ whose\_field\_;}
\DoxyCodeLine{02177\ \};}
\DoxyCodeLine{02178\ }
\DoxyCodeLine{02179\ \textcolor{comment}{//\ Implements\ the\ Property()\ matcher\ for\ matching\ a\ property}}
\DoxyCodeLine{02180\ \textcolor{comment}{//\ (i.e.\ return\ value\ of\ a\ getter\ method)\ of\ an\ object.}}
\DoxyCodeLine{02181\ \textcolor{comment}{//}}
\DoxyCodeLine{02182\ \textcolor{comment}{//\ Property\ is\ a\ const-\/qualified\ member\ function\ of\ Class\ returning}}
\DoxyCodeLine{02183\ \textcolor{comment}{//\ PropertyType.}}
\DoxyCodeLine{02184\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ Property>}
\DoxyCodeLine{02185\ \textcolor{keyword}{class\ }PropertyMatcher\ \{}
\DoxyCodeLine{02186\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02187\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{const}\ PropertyType\&\ RefToConstProperty;}
\DoxyCodeLine{02188\ }
\DoxyCodeLine{02189\ \ \ PropertyMatcher(Property\ property,\ \textcolor{keyword}{const}\ Matcher<RefToConstProperty>\&\ matcher)}
\DoxyCodeLine{02190\ \ \ \ \ \ \ :\ property\_(property),}
\DoxyCodeLine{02191\ \ \ \ \ \ \ \ \ matcher\_(matcher),}
\DoxyCodeLine{02192\ \ \ \ \ \ \ \ \ whose\_property\_(\textcolor{stringliteral}{"{}whose\ given\ property\ "{}})\ \{\}}
\DoxyCodeLine{02193\ }
\DoxyCodeLine{02194\ \ \ PropertyMatcher(\textcolor{keyword}{const}\ std::string\&\ property\_name,\ Property\ property,}
\DoxyCodeLine{02195\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Matcher<RefToConstProperty>\&\ matcher)}
\DoxyCodeLine{02196\ \ \ \ \ \ \ :\ property\_(property),}
\DoxyCodeLine{02197\ \ \ \ \ \ \ \ \ matcher\_(matcher),}
\DoxyCodeLine{02198\ \ \ \ \ \ \ \ \ whose\_property\_(\textcolor{stringliteral}{"{}whose\ property\ \`{}"{}}\ +\ property\_name\ +\ \textcolor{stringliteral}{"{}\`{}\ "{}})\ \{\}}
\DoxyCodeLine{02199\ }
\DoxyCodeLine{02200\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02201\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_property\_;}
\DoxyCodeLine{02202\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02203\ \ \ \}}
\DoxyCodeLine{02204\ }
\DoxyCodeLine{02205\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02206\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_property\_;}
\DoxyCodeLine{02207\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02208\ \ \ \}}
\DoxyCodeLine{02209\ }
\DoxyCodeLine{02210\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02211\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ value,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02212\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(}
\DoxyCodeLine{02213\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::is\_pointer<\textcolor{keyword}{typename}\ std::remove\_const<T>::type>::type(),}
\DoxyCodeLine{02214\ \ \ \ \ \ \ \ \ value,\ listener);}
\DoxyCodeLine{02215\ \ \ \}}
\DoxyCodeLine{02216\ }
\DoxyCodeLine{02217\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02218\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::false\_type\ \textcolor{comment}{/*\ is\_not\_pointer\ */},}
\DoxyCodeLine{02219\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Class\&\ obj,}
\DoxyCodeLine{02220\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02221\ \ \ \ \ *listener\ <<\ whose\_property\_\ <<\ \textcolor{stringliteral}{"{}is\ "{}};}
\DoxyCodeLine{02222\ \ \ \ \ \textcolor{comment}{//\ Cannot\ pass\ the\ return\ value\ (for\ example,\ int)\ to\ MatchPrintAndExplain,}}
\DoxyCodeLine{02223\ \ \ \ \ \textcolor{comment}{//\ which\ takes\ a\ non-\/const\ reference\ as\ argument.}}
\DoxyCodeLine{02224\ \ \ \ \ RefToConstProperty\ result\ =\ (obj.*property\_)();}
\DoxyCodeLine{02225\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(result,\ matcher\_,\ listener);}
\DoxyCodeLine{02226\ \ \ \}}
\DoxyCodeLine{02227\ }
\DoxyCodeLine{02228\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::true\_type\ \textcolor{comment}{/*\ is\_pointer\ */},\ \textcolor{keyword}{const}\ Class*\ p,}
\DoxyCodeLine{02229\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02230\ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ ==\ \textcolor{keyword}{nullptr})\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02231\ }
\DoxyCodeLine{02232\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ "{}};}
\DoxyCodeLine{02233\ \ \ \ \ \textcolor{comment}{//\ Since\ *p\ has\ a\ property\ method,\ it\ must\ be\ a\ class/struct/union}}
\DoxyCodeLine{02234\ \ \ \ \ \textcolor{comment}{//\ type\ and\ thus\ cannot\ be\ a\ pointer.\ \ Therefore\ we\ pass}}
\DoxyCodeLine{02235\ \ \ \ \ \textcolor{comment}{//\ false\_type()\ as\ the\ first\ argument.}}
\DoxyCodeLine{02236\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(std::false\_type(),\ *p,\ listener);}
\DoxyCodeLine{02237\ \ \ \}}
\DoxyCodeLine{02238\ }
\DoxyCodeLine{02239\ \ \ Property\ property\_;}
\DoxyCodeLine{02240\ \ \ \textcolor{keyword}{const}\ Matcher<RefToConstProperty>\ matcher\_;}
\DoxyCodeLine{02241\ }
\DoxyCodeLine{02242\ \ \ \textcolor{comment}{//\ Contains\ either\ "{}whose\ given\ property\ "{}\ if\ the\ name\ of\ the\ property\ is}}
\DoxyCodeLine{02243\ \ \ \textcolor{comment}{//\ unknown\ or\ "{}whose\ property\ \`{}name\_of\_property`\ "{}\ if\ the\ name\ is\ known.}}
\DoxyCodeLine{02244\ \ \ \textcolor{keyword}{const}\ std::string\ whose\_property\_;}
\DoxyCodeLine{02245\ \};}
\DoxyCodeLine{02246\ }
\DoxyCodeLine{02247\ \textcolor{comment}{//\ Type\ traits\ specifying\ various\ features\ of\ different\ functors\ for\ ResultOf.}}
\DoxyCodeLine{02248\ \textcolor{comment}{//\ The\ default\ template\ specifies\ features\ for\ functor\ objects.}}
\DoxyCodeLine{02249\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Functor>}
\DoxyCodeLine{02250\ \textcolor{keyword}{struct\ }CallableTraits\ \{}
\DoxyCodeLine{02251\ \ \ \textcolor{keyword}{typedef}\ Functor\ StorageType;}
\DoxyCodeLine{02252\ }
\DoxyCodeLine{02253\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ CheckIsValid(Functor\ \textcolor{comment}{/*\ functor\ */})\ \{\}}
\DoxyCodeLine{02254\ }
\DoxyCodeLine{02255\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02256\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{auto}\ Invoke(Functor\ f,\ \textcolor{keyword}{const}\ T\&\ arg)\ -\/>\ \textcolor{keyword}{decltype}(f(arg))\ \{}
\DoxyCodeLine{02257\ \ \ \ \ \textcolor{keywordflow}{return}\ f(arg);}
\DoxyCodeLine{02258\ \ \ \}}
\DoxyCodeLine{02259\ \};}
\DoxyCodeLine{02260\ }
\DoxyCodeLine{02261\ \textcolor{comment}{//\ Specialization\ for\ function\ pointers.}}
\DoxyCodeLine{02262\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ArgType,\ \textcolor{keyword}{typename}\ ResType>}
\DoxyCodeLine{02263\ \textcolor{keyword}{struct\ }CallableTraits<ResType\ (*)(ArgType)>\ \{}
\DoxyCodeLine{02264\ \ \ \textcolor{keyword}{typedef}\ ResType\ ResultType;}
\DoxyCodeLine{02265\ \ \ \textcolor{keyword}{typedef}\ ResType\ (*StorageType)(ArgType);}
\DoxyCodeLine{02266\ }
\DoxyCodeLine{02267\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ CheckIsValid(ResType\ (*f)(ArgType))\ \{}
\DoxyCodeLine{02268\ \ \ \ \ GTEST\_CHECK\_(f\ !=\ \textcolor{keyword}{nullptr})}
\DoxyCodeLine{02269\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}NULL\ function\ pointer\ is\ passed\ into\ ResultOf()."{}};}
\DoxyCodeLine{02270\ \ \ \}}
\DoxyCodeLine{02271\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02272\ \ \ \textcolor{keyword}{static}\ ResType\ Invoke(ResType\ (*f)(ArgType),\ T\ arg)\ \{}
\DoxyCodeLine{02273\ \ \ \ \ \textcolor{keywordflow}{return}\ (*f)(arg);}
\DoxyCodeLine{02274\ \ \ \}}
\DoxyCodeLine{02275\ \};}
\DoxyCodeLine{02276\ }
\DoxyCodeLine{02277\ \textcolor{comment}{//\ Implements\ the\ ResultOf()\ matcher\ for\ matching\ a\ return\ value\ of\ a}}
\DoxyCodeLine{02278\ \textcolor{comment}{//\ unary\ function\ of\ an\ object.}}
\DoxyCodeLine{02279\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Callable,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02280\ \textcolor{keyword}{class\ }ResultOfMatcher\ \{}
\DoxyCodeLine{02281\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02282\ \ \ ResultOfMatcher(Callable\ callable,\ InnerMatcher\ matcher)}
\DoxyCodeLine{02283\ \ \ \ \ \ \ :\ ResultOfMatcher(\textcolor{comment}{/*result\_description=*/}\textcolor{stringliteral}{"{}"{}},\ std::move(callable),}
\DoxyCodeLine{02284\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(matcher))\ \{\}}
\DoxyCodeLine{02285\ }
\DoxyCodeLine{02286\ \ \ ResultOfMatcher(\textcolor{keyword}{const}\ std::string\&\ result\_description,\ Callable\ callable,}
\DoxyCodeLine{02287\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InnerMatcher\ matcher)}
\DoxyCodeLine{02288\ \ \ \ \ \ \ :\ result\_description\_(result\_description),}
\DoxyCodeLine{02289\ \ \ \ \ \ \ \ \ callable\_(std::move(callable)),}
\DoxyCodeLine{02290\ \ \ \ \ \ \ \ \ matcher\_(std::move(matcher))\ \{}
\DoxyCodeLine{02291\ \ \ \ \ CallableTraits<Callable>::CheckIsValid(callable\_);}
\DoxyCodeLine{02292\ \ \ \}}
\DoxyCodeLine{02293\ }
\DoxyCodeLine{02294\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02295\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02296\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(}
\DoxyCodeLine{02297\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ T\&>(result\_description\_,\ callable\_,\ matcher\_));}
\DoxyCodeLine{02298\ \ \ \}}
\DoxyCodeLine{02299\ }
\DoxyCodeLine{02300\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02301\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ CallableTraits<Callable>::StorageType\ CallableStorageType;}
\DoxyCodeLine{02302\ }
\DoxyCodeLine{02303\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02304\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{02305\ \ \ \ \ \textcolor{keyword}{using\ }ResultType\ =\ \textcolor{keyword}{decltype}(CallableTraits<Callable>::template\ Invoke<T>(}
\DoxyCodeLine{02306\ \ \ \ \ \ \ \ \ std::declval<CallableStorageType>(),\ std::declval<T>()));}
\DoxyCodeLine{02307\ \ \ \ \ \textcolor{keyword}{using\ }InnerType\ =\ std::conditional\_t<}
\DoxyCodeLine{02308\ \ \ \ \ \ \ \ \ std::is\_lvalue\_reference<ResultType>::value,}
\DoxyCodeLine{02309\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{typename}\ std::remove\_reference<ResultType>::type\&,\ ResultType>;}
\DoxyCodeLine{02310\ }
\DoxyCodeLine{02311\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02312\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02313\ \ \ \ \ Impl(\textcolor{keyword}{const}\ std::string\&\ result\_description,}
\DoxyCodeLine{02314\ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ CallableStorageType\&\ callable,\ \textcolor{keyword}{const}\ M\&\ matcher)}
\DoxyCodeLine{02315\ \ \ \ \ \ \ \ \ :\ result\_description\_(result\_description),}
\DoxyCodeLine{02316\ \ \ \ \ \ \ \ \ \ \ callable\_(callable),}
\DoxyCodeLine{02317\ \ \ \ \ \ \ \ \ \ \ matcher\_(MatcherCast<InnerType>(matcher))\ \{\}}
\DoxyCodeLine{02318\ }
\DoxyCodeLine{02319\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02320\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (result\_description\_.empty())\ \{}
\DoxyCodeLine{02321\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ mapped\ by\ the\ given\ callable\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{02322\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02323\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}whose\ "{}}\ <<\ result\_description\_\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02324\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02325\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02326\ \ \ \ \ \}}
\DoxyCodeLine{02327\ }
\DoxyCodeLine{02328\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02329\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (result\_description\_.empty())\ \{}
\DoxyCodeLine{02330\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ mapped\ by\ the\ given\ callable\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{02331\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02332\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}whose\ "{}}\ <<\ result\_description\_\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02333\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02334\ \ \ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02335\ \ \ \ \ \}}
\DoxyCodeLine{02336\ }
\DoxyCodeLine{02337\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ obj,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02338\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (result\_description\_.empty())\ \{}
\DoxyCodeLine{02339\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ mapped\ by\ the\ given\ callable\ to\ "{}};}
\DoxyCodeLine{02340\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02341\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ "{}}\ <<\ result\_description\_\ <<\ \textcolor{stringliteral}{"{}\ is\ "{}};}
\DoxyCodeLine{02342\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02343\ \ \ \ \ \ \ \textcolor{comment}{//\ Cannot\ pass\ the\ return\ value\ directly\ to\ MatchPrintAndExplain,\ which}}
\DoxyCodeLine{02344\ \ \ \ \ \ \ \textcolor{comment}{//\ takes\ a\ non-\/const\ reference\ as\ argument.}}
\DoxyCodeLine{02345\ \ \ \ \ \ \ \textcolor{comment}{//\ Also,\ specifying\ template\ argument\ explicitly\ is\ needed\ because\ T\ could}}
\DoxyCodeLine{02346\ \ \ \ \ \ \ \textcolor{comment}{//\ be\ a\ non-\/const\ reference\ (e.g.\ Matcher<Uncopyable\&>).}}
\DoxyCodeLine{02347\ \ \ \ \ \ \ InnerType\ result\ =}
\DoxyCodeLine{02348\ \ \ \ \ \ \ \ \ \ \ CallableTraits<Callable>::template\ Invoke<T>(callable\_,\ obj);}
\DoxyCodeLine{02349\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(result,\ matcher\_,\ listener);}
\DoxyCodeLine{02350\ \ \ \ \ \}}
\DoxyCodeLine{02351\ }
\DoxyCodeLine{02352\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02353\ \ \ \ \ \textcolor{keyword}{const}\ std::string\ result\_description\_;}
\DoxyCodeLine{02354\ \ \ \ \ \textcolor{comment}{//\ Functors\ often\ define\ operator()\ as\ non-\/const\ method\ even\ though}}
\DoxyCodeLine{02355\ \ \ \ \ \textcolor{comment}{//\ they\ are\ actually\ stateless.\ But\ we\ need\ to\ use\ them\ even\ when}}
\DoxyCodeLine{02356\ \ \ \ \ \textcolor{comment}{//\ 'this'\ is\ a\ const\ pointer.\ It's\ the\ user's\ responsibility\ not\ to}}
\DoxyCodeLine{02357\ \ \ \ \ \textcolor{comment}{//\ use\ stateful\ callables\ with\ ResultOf(),\ which\ doesn't\ guarantee}}
\DoxyCodeLine{02358\ \ \ \ \ \textcolor{comment}{//\ how\ many\ times\ the\ callable\ will\ be\ invoked.}}
\DoxyCodeLine{02359\ \ \ \ \ \textcolor{keyword}{mutable}\ CallableStorageType\ callable\_;}
\DoxyCodeLine{02360\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<InnerType>\ matcher\_;}
\DoxyCodeLine{02361\ \ \ \};\ \ \textcolor{comment}{//\ class\ Impl}}
\DoxyCodeLine{02362\ }
\DoxyCodeLine{02363\ \ \ \textcolor{keyword}{const}\ std::string\ result\_description\_;}
\DoxyCodeLine{02364\ \ \ \textcolor{keyword}{const}\ CallableStorageType\ callable\_;}
\DoxyCodeLine{02365\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{02366\ \};}
\DoxyCodeLine{02367\ }
\DoxyCodeLine{02368\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ size\ of\ an\ STL-\/style\ container.}}
\DoxyCodeLine{02369\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ SizeMatcher>}
\DoxyCodeLine{02370\ \textcolor{keyword}{class\ }SizeIsMatcher\ \{}
\DoxyCodeLine{02371\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02372\ \ \ \textcolor{keyword}{explicit}\ SizeIsMatcher(\textcolor{keyword}{const}\ SizeMatcher\&\ size\_matcher)}
\DoxyCodeLine{02373\ \ \ \ \ \ \ :\ size\_matcher\_(size\_matcher)\ \{\}}
\DoxyCodeLine{02374\ }
\DoxyCodeLine{02375\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02376\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02377\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ Impl<const\ Container\&>(size\_matcher\_));}
\DoxyCodeLine{02378\ \ \ \}}
\DoxyCodeLine{02379\ }
\DoxyCodeLine{02380\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02381\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{02382\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02383\ \ \ \ \ \textcolor{keyword}{using\ }SizeType\ =\ \textcolor{keyword}{decltype}(std::declval<Container>().size());}
\DoxyCodeLine{02384\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ SizeMatcher\&\ size\_matcher)}
\DoxyCodeLine{02385\ \ \ \ \ \ \ \ \ :\ size\_matcher\_(MatcherCast<SizeType>(size\_matcher))\ \{\}}
\DoxyCodeLine{02386\ }
\DoxyCodeLine{02387\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02388\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ size\ that\ "{}};}
\DoxyCodeLine{02389\ \ \ \ \ \ \ size\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02390\ \ \ \ \ \}}
\DoxyCodeLine{02391\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02392\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ size\ that\ "{}};}
\DoxyCodeLine{02393\ \ \ \ \ \ \ size\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02394\ \ \ \ \ \}}
\DoxyCodeLine{02395\ }
\DoxyCodeLine{02396\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02397\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02398\ \ \ \ \ \ \ SizeType\ size\ =\ container.size();}
\DoxyCodeLine{02399\ \ \ \ \ \ \ StringMatchResultListener\ size\_listener;}
\DoxyCodeLine{02400\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ result\ =\ size\_matcher\_.MatchAndExplain(size,\ \&size\_listener);}
\DoxyCodeLine{02401\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ size\ "{}}\ <<\ size}
\DoxyCodeLine{02402\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (result\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{02403\ \ \ \ \ \ \ PrintIfNotEmpty(size\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02404\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{02405\ \ \ \ \ \}}
\DoxyCodeLine{02406\ }
\DoxyCodeLine{02407\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02408\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<SizeType>\ size\_matcher\_;}
\DoxyCodeLine{02409\ \ \ \};}
\DoxyCodeLine{02410\ }
\DoxyCodeLine{02411\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02412\ \ \ \textcolor{keyword}{const}\ SizeMatcher\ size\_matcher\_;}
\DoxyCodeLine{02413\ \};}
\DoxyCodeLine{02414\ }
\DoxyCodeLine{02415\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ begin()..end()\ distance\ of\ an\ STL-\/style}}
\DoxyCodeLine{02416\ \textcolor{comment}{//\ container.}}
\DoxyCodeLine{02417\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{02418\ \textcolor{keyword}{class\ }BeginEndDistanceIsMatcher\ \{}
\DoxyCodeLine{02419\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02420\ \ \ \textcolor{keyword}{explicit}\ BeginEndDistanceIsMatcher(\textcolor{keyword}{const}\ DistanceMatcher\&\ distance\_matcher)}
\DoxyCodeLine{02421\ \ \ \ \ \ \ :\ distance\_matcher\_(distance\_matcher)\ \{\}}
\DoxyCodeLine{02422\ }
\DoxyCodeLine{02423\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02424\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02425\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ Impl<const\ Container\&>(distance\_matcher\_));}
\DoxyCodeLine{02426\ \ \ \}}
\DoxyCodeLine{02427\ }
\DoxyCodeLine{02428\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02429\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{02430\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02431\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{02432\ \ \ \ \ \ \ \ \ Container)>}
\DoxyCodeLine{02433\ \ \ \ \ \ \ \ \ ContainerView;}
\DoxyCodeLine{02434\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ std::iterator\_traits<}
\DoxyCodeLine{02435\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ ContainerView::type::const\_iterator>::difference\_type}
\DoxyCodeLine{02436\ \ \ \ \ \ \ \ \ DistanceType;}
\DoxyCodeLine{02437\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ DistanceMatcher\&\ distance\_matcher)}
\DoxyCodeLine{02438\ \ \ \ \ \ \ \ \ :\ distance\_matcher\_(MatcherCast<DistanceType>(distance\_matcher))\ \{\}}
\DoxyCodeLine{02439\ }
\DoxyCodeLine{02440\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02441\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}distance\ between\ begin()\ and\ end()\ "{}};}
\DoxyCodeLine{02442\ \ \ \ \ \ \ distance\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02443\ \ \ \ \ \}}
\DoxyCodeLine{02444\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02445\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}distance\ between\ begin()\ and\ end()\ "{}};}
\DoxyCodeLine{02446\ \ \ \ \ \ \ distance\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02447\ \ \ \ \ \}}
\DoxyCodeLine{02448\ }
\DoxyCodeLine{02449\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02450\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02451\ \ \ \ \ \ \ \textcolor{keyword}{using\ }std::begin;}
\DoxyCodeLine{02452\ \ \ \ \ \ \ \textcolor{keyword}{using\ }std::end;}
\DoxyCodeLine{02453\ \ \ \ \ \ \ DistanceType\ distance\ =\ std::distance(begin(container),\ end(container));}
\DoxyCodeLine{02454\ \ \ \ \ \ \ StringMatchResultListener\ distance\_listener;}
\DoxyCodeLine{02455\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ result\ =}
\DoxyCodeLine{02456\ \ \ \ \ \ \ \ \ \ \ distance\_matcher\_.MatchAndExplain(distance,\ \&distance\_listener);}
\DoxyCodeLine{02457\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ "{}}\ <<\ distance}
\DoxyCodeLine{02458\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (result\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{02459\ \ \ \ \ \ \ PrintIfNotEmpty(distance\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02460\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{02461\ \ \ \ \ \}}
\DoxyCodeLine{02462\ }
\DoxyCodeLine{02463\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02464\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<DistanceType>\ distance\_matcher\_;}
\DoxyCodeLine{02465\ \ \ \};}
\DoxyCodeLine{02466\ }
\DoxyCodeLine{02467\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02468\ \ \ \textcolor{keyword}{const}\ DistanceMatcher\ distance\_matcher\_;}
\DoxyCodeLine{02469\ \};}
\DoxyCodeLine{02470\ }
\DoxyCodeLine{02471\ \textcolor{comment}{//\ Implements\ an\ equality\ matcher\ for\ any\ STL-\/style\ container\ whose\ elements}}
\DoxyCodeLine{02472\ \textcolor{comment}{//\ support\ ==.\ This\ matcher\ is\ like\ Eq(),\ but\ its\ failure\ explanations\ provide}}
\DoxyCodeLine{02473\ \textcolor{comment}{//\ more\ detailed\ information\ that\ is\ useful\ when\ the\ container\ is\ used\ as\ a\ set.}}
\DoxyCodeLine{02474\ \textcolor{comment}{//\ The\ failure\ message\ reports\ elements\ that\ are\ in\ one\ of\ the\ operands\ but\ not}}
\DoxyCodeLine{02475\ \textcolor{comment}{//\ the\ other.\ The\ failure\ messages\ do\ not\ report\ duplicate\ or\ out-\/of-\/order}}
\DoxyCodeLine{02476\ \textcolor{comment}{//\ elements\ in\ the\ containers\ (which\ don't\ properly\ matter\ to\ sets,\ but\ can}}
\DoxyCodeLine{02477\ \textcolor{comment}{//\ occur\ if\ the\ containers\ are\ vectors\ or\ lists,\ for\ example).}}
\DoxyCodeLine{02478\ \textcolor{comment}{//}}
\DoxyCodeLine{02479\ \textcolor{comment}{//\ Uses\ the\ container's\ const\_iterator,\ value\_type,\ operator\ ==,}}
\DoxyCodeLine{02480\ \textcolor{comment}{//\ begin(),\ and\ end().}}
\DoxyCodeLine{02481\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02482\ \textcolor{keyword}{class\ }ContainerEqMatcher\ \{}
\DoxyCodeLine{02483\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02484\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<Container>\ View;}
\DoxyCodeLine{02485\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{02486\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{02487\ }
\DoxyCodeLine{02488\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_const<Container>::value,}
\DoxyCodeLine{02489\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Container\ type\ must\ not\ be\ const"{}});}
\DoxyCodeLine{02490\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_reference<Container>::value,}
\DoxyCodeLine{02491\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Container\ type\ must\ not\ be\ a\ reference"{}});}
\DoxyCodeLine{02492\ }
\DoxyCodeLine{02493\ \ \ \textcolor{comment}{//\ We\ make\ a\ copy\ of\ expected\ in\ case\ the\ elements\ in\ it\ are\ modified}}
\DoxyCodeLine{02494\ \ \ \textcolor{comment}{//\ after\ this\ matcher\ is\ created.}}
\DoxyCodeLine{02495\ \ \ \textcolor{keyword}{explicit}\ ContainerEqMatcher(\textcolor{keyword}{const}\ Container\&\ expected)}
\DoxyCodeLine{02496\ \ \ \ \ \ \ :\ expected\_(View::Copy(expected))\ \{\}}
\DoxyCodeLine{02497\ }
\DoxyCodeLine{02498\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02499\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}equals\ "{}};}
\DoxyCodeLine{02500\ \ \ \ \ UniversalPrint(expected\_,\ os);}
\DoxyCodeLine{02501\ \ \ \}}
\DoxyCodeLine{02502\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02503\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ equal\ "{}};}
\DoxyCodeLine{02504\ \ \ \ \ UniversalPrint(expected\_,\ os);}
\DoxyCodeLine{02505\ \ \ \}}
\DoxyCodeLine{02506\ }
\DoxyCodeLine{02507\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02508\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ LhsContainer\&\ lhs,}
\DoxyCodeLine{02509\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02510\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<}
\DoxyCodeLine{02511\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<LhsContainer>::type>}
\DoxyCodeLine{02512\ \ \ \ \ \ \ \ \ LhsView;}
\DoxyCodeLine{02513\ \ \ \ \ StlContainerReference\ lhs\_stl\_container\ =\ LhsView::ConstReference(lhs);}
\DoxyCodeLine{02514\ \ \ \ \ \textcolor{keywordflow}{if}\ (lhs\_stl\_container\ ==\ expected\_)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02515\ }
\DoxyCodeLine{02516\ \ \ \ \ ::std::ostream*\ \textcolor{keyword}{const}\ os\ =\ listener-\/>stream();}
\DoxyCodeLine{02517\ \ \ \ \ \textcolor{keywordflow}{if}\ (os\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02518\ \ \ \ \ \ \ \textcolor{comment}{//\ Something\ is\ different.\ Check\ for\ extra\ values\ first.}}
\DoxyCodeLine{02519\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ printed\_header\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{02520\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ lhs\_stl\_container.begin();\ it\ !=\ lhs\_stl\_container.end();}
\DoxyCodeLine{02521\ \ \ \ \ \ \ \ \ \ \ \ ++it)\ \{}
\DoxyCodeLine{02522\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (internal::ArrayAwareFind(expected\_.begin(),\ expected\_.end(),\ *it)\ ==}
\DoxyCodeLine{02523\ \ \ \ \ \ \ \ \ \ \ \ \ expected\_.end())\ \{}
\DoxyCodeLine{02524\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (printed\_header)\ \{}
\DoxyCodeLine{02525\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02526\ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02527\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ "{}};}
\DoxyCodeLine{02528\ \ \ \ \ \ \ \ \ \ \ \ \ printed\_header\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{02529\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02530\ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*it,\ os);}
\DoxyCodeLine{02531\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02532\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02533\ }
\DoxyCodeLine{02534\ \ \ \ \ \ \ \textcolor{comment}{//\ Now\ check\ for\ missing\ values.}}
\DoxyCodeLine{02535\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ printed\_header2\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{02536\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ expected\_.begin();\ it\ !=\ expected\_.end();\ ++it)\ \{}
\DoxyCodeLine{02537\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (internal::ArrayAwareFind(lhs\_stl\_container.begin(),}
\DoxyCodeLine{02538\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs\_stl\_container.end(),}
\DoxyCodeLine{02539\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *it)\ ==\ lhs\_stl\_container.end())\ \{}
\DoxyCodeLine{02540\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (printed\_header2)\ \{}
\DoxyCodeLine{02541\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02542\ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02543\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ (printed\_header\ ?\ \textcolor{stringliteral}{"{},\(\backslash\)nand"{}}\ :\ \textcolor{stringliteral}{"{}which"{}})}
\DoxyCodeLine{02544\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ doesn't\ have\ these\ expected\ elements:\ "{}};}
\DoxyCodeLine{02545\ \ \ \ \ \ \ \ \ \ \ \ \ printed\_header2\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{02546\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02547\ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*it,\ os);}
\DoxyCodeLine{02548\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02549\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02550\ \ \ \ \ \}}
\DoxyCodeLine{02551\ }
\DoxyCodeLine{02552\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02553\ \ \ \}}
\DoxyCodeLine{02554\ }
\DoxyCodeLine{02555\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02556\ \ \ \textcolor{keyword}{const}\ StlContainer\ expected\_;}
\DoxyCodeLine{02557\ \};}
\DoxyCodeLine{02558\ }
\DoxyCodeLine{02559\ \textcolor{comment}{//\ A\ comparator\ functor\ that\ uses\ the\ <\ operator\ to\ compare\ two\ values.}}
\DoxyCodeLine{02560\ \textcolor{keyword}{struct\ }LessComparator\ \{}
\DoxyCodeLine{02561\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{02562\ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keyword}{const}\ T\&\ lhs,\ \textcolor{keyword}{const}\ U\&\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02563\ \ \ \ \ \textcolor{keywordflow}{return}\ lhs\ <\ rhs;}
\DoxyCodeLine{02564\ \ \ \}}
\DoxyCodeLine{02565\ \};}
\DoxyCodeLine{02566\ }
\DoxyCodeLine{02567\ \textcolor{comment}{//\ Implements\ WhenSortedBy(comparator,\ container\_matcher).}}
\DoxyCodeLine{02568\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Comparator,\ \textcolor{keyword}{typename}\ ContainerMatcher>}
\DoxyCodeLine{02569\ \textcolor{keyword}{class\ }WhenSortedByMatcher\ \{}
\DoxyCodeLine{02570\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02571\ \ \ WhenSortedByMatcher(\textcolor{keyword}{const}\ Comparator\&\ comparator,}
\DoxyCodeLine{02572\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ContainerMatcher\&\ matcher)}
\DoxyCodeLine{02573\ \ \ \ \ \ \ :\ comparator\_(comparator),\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{02574\ }
\DoxyCodeLine{02575\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02576\ \ \ \textcolor{keyword}{operator}\ Matcher<LhsContainer>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02577\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<LhsContainer>(comparator\_,\ matcher\_));}
\DoxyCodeLine{02578\ \ \ \}}
\DoxyCodeLine{02579\ }
\DoxyCodeLine{02580\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02581\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<LhsContainer>\ \{}
\DoxyCodeLine{02582\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02583\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{02584\ \ \ \ \ \ \ \ \ LhsContainer)>}
\DoxyCodeLine{02585\ \ \ \ \ \ \ \ \ LhsView;}
\DoxyCodeLine{02586\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::type\ LhsStlContainer;}
\DoxyCodeLine{02587\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::const\_reference\ LhsStlContainerReference;}
\DoxyCodeLine{02588\ \ \ \ \ \textcolor{comment}{//\ Transforms\ std::pair<const\ Key,\ Value>\ into\ std::pair<Key,\ Value>}}
\DoxyCodeLine{02589\ \ \ \ \ \textcolor{comment}{//\ so\ that\ we\ can\ match\ associative\ containers.}}
\DoxyCodeLine{02590\ \ \ \ \ \textcolor{keyword}{typedef}}
\DoxyCodeLine{02591\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ RemoveConstFromKey<typename\ LhsStlContainer::value\_type>::type}
\DoxyCodeLine{02592\ \ \ \ \ \ \ \ \ \ \ \ \ LhsValue;}
\DoxyCodeLine{02593\ }
\DoxyCodeLine{02594\ \ \ \ \ Impl(\textcolor{keyword}{const}\ Comparator\&\ comparator,\ \textcolor{keyword}{const}\ ContainerMatcher\&\ matcher)}
\DoxyCodeLine{02595\ \ \ \ \ \ \ \ \ :\ comparator\_(comparator),\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{02596\ }
\DoxyCodeLine{02597\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02598\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}(when\ sorted)\ "{}};}
\DoxyCodeLine{02599\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02600\ \ \ \ \ \}}
\DoxyCodeLine{02601\ }
\DoxyCodeLine{02602\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02603\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}(when\ sorted)\ "{}};}
\DoxyCodeLine{02604\ \ \ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02605\ \ \ \ \ \}}
\DoxyCodeLine{02606\ }
\DoxyCodeLine{02607\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(LhsContainer\ lhs,}
\DoxyCodeLine{02608\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02609\ \ \ \ \ \ \ LhsStlContainerReference\ lhs\_stl\_container\ =\ LhsView::ConstReference(lhs);}
\DoxyCodeLine{02610\ \ \ \ \ \ \ ::std::vector<LhsValue>\ sorted\_container(lhs\_stl\_container.begin(),}
\DoxyCodeLine{02611\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs\_stl\_container.end());}
\DoxyCodeLine{02612\ \ \ \ \ \ \ ::std::sort(sorted\_container.begin(),\ sorted\_container.end(),}
\DoxyCodeLine{02613\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ comparator\_);}
\DoxyCodeLine{02614\ }
\DoxyCodeLine{02615\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02616\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ do\ not\ need\ to}}
\DoxyCodeLine{02617\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ construct\ the\ inner\ explanation.}}
\DoxyCodeLine{02618\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_.Matches(sorted\_container);}
\DoxyCodeLine{02619\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02620\ }
\DoxyCodeLine{02621\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}};}
\DoxyCodeLine{02622\ \ \ \ \ \ \ UniversalPrint(sorted\_container,\ listener-\/>stream());}
\DoxyCodeLine{02623\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ when\ sorted"{}};}
\DoxyCodeLine{02624\ }
\DoxyCodeLine{02625\ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02626\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =}
\DoxyCodeLine{02627\ \ \ \ \ \ \ \ \ \ \ matcher\_.MatchAndExplain(sorted\_container,\ \&inner\_listener);}
\DoxyCodeLine{02628\ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02629\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{02630\ \ \ \ \ \}}
\DoxyCodeLine{02631\ }
\DoxyCodeLine{02632\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02633\ \ \ \ \ \textcolor{keyword}{const}\ Comparator\ comparator\_;}
\DoxyCodeLine{02634\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ ::std::vector<LhsValue>\&>\ matcher\_;}
\DoxyCodeLine{02635\ }
\DoxyCodeLine{02636\ \ \ \ \ Impl(\textcolor{keyword}{const}\ Impl\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{02637\ \ \ \ \ Impl\&\ operator=(\textcolor{keyword}{const}\ Impl\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{02638\ \ \ \};}
\DoxyCodeLine{02639\ }
\DoxyCodeLine{02640\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02641\ \ \ \textcolor{keyword}{const}\ Comparator\ comparator\_;}
\DoxyCodeLine{02642\ \ \ \textcolor{keyword}{const}\ ContainerMatcher\ matcher\_;}
\DoxyCodeLine{02643\ \};}
\DoxyCodeLine{02644\ }
\DoxyCodeLine{02645\ \textcolor{comment}{//\ Implements\ Pointwise(tuple\_matcher,\ rhs\_container).\ \ tuple\_matcher}}
\DoxyCodeLine{02646\ \textcolor{comment}{//\ must\ be\ able\ to\ be\ safely\ cast\ to\ Matcher<std::tuple<const\ T1\&,\ const}}
\DoxyCodeLine{02647\ \textcolor{comment}{//\ T2\&>\ >,\ where\ T1\ and\ T2\ are\ the\ types\ of\ elements\ in\ the\ LHS}}
\DoxyCodeLine{02648\ \textcolor{comment}{//\ container\ and\ the\ RHS\ container\ respectively.}}
\DoxyCodeLine{02649\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TupleMatcher,\ \textcolor{keyword}{typename}\ RhsContainer>}
\DoxyCodeLine{02650\ \textcolor{keyword}{class\ }PointwiseMatcher\ \{}
\DoxyCodeLine{02651\ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{02652\ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(RhsContainer)>::value,}
\DoxyCodeLine{02653\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}use\ UnorderedPointwise\ with\ hash\ tables"{}});}
\DoxyCodeLine{02654\ }
\DoxyCodeLine{02655\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02656\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<RhsContainer>\ RhsView;}
\DoxyCodeLine{02657\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsView::type\ RhsStlContainer;}
\DoxyCodeLine{02658\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsStlContainer::value\_type\ RhsValue;}
\DoxyCodeLine{02659\ }
\DoxyCodeLine{02660\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_const<RhsContainer>::value,}
\DoxyCodeLine{02661\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}RhsContainer\ type\ must\ not\ be\ const"{}});}
\DoxyCodeLine{02662\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_reference<RhsContainer>::value,}
\DoxyCodeLine{02663\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}RhsContainer\ type\ must\ not\ be\ a\ reference"{}});}
\DoxyCodeLine{02664\ }
\DoxyCodeLine{02665\ \ \ \textcolor{comment}{//\ Like\ ContainerEq,\ we\ make\ a\ copy\ of\ rhs\ in\ case\ the\ elements\ in}}
\DoxyCodeLine{02666\ \ \ \textcolor{comment}{//\ it\ are\ modified\ after\ this\ matcher\ is\ created.}}
\DoxyCodeLine{02667\ \ \ PointwiseMatcher(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ \textcolor{keyword}{const}\ RhsContainer\&\ rhs)}
\DoxyCodeLine{02668\ \ \ \ \ \ \ :\ tuple\_matcher\_(tuple\_matcher),\ rhs\_(RhsView::Copy(rhs))\ \{\}}
\DoxyCodeLine{02669\ }
\DoxyCodeLine{02670\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02671\ \ \ \textcolor{keyword}{operator}\ Matcher<LhsContainer>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02672\ \ \ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{02673\ \ \ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)>::value,}
\DoxyCodeLine{02674\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}use\ UnorderedPointwise\ with\ hash\ tables"{}});}
\DoxyCodeLine{02675\ }
\DoxyCodeLine{02676\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<LhsContainer>(}
\DoxyCodeLine{02677\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ LhsContainer\&>(tuple\_matcher\_,\ rhs\_));}
\DoxyCodeLine{02678\ \ \ \}}
\DoxyCodeLine{02679\ }
\DoxyCodeLine{02680\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02681\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<LhsContainer>\ \{}
\DoxyCodeLine{02682\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02683\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{02684\ \ \ \ \ \ \ \ \ LhsContainer)>}
\DoxyCodeLine{02685\ \ \ \ \ \ \ \ \ LhsView;}
\DoxyCodeLine{02686\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::type\ LhsStlContainer;}
\DoxyCodeLine{02687\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::const\_reference\ LhsStlContainerReference;}
\DoxyCodeLine{02688\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsStlContainer::value\_type\ LhsValue;}
\DoxyCodeLine{02689\ \ \ \ \ \textcolor{comment}{//\ We\ pass\ the\ LHS\ value\ and\ the\ RHS\ value\ to\ the\ inner\ matcher\ by}}
\DoxyCodeLine{02690\ \ \ \ \ \textcolor{comment}{//\ reference,\ as\ they\ may\ be\ expensive\ to\ copy.\ \ We\ must\ use\ tuple}}
\DoxyCodeLine{02691\ \ \ \ \ \textcolor{comment}{//\ instead\ of\ pair\ here,\ as\ a\ pair\ cannot\ hold\ references\ (C++\ 98,}}
\DoxyCodeLine{02692\ \ \ \ \ \textcolor{comment}{//\ 20.2.2\ [lib.pairs]).}}
\DoxyCodeLine{02693\ \ \ \ \ typedef\ ::std::tuple<const\ LhsValue\&,\ const\ RhsValue\&>\ InnerMatcherArg;}
\DoxyCodeLine{02694\ }
\DoxyCodeLine{02695\ \ \ \ \ Impl(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ \textcolor{keyword}{const}\ RhsStlContainer\&\ rhs)}
\DoxyCodeLine{02696\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ mono\_tuple\_matcher\_\ holds\ a\ monomorphic\ version\ of\ the\ tuple\ matcher.}}
\DoxyCodeLine{02697\ \ \ \ \ \ \ \ \ :\ mono\_tuple\_matcher\_(SafeMatcherCast<InnerMatcherArg>(tuple\_matcher)),}
\DoxyCodeLine{02698\ \ \ \ \ \ \ \ \ \ \ rhs\_(rhs)\ \{\}}
\DoxyCodeLine{02699\ }
\DoxyCodeLine{02700\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02701\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ "{}}\ <<\ rhs\_.size()}
\DoxyCodeLine{02702\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ values,\ where\ each\ value\ and\ its\ corresponding\ value\ in\ "{}};}
\DoxyCodeLine{02703\ \ \ \ \ \ \ UniversalPrinter<RhsStlContainer>::Print(rhs\_,\ os);}
\DoxyCodeLine{02704\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02705\ \ \ \ \ \ \ mono\_tuple\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02706\ \ \ \ \ \}}
\DoxyCodeLine{02707\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02708\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ contain\ exactly\ "{}}\ <<\ rhs\_.size()}
\DoxyCodeLine{02709\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ values,\ or\ contains\ a\ value\ x\ at\ some\ index\ i"{}}}
\DoxyCodeLine{02710\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ where\ x\ and\ the\ i-\/th\ value\ of\ "{}};}
\DoxyCodeLine{02711\ \ \ \ \ \ \ UniversalPrint(rhs\_,\ os);}
\DoxyCodeLine{02712\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02713\ \ \ \ \ \ \ mono\_tuple\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02714\ \ \ \ \ \}}
\DoxyCodeLine{02715\ }
\DoxyCodeLine{02716\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(LhsContainer\ lhs,}
\DoxyCodeLine{02717\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02718\ \ \ \ \ \ \ LhsStlContainerReference\ lhs\_stl\_container\ =\ LhsView::ConstReference(lhs);}
\DoxyCodeLine{02719\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ actual\_size\ =\ lhs\_stl\_container.size();}
\DoxyCodeLine{02720\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actual\_size\ !=\ rhs\_.size())\ \{}
\DoxyCodeLine{02721\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ contains\ "{}}\ <<\ actual\_size\ <<\ \textcolor{stringliteral}{"{}\ values"{}};}
\DoxyCodeLine{02722\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02723\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02724\ }
\DoxyCodeLine{02725\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ left\ =\ lhs\_stl\_container.begin();}
\DoxyCodeLine{02726\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ right\ =\ rhs\_.begin();}
\DoxyCodeLine{02727\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ actual\_size;\ ++i,\ ++left,\ ++right)\ \{}
\DoxyCodeLine{02728\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02729\ \ \ \ \ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02730\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Create\ InnerMatcherArg\ as\ a\ temporarily\ object\ to\ avoid\ it\ outlives}}
\DoxyCodeLine{02731\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ *left\ and\ *right.\ Dereference\ or\ the\ conversion\ to\ \`{}const\ T\&`\ may}}
\DoxyCodeLine{02732\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ return\ temp\ objects,\ e.g.\ for\ vector<bool>.}}
\DoxyCodeLine{02733\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!mono\_tuple\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{02734\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InnerMatcherArg(ImplicitCast\_<const\ LhsValue\&>(*left),}
\DoxyCodeLine{02735\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ImplicitCast\_<const\ RhsValue\&>(*right)),}
\DoxyCodeLine{02736\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&inner\_listener))\ \{}
\DoxyCodeLine{02737\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ the\ value\ pair\ ("{}};}
\DoxyCodeLine{02738\ \ \ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*left,\ listener-\/>stream());}
\DoxyCodeLine{02739\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02740\ \ \ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*right,\ listener-\/>stream());}
\DoxyCodeLine{02741\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{})\ at\ index\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ don't\ match"{}};}
\DoxyCodeLine{02742\ \ \ \ \ \ \ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02743\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02744\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02745\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02746\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!mono\_tuple\_matcher\_.Matches(}
\DoxyCodeLine{02747\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InnerMatcherArg(ImplicitCast\_<const\ LhsValue\&>(*left),}
\DoxyCodeLine{02748\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ImplicitCast\_<const\ RhsValue\&>(*right))))}
\DoxyCodeLine{02749\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02750\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02751\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02752\ }
\DoxyCodeLine{02753\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02754\ \ \ \ \ \}}
\DoxyCodeLine{02755\ }
\DoxyCodeLine{02756\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02757\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<InnerMatcherArg>\ mono\_tuple\_matcher\_;}
\DoxyCodeLine{02758\ \ \ \ \ \textcolor{keyword}{const}\ RhsStlContainer\ rhs\_;}
\DoxyCodeLine{02759\ \ \ \};}
\DoxyCodeLine{02760\ }
\DoxyCodeLine{02761\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02762\ \ \ \textcolor{keyword}{const}\ TupleMatcher\ tuple\_matcher\_;}
\DoxyCodeLine{02763\ \ \ \textcolor{keyword}{const}\ RhsStlContainer\ rhs\_;}
\DoxyCodeLine{02764\ \};}
\DoxyCodeLine{02765\ }
\DoxyCodeLine{02766\ \textcolor{comment}{//\ Holds\ the\ logic\ common\ to\ ContainsMatcherImpl\ and\ EachMatcherImpl.}}
\DoxyCodeLine{02767\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02768\ \textcolor{keyword}{class\ }QuantifierMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{02769\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02770\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{02771\ \ \ \textcolor{keyword}{typedef}\ StlContainerView<RawContainer>\ View;}
\DoxyCodeLine{02772\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{02773\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{02774\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ StlContainer::value\_type\ Element;}
\DoxyCodeLine{02775\ }
\DoxyCodeLine{02776\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02777\ \ \ \textcolor{keyword}{explicit}\ QuantifierMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02778\ \ \ \ \ \ \ :\ inner\_matcher\_(}
\DoxyCodeLine{02779\ \ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ Element\&>(inner\_matcher))\ \{\}}
\DoxyCodeLine{02780\ }
\DoxyCodeLine{02781\ \ \ \textcolor{comment}{//\ Checks\ whether:}}
\DoxyCodeLine{02782\ \ \ \textcolor{comment}{//\ *\ All\ elements\ in\ the\ container\ match,\ if\ all\_elements\_should\_match.}}
\DoxyCodeLine{02783\ \ \ \textcolor{comment}{//\ *\ Any\ element\ in\ the\ container\ matches,\ if\ !all\_elements\_should\_match.}}
\DoxyCodeLine{02784\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(\textcolor{keywordtype}{bool}\ all\_elements\_should\_match,\ Container\ container,}
\DoxyCodeLine{02785\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02786\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{02787\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ 0;}
\DoxyCodeLine{02788\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ stl\_container.begin();\ it\ !=\ stl\_container.end();}
\DoxyCodeLine{02789\ \ \ \ \ \ \ \ \ \ ++it,\ ++i)\ \{}
\DoxyCodeLine{02790\ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02791\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ matches\ =\ inner\_matcher\_.MatchAndExplain(*it,\ \&inner\_listener);}
\DoxyCodeLine{02792\ }
\DoxyCodeLine{02793\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matches\ !=\ all\_elements\_should\_match)\ \{}
\DoxyCodeLine{02794\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ i}
\DoxyCodeLine{02795\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (matches\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{02796\ \ \ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02797\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !all\_elements\_should\_match;}
\DoxyCodeLine{02798\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02799\ \ \ \ \ \}}
\DoxyCodeLine{02800\ \ \ \ \ \textcolor{keywordflow}{return}\ all\_elements\_should\_match;}
\DoxyCodeLine{02801\ \ \ \}}
\DoxyCodeLine{02802\ }
\DoxyCodeLine{02803\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(\textcolor{keyword}{const}\ Matcher<size\_t>\&\ count\_matcher,}
\DoxyCodeLine{02804\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Container\ container,}
\DoxyCodeLine{02805\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02806\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{02807\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ 0;}
\DoxyCodeLine{02808\ \ \ \ \ std::vector<size\_t>\ match\_elements;}
\DoxyCodeLine{02809\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ stl\_container.begin();\ it\ !=\ stl\_container.end();}
\DoxyCodeLine{02810\ \ \ \ \ \ \ \ \ \ ++it,\ ++i)\ \{}
\DoxyCodeLine{02811\ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02812\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ matches\ =\ inner\_matcher\_.MatchAndExplain(*it,\ \&inner\_listener);}
\DoxyCodeLine{02813\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matches)\ \{}
\DoxyCodeLine{02814\ \ \ \ \ \ \ \ \ match\_elements.push\_back(i);}
\DoxyCodeLine{02815\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02816\ \ \ \ \ \}}
\DoxyCodeLine{02817\ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02818\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (match\_elements.empty())\ \{}
\DoxyCodeLine{02819\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}has\ no\ element\ that\ matches"{}};}
\DoxyCodeLine{02820\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (match\_elements.size()\ ==\ 1)\ \{}
\DoxyCodeLine{02821\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ match\_elements[0]\ <<\ \textcolor{stringliteral}{"{}\ matches"{}};}
\DoxyCodeLine{02822\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02823\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ elements\ ("{}};}
\DoxyCodeLine{02824\ \ \ \ \ \ \ \ \ std::string\ sep\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{02825\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ e\ :\ match\_elements)\ \{}
\DoxyCodeLine{02826\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ sep\ <<\ e;}
\DoxyCodeLine{02827\ \ \ \ \ \ \ \ \ \ \ sep\ =\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02828\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02829\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{})\ match"{}};}
\DoxyCodeLine{02830\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02831\ \ \ \ \ \}}
\DoxyCodeLine{02832\ \ \ \ \ StringMatchResultListener\ count\_listener;}
\DoxyCodeLine{02833\ \ \ \ \ \textcolor{keywordflow}{if}\ (count\_matcher.MatchAndExplain(match\_elements.size(),\ \&count\_listener))\ \{}
\DoxyCodeLine{02834\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ and\ whose\ match\ quantity\ of\ "{}}\ <<\ match\_elements.size()}
\DoxyCodeLine{02835\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ matches"{}};}
\DoxyCodeLine{02836\ \ \ \ \ \ \ PrintIfNotEmpty(count\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02837\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02838\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02839\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (match\_elements.empty())\ \{}
\DoxyCodeLine{02840\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ and"{}};}
\DoxyCodeLine{02841\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02842\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ but"{}};}
\DoxyCodeLine{02843\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02844\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ whose\ match\ quantity\ of\ "{}}\ <<\ match\_elements.size()}
\DoxyCodeLine{02845\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ does\ not\ match"{}};}
\DoxyCodeLine{02846\ \ \ \ \ \ \ PrintIfNotEmpty(count\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02847\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02848\ \ \ \ \ \}}
\DoxyCodeLine{02849\ \ \ \}}
\DoxyCodeLine{02850\ }
\DoxyCodeLine{02851\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{02852\ \ \ \textcolor{keyword}{const}\ Matcher<const\ Element\&>\ inner\_matcher\_;}
\DoxyCodeLine{02853\ \};}
\DoxyCodeLine{02854\ }
\DoxyCodeLine{02855\ \textcolor{comment}{//\ Implements\ Contains(element\_matcher)\ for\ the\ given\ argument\ type\ Container.}}
\DoxyCodeLine{02856\ \textcolor{comment}{//\ Symmetric\ to\ EachMatcherImpl.}}
\DoxyCodeLine{02857\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02858\ \textcolor{keyword}{class\ }ContainsMatcherImpl\ :\ \textcolor{keyword}{public}\ QuantifierMatcherImpl<Container>\ \{}
\DoxyCodeLine{02859\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02860\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02861\ \ \ \textcolor{keyword}{explicit}\ ContainsMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02862\ \ \ \ \ \ \ :\ QuantifierMatcherImpl<Container>(inner\_matcher)\ \{\}}
\DoxyCodeLine{02863\ }
\DoxyCodeLine{02864\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{02865\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02866\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ at\ least\ one\ element\ that\ "{}};}
\DoxyCodeLine{02867\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02868\ \ \ \}}
\DoxyCodeLine{02869\ }
\DoxyCodeLine{02870\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02871\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ contain\ any\ element\ that\ "{}};}
\DoxyCodeLine{02872\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02873\ \ \ \}}
\DoxyCodeLine{02874\ }
\DoxyCodeLine{02875\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02876\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02877\ \ \ \ \ \textcolor{keywordflow}{return}\ this-\/>MatchAndExplainImpl(\textcolor{keyword}{false},\ container,\ listener);}
\DoxyCodeLine{02878\ \ \ \}}
\DoxyCodeLine{02879\ \};}
\DoxyCodeLine{02880\ }
\DoxyCodeLine{02881\ \textcolor{comment}{//\ Implements\ DistanceFrom(target,\ get\_distance,\ distance\_matcher)\ for\ the\ given}}
\DoxyCodeLine{02882\ \textcolor{comment}{//\ argument\ types:}}
\DoxyCodeLine{02883\ \textcolor{comment}{//\ \ \ *\ V\ is\ the\ type\ of\ the\ value\ to\ be\ matched.}}
\DoxyCodeLine{02884\ \textcolor{comment}{//\ \ \ *\ T\ is\ the\ type\ of\ the\ target\ value.}}
\DoxyCodeLine{02885\ \textcolor{comment}{//\ \ \ *\ Distance\ is\ the\ type\ of\ the\ distance\ between\ V\ and\ T.}}
\DoxyCodeLine{02886\ \textcolor{comment}{//\ \ \ *\ GetDistance\ is\ the\ type\ of\ the\ functor\ for\ computing\ the\ distance\ between}}
\DoxyCodeLine{02887\ \textcolor{comment}{//\ \ \ \ \ V\ and\ T.}}
\DoxyCodeLine{02888\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ V,\ \textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Distance,\ \textcolor{keyword}{typename}\ GetDistance>}
\DoxyCodeLine{02889\ \textcolor{keyword}{class\ }DistanceFromMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<V>\ \{}
\DoxyCodeLine{02890\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02891\ \ \ \textcolor{comment}{//\ Arguments:}}
\DoxyCodeLine{02892\ \ \ \textcolor{comment}{//\ \ \ *\ target:\ the\ target\ value.}}
\DoxyCodeLine{02893\ \ \ \textcolor{comment}{//\ \ \ *\ get\_distance:\ the\ functor\ for\ computing\ the\ distance\ between\ the\ value}}
\DoxyCodeLine{02894\ \ \ \textcolor{comment}{//\ \ \ being\ matched\ and\ target.}}
\DoxyCodeLine{02895\ \ \ \textcolor{comment}{//\ \ \ *\ distance\_matcher:\ the\ matcher\ for\ checking\ the\ distance.}}
\DoxyCodeLine{02896\ \ \ DistanceFromMatcherImpl(T\ target,\ GetDistance\ get\_distance,}
\DoxyCodeLine{02897\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Matcher<const\ Distance\&>\ distance\_matcher)}
\DoxyCodeLine{02898\ \ \ \ \ \ \ :\ target\_(std::move(target)),}
\DoxyCodeLine{02899\ \ \ \ \ \ \ \ \ get\_distance\_(std::move(get\_distance)),}
\DoxyCodeLine{02900\ \ \ \ \ \ \ \ \ distance\_matcher\_(std::move(distance\_matcher))\ \{\}}
\DoxyCodeLine{02901\ }
\DoxyCodeLine{02902\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{02903\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02904\ \ \ \ \ distance\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02905\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ away\ from\ "{}}\ <<\ PrintToString(target\_);}
\DoxyCodeLine{02906\ \ \ \}}
\DoxyCodeLine{02907\ }
\DoxyCodeLine{02908\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02909\ \ \ \ \ distance\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02910\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ away\ from\ "{}}\ <<\ PrintToString(target\_);}
\DoxyCodeLine{02911\ \ \ \}}
\DoxyCodeLine{02912\ }
\DoxyCodeLine{02913\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(V\ value,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02914\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ distance\ =\ get\_distance\_(value,\ target\_);}
\DoxyCodeLine{02915\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ distance\_matcher\_.Matches(distance);}
\DoxyCodeLine{02916\ \ \ \ \ \textcolor{keywordflow}{if}\ (!match\ \&\&\ listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02917\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}}\ <<\ PrintToString(distance)\ <<\ \textcolor{stringliteral}{"{}\ away\ from\ "{}}}
\DoxyCodeLine{02918\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ PrintToString(target\_);}
\DoxyCodeLine{02919\ \ \ \ \ \}}
\DoxyCodeLine{02920\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{02921\ \ \ \}}
\DoxyCodeLine{02922\ }
\DoxyCodeLine{02923\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02924\ \ \ \textcolor{keyword}{const}\ T\ target\_;}
\DoxyCodeLine{02925\ \ \ \textcolor{keyword}{const}\ GetDistance\ get\_distance\_;}
\DoxyCodeLine{02926\ \ \ \textcolor{keyword}{const}\ Matcher<const\ Distance\&>\ distance\_matcher\_;}
\DoxyCodeLine{02927\ \};}
\DoxyCodeLine{02928\ }
\DoxyCodeLine{02929\ \textcolor{comment}{//\ Implements\ Each(element\_matcher)\ for\ the\ given\ argument\ type\ Container.}}
\DoxyCodeLine{02930\ \textcolor{comment}{//\ Symmetric\ to\ ContainsMatcherImpl.}}
\DoxyCodeLine{02931\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02932\ \textcolor{keyword}{class\ }EachMatcherImpl\ :\ \textcolor{keyword}{public}\ QuantifierMatcherImpl<Container>\ \{}
\DoxyCodeLine{02933\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02934\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02935\ \ \ \textcolor{keyword}{explicit}\ EachMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02936\ \ \ \ \ \ \ :\ QuantifierMatcherImpl<Container>(inner\_matcher)\ \{\}}
\DoxyCodeLine{02937\ }
\DoxyCodeLine{02938\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{02939\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02940\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}only\ contains\ elements\ that\ "{}};}
\DoxyCodeLine{02941\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02942\ \ \ \}}
\DoxyCodeLine{02943\ }
\DoxyCodeLine{02944\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02945\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ some\ element\ that\ "{}};}
\DoxyCodeLine{02946\ \ \ \ \ this-\/>inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02947\ \ \ \}}
\DoxyCodeLine{02948\ }
\DoxyCodeLine{02949\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02950\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02951\ \ \ \ \ \textcolor{keywordflow}{return}\ this-\/>MatchAndExplainImpl(\textcolor{keyword}{true},\ container,\ listener);}
\DoxyCodeLine{02952\ \ \ \}}
\DoxyCodeLine{02953\ \};}
\DoxyCodeLine{02954\ }
\DoxyCodeLine{02955\ \textcolor{comment}{//\ Implements\ Contains(element\_matcher).Times(n)\ for\ the\ given\ argument\ type}}
\DoxyCodeLine{02956\ \textcolor{comment}{//\ Container.}}
\DoxyCodeLine{02957\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02958\ \textcolor{keyword}{class\ }ContainsTimesMatcherImpl\ :\ \textcolor{keyword}{public}\ QuantifierMatcherImpl<Container>\ \{}
\DoxyCodeLine{02959\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02960\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02961\ \ \ \textcolor{keyword}{explicit}\ ContainsTimesMatcherImpl(InnerMatcher\ inner\_matcher,}
\DoxyCodeLine{02962\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Matcher<size\_t>\ count\_matcher)}
\DoxyCodeLine{02963\ \ \ \ \ \ \ :\ QuantifierMatcherImpl<Container>(inner\_matcher),}
\DoxyCodeLine{02964\ \ \ \ \ \ \ \ \ count\_matcher\_(std::move(count\_matcher))\ \{\}}
\DoxyCodeLine{02965\ }
\DoxyCodeLine{02966\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02967\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}quantity\ of\ elements\ that\ match\ "{}};}
\DoxyCodeLine{02968\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02969\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02970\ \ \ \ \ count\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02971\ \ \ \}}
\DoxyCodeLine{02972\ }
\DoxyCodeLine{02973\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02974\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}quantity\ of\ elements\ that\ match\ "{}};}
\DoxyCodeLine{02975\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02976\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02977\ \ \ \ \ count\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02978\ \ \ \}}
\DoxyCodeLine{02979\ }
\DoxyCodeLine{02980\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02981\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02982\ \ \ \ \ \textcolor{keywordflow}{return}\ this-\/>MatchAndExplainImpl(count\_matcher\_,\ container,\ listener);}
\DoxyCodeLine{02983\ \ \ \}}
\DoxyCodeLine{02984\ }
\DoxyCodeLine{02985\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02986\ \ \ \textcolor{keyword}{const}\ Matcher<size\_t>\ count\_matcher\_;}
\DoxyCodeLine{02987\ \};}
\DoxyCodeLine{02988\ }
\DoxyCodeLine{02989\ \textcolor{comment}{//\ Implements\ polymorphic\ Contains(element\_matcher).Times(n).}}
\DoxyCodeLine{02990\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02991\ \textcolor{keyword}{class\ }ContainsTimesMatcher\ \{}
\DoxyCodeLine{02992\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02993\ \ \ \textcolor{keyword}{explicit}\ ContainsTimesMatcher(M\ m,\ Matcher<size\_t>\ count\_matcher)}
\DoxyCodeLine{02994\ \ \ \ \ \ \ :\ inner\_matcher\_(m),\ count\_matcher\_(std::move(count\_matcher))\ \{\}}
\DoxyCodeLine{02995\ }
\DoxyCodeLine{02996\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02997\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02998\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ ContainsTimesMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{02999\ \ \ \ \ \ \ \ \ inner\_matcher\_,\ count\_matcher\_));}
\DoxyCodeLine{03000\ \ \ \}}
\DoxyCodeLine{03001\ }
\DoxyCodeLine{03002\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03003\ \ \ \textcolor{keyword}{const}\ M\ inner\_matcher\_;}
\DoxyCodeLine{03004\ \ \ \textcolor{keyword}{const}\ Matcher<size\_t>\ count\_matcher\_;}
\DoxyCodeLine{03005\ \};}
\DoxyCodeLine{03006\ }
\DoxyCodeLine{03007\ \textcolor{comment}{//\ Implements\ polymorphic\ Contains(element\_matcher).}}
\DoxyCodeLine{03008\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{03009\ \textcolor{keyword}{class\ }ContainsMatcher\ \{}
\DoxyCodeLine{03010\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03011\ \ \ \textcolor{keyword}{explicit}\ ContainsMatcher(M\ m)\ :\ inner\_matcher\_(m)\ \{\}}
\DoxyCodeLine{03012\ }
\DoxyCodeLine{03013\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03014\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03015\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{03016\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ContainsMatcherImpl<const\ Container\&>(inner\_matcher\_));}
\DoxyCodeLine{03017\ \ \ \}}
\DoxyCodeLine{03018\ }
\DoxyCodeLine{03019\ \ \ ContainsTimesMatcher<M>\ Times(Matcher<size\_t>\ count\_matcher)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03020\ \ \ \ \ \textcolor{keywordflow}{return}\ ContainsTimesMatcher<M>(inner\_matcher\_,\ std::move(count\_matcher));}
\DoxyCodeLine{03021\ \ \ \}}
\DoxyCodeLine{03022\ }
\DoxyCodeLine{03023\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03024\ \ \ \textcolor{keyword}{const}\ M\ inner\_matcher\_;}
\DoxyCodeLine{03025\ \};}
\DoxyCodeLine{03026\ }
\DoxyCodeLine{03027\ \textcolor{comment}{//\ Implements\ polymorphic\ Each(element\_matcher).}}
\DoxyCodeLine{03028\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{03029\ \textcolor{keyword}{class\ }EachMatcher\ \{}
\DoxyCodeLine{03030\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03031\ \ \ \textcolor{keyword}{explicit}\ EachMatcher(M\ m)\ :\ inner\_matcher\_(m)\ \{\}}
\DoxyCodeLine{03032\ }
\DoxyCodeLine{03033\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03034\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03035\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{03036\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ EachMatcherImpl<const\ Container\&>(inner\_matcher\_));}
\DoxyCodeLine{03037\ \ \ \}}
\DoxyCodeLine{03038\ }
\DoxyCodeLine{03039\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03040\ \ \ \textcolor{keyword}{const}\ M\ inner\_matcher\_;}
\DoxyCodeLine{03041\ \};}
\DoxyCodeLine{03042\ }
\DoxyCodeLine{03043\ \textcolor{keyword}{namespace\ }pair\_getters\ \{}
\DoxyCodeLine{03044\ \textcolor{keyword}{using\ }std::get;}
\DoxyCodeLine{03045\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03046\ \textcolor{keyword}{auto}\ First(T\&\ x,\ Rank0)\ -\/>\ \textcolor{keyword}{decltype}(get<0>(x))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03047\ \ \ \textcolor{keywordflow}{return}\ get<0>(x);}
\DoxyCodeLine{03048\ \}}
\DoxyCodeLine{03049\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03050\ \textcolor{keyword}{auto}\ First(T\&\ x,\ Rank1)\ -\/>\ \textcolor{keyword}{decltype}((x.first))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03051\ \ \ \textcolor{keywordflow}{return}\ x.first;}
\DoxyCodeLine{03052\ \}}
\DoxyCodeLine{03053\ }
\DoxyCodeLine{03054\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03055\ \textcolor{keyword}{auto}\ Second(T\&\ x,\ Rank0)\ -\/>\ \textcolor{keyword}{decltype}(get<1>(x))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03056\ \ \ \textcolor{keywordflow}{return}\ get<1>(x);}
\DoxyCodeLine{03057\ \}}
\DoxyCodeLine{03058\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03059\ \textcolor{keyword}{auto}\ Second(T\&\ x,\ Rank1)\ -\/>\ \textcolor{keyword}{decltype}((x.second))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03060\ \ \ \textcolor{keywordflow}{return}\ x.second;}
\DoxyCodeLine{03061\ \}}
\DoxyCodeLine{03062\ \}\ \ \textcolor{comment}{//\ namespace\ pair\_getters}}
\DoxyCodeLine{03063\ }
\DoxyCodeLine{03064\ \textcolor{comment}{//\ Default\ functor\ for\ computing\ the\ distance\ between\ two\ values.}}
\DoxyCodeLine{03065\ \textcolor{keyword}{struct\ }DefaultGetDistance\ \{}
\DoxyCodeLine{03066\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{03067\ \ \ \textcolor{keyword}{auto}\ operator()(\textcolor{keyword}{const}\ T\&\ lhs,\ \textcolor{keyword}{const}\ U\&\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03068\ \ \ \ \ \textcolor{keyword}{using\ }std::abs;}
\DoxyCodeLine{03069\ \ \ \ \ \textcolor{comment}{//\ Allow\ finding\ abs()\ in\ the\ type's\ namespace\ via\ ADL.}}
\DoxyCodeLine{03070\ \ \ \ \ \textcolor{keywordflow}{return}\ abs(lhs\ -\/\ rhs);}
\DoxyCodeLine{03071\ \ \ \}}
\DoxyCodeLine{03072\ \};}
\DoxyCodeLine{03073\ }
\DoxyCodeLine{03074\ \textcolor{comment}{//\ Implements\ polymorphic\ DistanceFrom(target,\ get\_distance,\ distance\_matcher)}}
\DoxyCodeLine{03075\ \textcolor{comment}{//\ matcher.\ Template\ arguments:}}
\DoxyCodeLine{03076\ \textcolor{comment}{//\ \ \ *\ T\ is\ the\ type\ of\ the\ target\ value.}}
\DoxyCodeLine{03077\ \textcolor{comment}{//\ \ \ *\ GetDistance\ is\ the\ type\ of\ the\ functor\ for\ computing\ the\ distance\ between}}
\DoxyCodeLine{03078\ \textcolor{comment}{//\ \ \ \ \ the\ value\ being\ matched\ and\ the\ target.}}
\DoxyCodeLine{03079\ \textcolor{comment}{//\ \ \ *\ DistanceMatcher\ is\ the\ type\ of\ the\ matcher\ for\ checking\ the\ distance.}}
\DoxyCodeLine{03080\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ GetDistance,\ \textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{03081\ \textcolor{keyword}{class\ }DistanceFromMatcher\ \{}
\DoxyCodeLine{03082\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03083\ \ \ \textcolor{comment}{//\ Arguments:}}
\DoxyCodeLine{03084\ \ \ \textcolor{comment}{//\ \ \ *\ target:\ the\ target\ value.}}
\DoxyCodeLine{03085\ \ \ \textcolor{comment}{//\ \ \ *\ get\_distance:\ the\ functor\ for\ computing\ the\ distance\ between\ the\ value}}
\DoxyCodeLine{03086\ \ \ \textcolor{comment}{//\ \ \ \ \ being\ matched\ and\ target.}}
\DoxyCodeLine{03087\ \ \ \textcolor{comment}{//\ \ \ *\ distance\_matcher:\ the\ matcher\ for\ checking\ the\ distance.}}
\DoxyCodeLine{03088\ \ \ DistanceFromMatcher(T\ target,\ GetDistance\ get\_distance,}
\DoxyCodeLine{03089\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ DistanceMatcher\ distance\_matcher)}
\DoxyCodeLine{03090\ \ \ \ \ \ \ :\ target\_(std::move(target)),}
\DoxyCodeLine{03091\ \ \ \ \ \ \ \ \ get\_distance\_(std::move(get\_distance)),}
\DoxyCodeLine{03092\ \ \ \ \ \ \ \ \ distance\_matcher\_(std::move(distance\_matcher))\ \{\}}
\DoxyCodeLine{03093\ }
\DoxyCodeLine{03094\ \ \ DistanceFromMatcher(\textcolor{keyword}{const}\ DistanceFromMatcher\&\ other)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{03095\ }
\DoxyCodeLine{03096\ \ \ \textcolor{comment}{//\ Implicitly\ converts\ to\ a\ monomorphic\ matcher\ of\ the\ given\ type.}}
\DoxyCodeLine{03097\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ V>}
\DoxyCodeLine{03098\ \ \ \textcolor{keyword}{operator}\ Matcher<V>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03099\ \ \ \ \ \textcolor{keyword}{using\ }Distance\ =\ \textcolor{keyword}{decltype}(get\_distance\_(std::declval<V>(),\ target\_));}
\DoxyCodeLine{03100\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<V>(\textcolor{keyword}{new}\ DistanceFromMatcherImpl<V,\ T,\ Distance,\ GetDistance>(}
\DoxyCodeLine{03101\ \ \ \ \ \ \ \ \ target\_,\ get\_distance\_,\ distance\_matcher\_));}
\DoxyCodeLine{03102\ \ \ \}}
\DoxyCodeLine{03103\ }
\DoxyCodeLine{03104\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03105\ \ \ \textcolor{keyword}{const}\ T\ target\_;}
\DoxyCodeLine{03106\ \ \ \textcolor{keyword}{const}\ GetDistance\ get\_distance\_;}
\DoxyCodeLine{03107\ \ \ \textcolor{keyword}{const}\ DistanceMatcher\ distance\_matcher\_;}
\DoxyCodeLine{03108\ \};}
\DoxyCodeLine{03109\ }
\DoxyCodeLine{03110\ \textcolor{comment}{//\ Implements\ Key(inner\_matcher)\ for\ the\ given\ argument\ pair\ type.}}
\DoxyCodeLine{03111\ \textcolor{comment}{//\ Key(inner\_matcher)\ matches\ an\ std::pair\ whose\ 'first'\ field\ matches}}
\DoxyCodeLine{03112\ \textcolor{comment}{//\ inner\_matcher.\ \ For\ example,\ Contains(Key(Ge(5)))\ can\ be\ used\ to\ match\ an}}
\DoxyCodeLine{03113\ \textcolor{comment}{//\ std::map\ that\ contains\ at\ least\ one\ element\ whose\ key\ is\ >=\ 5.}}
\DoxyCodeLine{03114\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{03115\ \textcolor{keyword}{class\ }KeyMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<PairType>\ \{}
\DoxyCodeLine{03116\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03117\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType)\ RawPairType;}
\DoxyCodeLine{03118\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RawPairType::first\_type\ KeyType;}
\DoxyCodeLine{03119\ }
\DoxyCodeLine{03120\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{03121\ \ \ \textcolor{keyword}{explicit}\ KeyMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{03122\ \ \ \ \ \ \ :\ inner\_matcher\_(}
\DoxyCodeLine{03123\ \ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ KeyType\&>(inner\_matcher))\ \{\}}
\DoxyCodeLine{03124\ }
\DoxyCodeLine{03125\ \ \ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ 'key\_value.first'\ (the\ key)\ matches\ the\ inner}}
\DoxyCodeLine{03126\ \ \ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{03127\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(PairType\ key\_value,}
\DoxyCodeLine{03128\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03129\ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{03130\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ inner\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{03131\ \ \ \ \ \ \ \ \ pair\_getters::First(key\_value,\ Rank1()),\ \&inner\_listener);}
\DoxyCodeLine{03132\ \ \ \ \ \textcolor{keyword}{const}\ std::string\ explanation\ =\ inner\_listener.str();}
\DoxyCodeLine{03133\ \ \ \ \ \textcolor{keywordflow}{if}\ (!explanation.empty())\ \{}
\DoxyCodeLine{03134\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ first\ field\ is\ a\ value\ "{}}\ <<\ explanation;}
\DoxyCodeLine{03135\ \ \ \ \ \}}
\DoxyCodeLine{03136\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{03137\ \ \ \}}
\DoxyCodeLine{03138\ }
\DoxyCodeLine{03139\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03140\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03141\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ key\ that\ "{}};}
\DoxyCodeLine{03142\ \ \ \ \ inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03143\ \ \ \}}
\DoxyCodeLine{03144\ }
\DoxyCodeLine{03145\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03146\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03147\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ have\ a\ key\ that\ "{}};}
\DoxyCodeLine{03148\ \ \ \ \ inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03149\ \ \ \}}
\DoxyCodeLine{03150\ }
\DoxyCodeLine{03151\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03152\ \ \ \textcolor{keyword}{const}\ Matcher<const\ KeyType\&>\ inner\_matcher\_;}
\DoxyCodeLine{03153\ \};}
\DoxyCodeLine{03154\ }
\DoxyCodeLine{03155\ \textcolor{comment}{//\ Implements\ polymorphic\ Key(matcher\_for\_key).}}
\DoxyCodeLine{03156\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{03157\ \textcolor{keyword}{class\ }KeyMatcher\ \{}
\DoxyCodeLine{03158\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03159\ \ \ \textcolor{keyword}{explicit}\ KeyMatcher(M\ m)\ :\ matcher\_for\_key\_(m)\ \{\}}
\DoxyCodeLine{03160\ }
\DoxyCodeLine{03161\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{03162\ \ \ \textcolor{keyword}{operator}\ Matcher<PairType>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03163\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<PairType>(}
\DoxyCodeLine{03164\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ KeyMatcherImpl<const\ PairType\&>(matcher\_for\_key\_));}
\DoxyCodeLine{03165\ \ \ \}}
\DoxyCodeLine{03166\ }
\DoxyCodeLine{03167\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03168\ \ \ \textcolor{keyword}{const}\ M\ matcher\_for\_key\_;}
\DoxyCodeLine{03169\ \};}
\DoxyCodeLine{03170\ }
\DoxyCodeLine{03171\ \textcolor{comment}{//\ Implements\ polymorphic\ Address(matcher\_for\_address).}}
\DoxyCodeLine{03172\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{03173\ \textcolor{keyword}{class\ }AddressMatcher\ \{}
\DoxyCodeLine{03174\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03175\ \ \ \textcolor{keyword}{explicit}\ AddressMatcher(InnerMatcher\ m)\ :\ matcher\_(m)\ \{\}}
\DoxyCodeLine{03176\ }
\DoxyCodeLine{03177\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Type>}
\DoxyCodeLine{03178\ \ \ \textcolor{keyword}{operator}\ Matcher<Type>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03179\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Type>(\textcolor{keyword}{new}\ Impl<const\ Type\&>(matcher\_));}
\DoxyCodeLine{03180\ \ \ \}}
\DoxyCodeLine{03181\ }
\DoxyCodeLine{03182\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03183\ \ \ \textcolor{comment}{//\ The\ monomorphic\ implementation\ that\ works\ for\ a\ particular\ object\ type.}}
\DoxyCodeLine{03184\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Type>}
\DoxyCodeLine{03185\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Type>\ \{}
\DoxyCodeLine{03186\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03187\ \ \ \ \ \textcolor{keyword}{using\ }Address\ =\ \textcolor{keyword}{const}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Type)\ *;}
\DoxyCodeLine{03188\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)}
\DoxyCodeLine{03189\ \ \ \ \ \ \ \ \ :\ matcher\_(MatcherCast<Address>(matcher))\ \{\}}
\DoxyCodeLine{03190\ }
\DoxyCodeLine{03191\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03192\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ address\ that\ "{}};}
\DoxyCodeLine{03193\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{03194\ \ \ \ \ \}}
\DoxyCodeLine{03195\ }
\DoxyCodeLine{03196\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03197\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ have\ address\ that\ "{}};}
\DoxyCodeLine{03198\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{03199\ \ \ \ \ \}}
\DoxyCodeLine{03200\ }
\DoxyCodeLine{03201\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Type\ \textcolor{keywordtype}{object},}
\DoxyCodeLine{03202\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03203\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ has\ address\ "{}};}
\DoxyCodeLine{03204\ \ \ \ \ \ \ Address\ address\ =\ std::addressof(\textcolor{keywordtype}{object});}
\DoxyCodeLine{03205\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(address,\ matcher\_,\ listener);}
\DoxyCodeLine{03206\ \ \ \ \ \}}
\DoxyCodeLine{03207\ }
\DoxyCodeLine{03208\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03209\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<Address>\ matcher\_;}
\DoxyCodeLine{03210\ \ \ \};}
\DoxyCodeLine{03211\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{03212\ \};}
\DoxyCodeLine{03213\ }
\DoxyCodeLine{03214\ \textcolor{comment}{//\ Implements\ Pair(first\_matcher,\ second\_matcher)\ for\ the\ given\ argument\ pair}}
\DoxyCodeLine{03215\ \textcolor{comment}{//\ type\ with\ its\ two\ matchers.\ See\ Pair()\ function\ below.}}
\DoxyCodeLine{03216\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{03217\ \textcolor{keyword}{class\ }PairMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<PairType>\ \{}
\DoxyCodeLine{03218\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03219\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType)\ RawPairType;}
\DoxyCodeLine{03220\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RawPairType::first\_type\ FirstType;}
\DoxyCodeLine{03221\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RawPairType::second\_type\ SecondType;}
\DoxyCodeLine{03222\ }
\DoxyCodeLine{03223\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FirstMatcher,\ \textcolor{keyword}{typename}\ SecondMatcher>}
\DoxyCodeLine{03224\ \ \ PairMatcherImpl(FirstMatcher\ first\_matcher,\ SecondMatcher\ second\_matcher)}
\DoxyCodeLine{03225\ \ \ \ \ \ \ :\ first\_matcher\_(}
\DoxyCodeLine{03226\ \ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ FirstType\&>(first\_matcher)),}
\DoxyCodeLine{03227\ \ \ \ \ \ \ \ \ second\_matcher\_(}
\DoxyCodeLine{03228\ \ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ SecondType\&>(second\_matcher))\ \{\}}
\DoxyCodeLine{03229\ }
\DoxyCodeLine{03230\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03231\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03232\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ "{}};}
\DoxyCodeLine{03233\ \ \ \ \ first\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03234\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ and\ has\ a\ second\ field\ that\ "{}};}
\DoxyCodeLine{03235\ \ \ \ \ second\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03236\ \ \ \}}
\DoxyCodeLine{03237\ }
\DoxyCodeLine{03238\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03239\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03240\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ "{}};}
\DoxyCodeLine{03241\ \ \ \ \ first\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{03242\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ or\ has\ a\ second\ field\ that\ "{}};}
\DoxyCodeLine{03243\ \ \ \ \ second\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{03244\ \ \ \}}
\DoxyCodeLine{03245\ }
\DoxyCodeLine{03246\ \ \ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ 'a\_pair.first'\ matches\ first\_matcher\ and}}
\DoxyCodeLine{03247\ \ \ \textcolor{comment}{//\ 'a\_pair.second'\ matches\ second\_matcher.}}
\DoxyCodeLine{03248\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(PairType\ a\_pair,}
\DoxyCodeLine{03249\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03250\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03251\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ don't\ need\ to\ construct\ the}}
\DoxyCodeLine{03252\ \ \ \ \ \ \ \textcolor{comment}{//\ explanation.}}
\DoxyCodeLine{03253\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ first\_matcher\_.Matches(pair\_getters::First(a\_pair,\ Rank1()))\ \&\&}
\DoxyCodeLine{03254\ \ \ \ \ \ \ \ \ \ \ \ \ \ second\_matcher\_.Matches(pair\_getters::Second(a\_pair,\ Rank1()));}
\DoxyCodeLine{03255\ \ \ \ \ \}}
\DoxyCodeLine{03256\ \ \ \ \ StringMatchResultListener\ first\_inner\_listener;}
\DoxyCodeLine{03257\ \ \ \ \ \textcolor{keywordflow}{if}\ (!first\_matcher\_.MatchAndExplain(pair\_getters::First(a\_pair,\ Rank1()),}
\DoxyCodeLine{03258\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&first\_inner\_listener))\ \{}
\DoxyCodeLine{03259\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ first\ field\ does\ not\ match"{}};}
\DoxyCodeLine{03260\ \ \ \ \ \ \ PrintIfNotEmpty(first\_inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{03261\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03262\ \ \ \ \ \}}
\DoxyCodeLine{03263\ \ \ \ \ StringMatchResultListener\ second\_inner\_listener;}
\DoxyCodeLine{03264\ \ \ \ \ \textcolor{keywordflow}{if}\ (!second\_matcher\_.MatchAndExplain(pair\_getters::Second(a\_pair,\ Rank1()),}
\DoxyCodeLine{03265\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&second\_inner\_listener))\ \{}
\DoxyCodeLine{03266\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ second\ field\ does\ not\ match"{}};}
\DoxyCodeLine{03267\ \ \ \ \ \ \ PrintIfNotEmpty(second\_inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{03268\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03269\ \ \ \ \ \}}
\DoxyCodeLine{03270\ \ \ \ \ ExplainSuccess(first\_inner\_listener.str(),\ second\_inner\_listener.str(),}
\DoxyCodeLine{03271\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ listener);}
\DoxyCodeLine{03272\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03273\ \ \ \}}
\DoxyCodeLine{03274\ }
\DoxyCodeLine{03275\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03276\ \ \ \textcolor{keywordtype}{void}\ ExplainSuccess(\textcolor{keyword}{const}\ std::string\&\ first\_explanation,}
\DoxyCodeLine{03277\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ second\_explanation,}
\DoxyCodeLine{03278\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03279\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ both\ fields\ match"{}};}
\DoxyCodeLine{03280\ \ \ \ \ \textcolor{keywordflow}{if}\ (!first\_explanation.empty())\ \{}
\DoxyCodeLine{03281\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\ where\ the\ first\ field\ is\ a\ value\ "{}}\ <<\ first\_explanation;}
\DoxyCodeLine{03282\ \ \ \ \ \}}
\DoxyCodeLine{03283\ \ \ \ \ \textcolor{keywordflow}{if}\ (!second\_explanation.empty())\ \{}
\DoxyCodeLine{03284\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{03285\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!first\_explanation.empty())\ \{}
\DoxyCodeLine{03286\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}and\ "{}};}
\DoxyCodeLine{03287\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03288\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ "{}};}
\DoxyCodeLine{03289\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03290\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}the\ second\ field\ is\ a\ value\ "{}}\ <<\ second\_explanation;}
\DoxyCodeLine{03291\ \ \ \ \ \}}
\DoxyCodeLine{03292\ \ \ \}}
\DoxyCodeLine{03293\ }
\DoxyCodeLine{03294\ \ \ \textcolor{keyword}{const}\ Matcher<const\ FirstType\&>\ first\_matcher\_;}
\DoxyCodeLine{03295\ \ \ \textcolor{keyword}{const}\ Matcher<const\ SecondType\&>\ second\_matcher\_;}
\DoxyCodeLine{03296\ \};}
\DoxyCodeLine{03297\ }
\DoxyCodeLine{03298\ \textcolor{comment}{//\ Implements\ polymorphic\ Pair(first\_matcher,\ second\_matcher).}}
\DoxyCodeLine{03299\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FirstMatcher,\ \textcolor{keyword}{typename}\ SecondMatcher>}
\DoxyCodeLine{03300\ \textcolor{keyword}{class\ }PairMatcher\ \{}
\DoxyCodeLine{03301\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03302\ \ \ PairMatcher(FirstMatcher\ first\_matcher,\ SecondMatcher\ second\_matcher)}
\DoxyCodeLine{03303\ \ \ \ \ \ \ :\ first\_matcher\_(first\_matcher),\ second\_matcher\_(second\_matcher)\ \{\}}
\DoxyCodeLine{03304\ }
\DoxyCodeLine{03305\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{03306\ \ \ \textcolor{keyword}{operator}\ Matcher<PairType>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03307\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<PairType>(}
\DoxyCodeLine{03308\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ PairMatcherImpl<const\ PairType\&>(first\_matcher\_,\ second\_matcher\_));}
\DoxyCodeLine{03309\ \ \ \}}
\DoxyCodeLine{03310\ }
\DoxyCodeLine{03311\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03312\ \ \ \textcolor{keyword}{const}\ FirstMatcher\ first\_matcher\_;}
\DoxyCodeLine{03313\ \ \ \textcolor{keyword}{const}\ SecondMatcher\ second\_matcher\_;}
\DoxyCodeLine{03314\ \};}
\DoxyCodeLine{03315\ }
\DoxyCodeLine{03316\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}...\ I>}
\DoxyCodeLine{03317\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::index\_sequence<I...>,\ \textcolor{keywordtype}{int})}
\DoxyCodeLine{03318\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(std::tie(get<I>(t)...))\ \{}
\DoxyCodeLine{03319\ \ \ \textcolor{keyword}{static\_assert}(std::tuple\_size<T>::value\ ==\ \textcolor{keyword}{sizeof}...(I),}
\DoxyCodeLine{03320\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Number\ of\ arguments\ doesn't\ match\ the\ number\ of\ fields."{}});}
\DoxyCodeLine{03321\ \ \ \textcolor{keywordflow}{return}\ std::tie(get<I>(t)...);}
\DoxyCodeLine{03322\ \}}
\DoxyCodeLine{03323\ }
\DoxyCodeLine{03324\ \textcolor{preprocessor}{\#if\ defined(\_\_cpp\_structured\_bindings)\ \&\&\ \_\_cpp\_structured\_bindings\ >=\ 201606}}
\DoxyCodeLine{03325\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03326\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<1>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03327\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a]\ =\ t;}
\DoxyCodeLine{03328\ \ \ \textcolor{keywordflow}{return}\ std::tie(a);}
\DoxyCodeLine{03329\ \}}
\DoxyCodeLine{03330\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03331\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<2>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03332\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b]\ =\ t;}
\DoxyCodeLine{03333\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b);}
\DoxyCodeLine{03334\ \}}
\DoxyCodeLine{03335\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03336\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<3>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03337\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c]\ =\ t;}
\DoxyCodeLine{03338\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c);}
\DoxyCodeLine{03339\ \}}
\DoxyCodeLine{03340\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03341\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<4>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03342\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d]\ =\ t;}
\DoxyCodeLine{03343\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d);}
\DoxyCodeLine{03344\ \}}
\DoxyCodeLine{03345\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03346\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<5>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03347\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e]\ =\ t;}
\DoxyCodeLine{03348\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e);}
\DoxyCodeLine{03349\ \}}
\DoxyCodeLine{03350\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03351\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<6>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03352\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f]\ =\ t;}
\DoxyCodeLine{03353\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f);}
\DoxyCodeLine{03354\ \}}
\DoxyCodeLine{03355\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03356\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<7>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03357\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g]\ =\ t;}
\DoxyCodeLine{03358\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g);}
\DoxyCodeLine{03359\ \}}
\DoxyCodeLine{03360\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03361\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<8>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03362\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h]\ =\ t;}
\DoxyCodeLine{03363\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h);}
\DoxyCodeLine{03364\ \}}
\DoxyCodeLine{03365\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03366\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<9>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03367\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i]\ =\ t;}
\DoxyCodeLine{03368\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i);}
\DoxyCodeLine{03369\ \}}
\DoxyCodeLine{03370\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03371\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<10>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03372\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j]\ =\ t;}
\DoxyCodeLine{03373\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j);}
\DoxyCodeLine{03374\ \}}
\DoxyCodeLine{03375\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03376\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<11>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03377\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k]\ =\ t;}
\DoxyCodeLine{03378\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k);}
\DoxyCodeLine{03379\ \}}
\DoxyCodeLine{03380\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03381\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<12>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03382\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l]\ =\ t;}
\DoxyCodeLine{03383\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l);}
\DoxyCodeLine{03384\ \}}
\DoxyCodeLine{03385\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03386\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<13>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03387\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m]\ =\ t;}
\DoxyCodeLine{03388\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m);}
\DoxyCodeLine{03389\ \}}
\DoxyCodeLine{03390\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03391\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<14>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03392\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n]\ =\ t;}
\DoxyCodeLine{03393\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n);}
\DoxyCodeLine{03394\ \}}
\DoxyCodeLine{03395\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03396\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<15>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03397\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o]\ =\ t;}
\DoxyCodeLine{03398\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o);}
\DoxyCodeLine{03399\ \}}
\DoxyCodeLine{03400\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03401\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<16>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03402\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p]\ =\ t;}
\DoxyCodeLine{03403\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p);}
\DoxyCodeLine{03404\ \}}
\DoxyCodeLine{03405\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03406\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<17>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03407\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q]\ =\ t;}
\DoxyCodeLine{03408\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q);}
\DoxyCodeLine{03409\ \}}
\DoxyCodeLine{03410\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03411\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<18>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03412\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r]\ =\ t;}
\DoxyCodeLine{03413\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r);}
\DoxyCodeLine{03414\ \}}
\DoxyCodeLine{03415\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03416\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ std::make\_index\_sequence<19>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03417\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s]\ =\ t;}
\DoxyCodeLine{03418\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s);}
\DoxyCodeLine{03419\ \}}
\DoxyCodeLine{03420\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03421\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ u,\ std::make\_index\_sequence<20>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03422\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t]\ =\ u;}
\DoxyCodeLine{03423\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t);}
\DoxyCodeLine{03424\ \}}
\DoxyCodeLine{03425\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03426\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ in,\ std::make\_index\_sequence<21>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03427\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u]\ =}
\DoxyCodeLine{03428\ \ \ \ \ \ \ in;}
\DoxyCodeLine{03429\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,}
\DoxyCodeLine{03430\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ u);}
\DoxyCodeLine{03431\ \}}
\DoxyCodeLine{03432\ }
\DoxyCodeLine{03433\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03434\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ in,\ std::make\_index\_sequence<22>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03435\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,}
\DoxyCodeLine{03436\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v]\ =\ in;}
\DoxyCodeLine{03437\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,}
\DoxyCodeLine{03438\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v);}
\DoxyCodeLine{03439\ \}}
\DoxyCodeLine{03440\ }
\DoxyCodeLine{03441\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03442\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ in,\ std::make\_index\_sequence<23>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03443\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,\ v,}
\DoxyCodeLine{03444\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ w]\ =\ in;}
\DoxyCodeLine{03445\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,}
\DoxyCodeLine{03446\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ w);}
\DoxyCodeLine{03447\ \}}
\DoxyCodeLine{03448\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03449\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ in,\ std::make\_index\_sequence<24>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03450\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,\ v,}
\DoxyCodeLine{03451\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ w,\ x]\ =\ in;}
\DoxyCodeLine{03452\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,}
\DoxyCodeLine{03453\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ w,\ x);}
\DoxyCodeLine{03454\ \}}
\DoxyCodeLine{03455\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03456\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ in,\ std::make\_index\_sequence<25>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03457\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,\ v,}
\DoxyCodeLine{03458\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ w,\ x,\ y]\ =\ in;}
\DoxyCodeLine{03459\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,}
\DoxyCodeLine{03460\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ w,\ x,\ y);}
\DoxyCodeLine{03461\ \}}
\DoxyCodeLine{03462\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03463\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ in,\ std::make\_index\_sequence<26>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03464\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,\ v,}
\DoxyCodeLine{03465\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ w,\ x,\ y,\ z]\ =\ in;}
\DoxyCodeLine{03466\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p,\ q,\ r,\ s,\ t,\ u,}
\DoxyCodeLine{03467\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ w,\ x,\ y,\ z);}
\DoxyCodeLine{03468\ \}}
\DoxyCodeLine{03469\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ defined(\_\_cpp\_structured\_bindings)}}
\DoxyCodeLine{03470\ }
\DoxyCodeLine{03471\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ I,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03472\ \textcolor{keyword}{auto}\ UnpackStruct(\textcolor{keyword}{const}\ T\&\ t)}
\DoxyCodeLine{03473\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}((UnpackStructImpl)(t,\ std::make\_index\_sequence<I>\{\},\ 0))\ \{}
\DoxyCodeLine{03474\ \ \ \textcolor{keywordflow}{return}\ (UnpackStructImpl)(t,\ std::make\_index\_sequence<I>\{\},\ 0);}
\DoxyCodeLine{03475\ \}}
\DoxyCodeLine{03476\ }
\DoxyCodeLine{03477\ \textcolor{comment}{//\ Helper\ function\ to\ do\ comma\ folding\ in\ C++11.}}
\DoxyCodeLine{03478\ \textcolor{comment}{//\ The\ array\ ensures\ left-\/to-\/right\ order\ of\ evaluation.}}
\DoxyCodeLine{03479\ \textcolor{comment}{//\ Usage:\ VariadicExpand(\{expr...\});}}
\DoxyCodeLine{03480\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{03481\ \textcolor{keywordtype}{void}\ VariadicExpand(\textcolor{keyword}{const}\ T\ (\&)[N])\ \{\}}
\DoxyCodeLine{03482\ }
\DoxyCodeLine{03483\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Struct,\ \textcolor{keyword}{typename}\ StructSize>}
\DoxyCodeLine{03484\ \textcolor{keyword}{class\ }FieldsAreMatcherImpl;}
\DoxyCodeLine{03485\ }
\DoxyCodeLine{03486\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Struct,\ \textcolor{keywordtype}{size\_t}...\ I>}
\DoxyCodeLine{03487\ \textcolor{keyword}{class\ }FieldsAreMatcherImpl<Struct,\ std::index\_sequence<I...>>}
\DoxyCodeLine{03488\ \ \ \ \ :\ \textcolor{keyword}{public}\ MatcherInterface<Struct>\ \{}
\DoxyCodeLine{03489\ \ \ \textcolor{keyword}{using\ }UnpackedType\ =}
\DoxyCodeLine{03490\ \ \ \ \ \ \ \textcolor{keyword}{decltype}(UnpackStruct<\textcolor{keyword}{sizeof}...(I)>(std::declval<const\ Struct\&>()));}
\DoxyCodeLine{03491\ \ \ \textcolor{keyword}{using\ }MatchersType\ =\ std::tuple<}
\DoxyCodeLine{03492\ \ \ \ \ \ \ Matcher<const\ typename\ std::tuple\_element<I,\ UnpackedType>::type\&>...>;}
\DoxyCodeLine{03493\ }
\DoxyCodeLine{03494\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03495\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Inner>}
\DoxyCodeLine{03496\ \ \ \textcolor{keyword}{explicit}\ FieldsAreMatcherImpl(\textcolor{keyword}{const}\ Inner\&\ matchers)}
\DoxyCodeLine{03497\ \ \ \ \ \ \ :\ matchers\_(testing::SafeMatcherCast<}
\DoxyCodeLine{03498\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ typename\ std::tuple\_element<I,\ UnpackedType>::type\&>(}
\DoxyCodeLine{03499\ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(matchers))...)\ \{\}}
\DoxyCodeLine{03500\ }
\DoxyCodeLine{03501\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03502\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ separator\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{03503\ \ \ \ \ VariadicExpand(}
\DoxyCodeLine{03504\ \ \ \ \ \ \ \ \ \{(*os\ <<\ separator\ <<\ \textcolor{stringliteral}{"{}has\ field\ \#"{}}\ <<\ I\ <<\ \textcolor{stringliteral}{"{}\ that\ "{}},}
\DoxyCodeLine{03505\ \ \ \ \ \ \ \ \ \ \ std::get<I>(matchers\_).DescribeTo(os),\ separator\ =\ \textcolor{stringliteral}{"{},\ and\ "{}})...\});}
\DoxyCodeLine{03506\ \ \ \}}
\DoxyCodeLine{03507\ }
\DoxyCodeLine{03508\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03509\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ separator\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{03510\ \ \ \ \ VariadicExpand(\{(*os\ <<\ separator\ <<\ \textcolor{stringliteral}{"{}has\ field\ \#"{}}\ <<\ I\ <<\ \textcolor{stringliteral}{"{}\ that\ "{}},}
\DoxyCodeLine{03511\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(matchers\_).DescribeNegationTo(os),}
\DoxyCodeLine{03512\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ separator\ =\ \textcolor{stringliteral}{"{},\ or\ "{}})...\});}
\DoxyCodeLine{03513\ \ \ \}}
\DoxyCodeLine{03514\ }
\DoxyCodeLine{03515\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Struct\ t,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03516\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchInternal((UnpackStruct<\textcolor{keyword}{sizeof}...(I)>)(t),\ listener);}
\DoxyCodeLine{03517\ \ \ \}}
\DoxyCodeLine{03518\ }
\DoxyCodeLine{03519\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03520\ \ \ \textcolor{keywordtype}{bool}\ MatchInternal(UnpackedType\ tuple,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03521\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03522\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ don't\ need\ to\ construct\ the}}
\DoxyCodeLine{03523\ \ \ \ \ \ \ \textcolor{comment}{//\ explanation.}}
\DoxyCodeLine{03524\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ good\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03525\ \ \ \ \ \ \ VariadicExpand(\{good\ =\ good\ \&\&\ std::get<I>(matchers\_).Matches(}
\DoxyCodeLine{03526\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(tuple))...\});}
\DoxyCodeLine{03527\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ good;}
\DoxyCodeLine{03528\ \ \ \ \ \}}
\DoxyCodeLine{03529\ }
\DoxyCodeLine{03530\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ failed\_pos\ =\ \string~size\_t\{\};}
\DoxyCodeLine{03531\ }
\DoxyCodeLine{03532\ \ \ \ \ std::vector<StringMatchResultListener>\ inner\_listener(\textcolor{keyword}{sizeof}...(I));}
\DoxyCodeLine{03533\ }
\DoxyCodeLine{03534\ \ \ \ \ VariadicExpand(}
\DoxyCodeLine{03535\ \ \ \ \ \ \ \ \ \{failed\_pos\ ==\ \string~size\_t\{\}\ \&\&\ !std::get<I>(matchers\_).MatchAndExplain(}
\DoxyCodeLine{03536\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(tuple),\ \&inner\_listener[I])}
\DoxyCodeLine{03537\ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ failed\_pos\ =\ I}
\DoxyCodeLine{03538\ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ 0\ ...\});}
\DoxyCodeLine{03539\ \ \ \ \ \textcolor{keywordflow}{if}\ (failed\_pos\ !=\ \string~\textcolor{keywordtype}{size\_t}\{\})\ \{}
\DoxyCodeLine{03540\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ field\ \#"{}}\ <<\ failed\_pos\ <<\ \textcolor{stringliteral}{"{}\ does\ not\ match"{}};}
\DoxyCodeLine{03541\ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener[failed\_pos].str(),\ listener-\/>stream());}
\DoxyCodeLine{03542\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03543\ \ \ \ \ \}}
\DoxyCodeLine{03544\ }
\DoxyCodeLine{03545\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ all\ elements\ match"{}};}
\DoxyCodeLine{03546\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ separator\ =\ \textcolor{stringliteral}{"{},\ where"{}};}
\DoxyCodeLine{03547\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ index\ =\ 0;\ index\ <\ \textcolor{keyword}{sizeof}...(I);\ ++index)\ \{}
\DoxyCodeLine{03548\ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\ str\ =\ inner\_listener[index].str();}
\DoxyCodeLine{03549\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!str.empty())\ \{}
\DoxyCodeLine{03550\ \ \ \ \ \ \ \ \ *listener\ <<\ separator\ <<\ \textcolor{stringliteral}{"{}\ field\ \#"{}}\ <<\ index\ <<\ \textcolor{stringliteral}{"{}\ is\ a\ value\ "{}}\ <<\ str;}
\DoxyCodeLine{03551\ \ \ \ \ \ \ \ \ separator\ =\ \textcolor{stringliteral}{"{},\ and"{}};}
\DoxyCodeLine{03552\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03553\ \ \ \ \ \}}
\DoxyCodeLine{03554\ }
\DoxyCodeLine{03555\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03556\ \ \ \}}
\DoxyCodeLine{03557\ }
\DoxyCodeLine{03558\ \ \ MatchersType\ matchers\_;}
\DoxyCodeLine{03559\ \};}
\DoxyCodeLine{03560\ }
\DoxyCodeLine{03561\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Inner>}
\DoxyCodeLine{03562\ \textcolor{keyword}{class\ }FieldsAreMatcher\ \{}
\DoxyCodeLine{03563\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03564\ \ \ \textcolor{keyword}{explicit}\ FieldsAreMatcher(Inner...\ inner)\ :\ matchers\_(std::move(inner)...)\ \{\}}
\DoxyCodeLine{03565\ }
\DoxyCodeLine{03566\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Struct>}
\DoxyCodeLine{03567\ \ \ \textcolor{keyword}{operator}\ Matcher<Struct>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03568\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Struct>(}
\DoxyCodeLine{03569\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ FieldsAreMatcherImpl<\textcolor{keyword}{const}\ Struct\&,}
\DoxyCodeLine{03570\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::index\_sequence\_for<Inner...>>(matchers\_));}
\DoxyCodeLine{03571\ \ \ \}}
\DoxyCodeLine{03572\ }
\DoxyCodeLine{03573\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03574\ \ \ std::tuple<Inner...>\ matchers\_;}
\DoxyCodeLine{03575\ \};}
\DoxyCodeLine{03576\ }
\DoxyCodeLine{03577\ \textcolor{comment}{//\ Implements\ ElementsAre()\ and\ ElementsAreArray().}}
\DoxyCodeLine{03578\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03579\ \textcolor{keyword}{class\ }ElementsAreMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{03580\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03581\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03582\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<RawContainer>\ View;}
\DoxyCodeLine{03583\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{03584\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{03585\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ StlContainer::value\_type\ Element;}
\DoxyCodeLine{03586\ }
\DoxyCodeLine{03587\ \ \ \textcolor{comment}{//\ Constructs\ the\ matcher\ from\ a\ sequence\ of\ element\ values\ or}}
\DoxyCodeLine{03588\ \ \ \textcolor{comment}{//\ element\ matchers.}}
\DoxyCodeLine{03589\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIter>}
\DoxyCodeLine{03590\ \ \ ElementsAreMatcherImpl(InputIter\ first,\ InputIter\ last)\ \{}
\DoxyCodeLine{03591\ \ \ \ \ \textcolor{keywordflow}{while}\ (first\ !=\ last)\ \{}
\DoxyCodeLine{03592\ \ \ \ \ \ \ matchers\_.push\_back(MatcherCast<const\ Element\&>(*first++));}
\DoxyCodeLine{03593\ \ \ \ \ \}}
\DoxyCodeLine{03594\ \ \ \}}
\DoxyCodeLine{03595\ }
\DoxyCodeLine{03596\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03597\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03598\ \ \ \ \ \textcolor{keywordflow}{if}\ (count()\ ==\ 0)\ \{}
\DoxyCodeLine{03599\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ empty"{}};}
\DoxyCodeLine{03600\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (count()\ ==\ 1)\ \{}
\DoxyCodeLine{03601\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ 1\ element\ that\ "{}};}
\DoxyCodeLine{03602\ \ \ \ \ \ \ matchers\_[0].DescribeTo(os);}
\DoxyCodeLine{03603\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03604\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ "{}}\ <<\ Elements(count())\ <<\ \textcolor{stringliteral}{"{}\ where\(\backslash\)n"{}};}
\DoxyCodeLine{03605\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count();\ ++i)\ \{}
\DoxyCodeLine{03606\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}element\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{03607\ \ \ \ \ \ \ \ \ matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{03608\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ +\ 1\ <\ count())\ \{}
\DoxyCodeLine{03609\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\(\backslash\)n"{}};}
\DoxyCodeLine{03610\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03611\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03612\ \ \ \ \ \}}
\DoxyCodeLine{03613\ \ \ \}}
\DoxyCodeLine{03614\ }
\DoxyCodeLine{03615\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03616\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03617\ \ \ \ \ \textcolor{keywordflow}{if}\ (count()\ ==\ 0)\ \{}
\DoxyCodeLine{03618\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ empty"{}};}
\DoxyCodeLine{03619\ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{03620\ \ \ \ \ \}}
\DoxyCodeLine{03621\ }
\DoxyCodeLine{03622\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ have\ "{}}\ <<\ Elements(count())\ <<\ \textcolor{stringliteral}{"{},\ or\(\backslash\)n"{}};}
\DoxyCodeLine{03623\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count();\ ++i)\ \{}
\DoxyCodeLine{03624\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}element\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{03625\ \ \ \ \ \ \ matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{03626\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ +\ 1\ <\ count())\ \{}
\DoxyCodeLine{03627\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ or\(\backslash\)n"{}};}
\DoxyCodeLine{03628\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03629\ \ \ \ \ \}}
\DoxyCodeLine{03630\ \ \ \}}
\DoxyCodeLine{03631\ }
\DoxyCodeLine{03632\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{03633\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03634\ \ \ \ \ \textcolor{comment}{//\ To\ work\ with\ stream-\/like\ "{}containers"{},\ we\ must\ only\ walk}}
\DoxyCodeLine{03635\ \ \ \ \ \textcolor{comment}{//\ through\ the\ elements\ in\ one\ pass.}}
\DoxyCodeLine{03636\ }
\DoxyCodeLine{03637\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ listener\_interested\ =\ listener-\/>IsInterested();}
\DoxyCodeLine{03638\ }
\DoxyCodeLine{03639\ \ \ \ \ \textcolor{comment}{//\ explanations[i]\ is\ the\ explanation\ of\ the\ element\ at\ index\ i.}}
\DoxyCodeLine{03640\ \ \ \ \ ::std::vector<std::string>\ explanations(count());}
\DoxyCodeLine{03641\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{03642\ \ \ \ \ \textcolor{keyword}{auto}\ it\ =\ stl\_container.begin();}
\DoxyCodeLine{03643\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ exam\_pos\ =\ 0;}
\DoxyCodeLine{03644\ \ \ \ \ \textcolor{keywordtype}{bool}\ unmatched\_found\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{03645\ }
\DoxyCodeLine{03646\ \ \ \ \ \textcolor{comment}{//\ Go\ through\ the\ elements\ and\ matchers\ in\ pairs,\ until\ we\ reach}}
\DoxyCodeLine{03647\ \ \ \ \ \textcolor{comment}{//\ the\ end\ of\ either\ the\ elements\ or\ the\ matchers,\ or\ until\ we\ find\ a}}
\DoxyCodeLine{03648\ \ \ \ \ \textcolor{comment}{//\ mismatch.}}
\DoxyCodeLine{03649\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ it\ !=\ stl\_container.end()\ \&\&\ exam\_pos\ !=\ count();\ ++it,\ ++exam\_pos)\ \{}
\DoxyCodeLine{03650\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ match;\ \ \textcolor{comment}{//\ Does\ the\ current\ element\ match\ the\ current\ matcher?}}
\DoxyCodeLine{03651\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested)\ \{}
\DoxyCodeLine{03652\ \ \ \ \ \ \ \ \ StringMatchResultListener\ s;}
\DoxyCodeLine{03653\ \ \ \ \ \ \ \ \ match\ =\ matchers\_[exam\_pos].MatchAndExplain(*it,\ \&s);}
\DoxyCodeLine{03654\ \ \ \ \ \ \ \ \ explanations[exam\_pos]\ =\ s.str();}
\DoxyCodeLine{03655\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03656\ \ \ \ \ \ \ \ \ match\ =\ matchers\_[exam\_pos].Matches(*it);}
\DoxyCodeLine{03657\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03658\ }
\DoxyCodeLine{03659\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!match)\ \{}
\DoxyCodeLine{03660\ \ \ \ \ \ \ \ \ unmatched\_found\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03661\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ store\ the\ iterator\ for\ the\ unmatched\ element\ to\ be\ used}}
\DoxyCodeLine{03662\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ later,\ as\ some\ users\ use\ ElementsAre()\ with\ a\ "{}container"{}\ whose}}
\DoxyCodeLine{03663\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ iterator\ is\ not\ copy-\/constructible\ or\ copy-\/assignable.}}
\DoxyCodeLine{03664\ \ \ \ \ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{03665\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ store\ a\ pointer\ to\ the\ element\ either,\ as\ some\ container's}}
\DoxyCodeLine{03666\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ iterators\ return\ a\ temporary.}}
\DoxyCodeLine{03667\ \ \ \ \ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{03668\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ store\ the\ element\ itself\ either,\ as\ the\ element\ may\ not\ be}}
\DoxyCodeLine{03669\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ copyable.}}
\DoxyCodeLine{03670\ \ \ \ \ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{03671\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Therefore,\ we\ just\ remember\ the\ index\ of\ the\ unmatched\ element,}}
\DoxyCodeLine{03672\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\ use\ it\ later\ to\ print\ the\ unmatched\ element.}}
\DoxyCodeLine{03673\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{03674\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03675\ \ \ \ \ \}}
\DoxyCodeLine{03676\ \ \ \ \ \textcolor{comment}{//\ If\ unmatched\_found\ is\ true,\ exam\_pos\ is\ the\ index\ of\ the\ mismatch.}}
\DoxyCodeLine{03677\ }
\DoxyCodeLine{03678\ \ \ \ \ \textcolor{comment}{//\ Find\ how\ many\ elements\ the\ actual\ container\ has.\ \ We\ avoid}}
\DoxyCodeLine{03679\ \ \ \ \ \textcolor{comment}{//\ calling\ size()\ s.t.\ this\ code\ works\ for\ stream-\/like\ "{}containers"{}}}
\DoxyCodeLine{03680\ \ \ \ \ \textcolor{comment}{//\ that\ don't\ define\ size().}}
\DoxyCodeLine{03681\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ actual\_count\ =\ exam\_pos;}
\DoxyCodeLine{03682\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ it\ !=\ stl\_container.end();\ ++it)\ \{}
\DoxyCodeLine{03683\ \ \ \ \ \ \ ++actual\_count;}
\DoxyCodeLine{03684\ \ \ \ \ \}}
\DoxyCodeLine{03685\ }
\DoxyCodeLine{03686\ \ \ \ \ \textcolor{keywordflow}{if}\ (actual\_count\ !=\ count())\ \{}
\DoxyCodeLine{03687\ \ \ \ \ \ \ \textcolor{comment}{//\ The\ element\ count\ doesn't\ match.\ \ If\ the\ container\ is\ empty,}}
\DoxyCodeLine{03688\ \ \ \ \ \ \ \textcolor{comment}{//\ there's\ no\ need\ to\ explain\ anything\ as\ Google\ Mock\ already}}
\DoxyCodeLine{03689\ \ \ \ \ \ \ \textcolor{comment}{//\ prints\ the\ empty\ container.\ \ Otherwise\ we\ just\ need\ to\ show}}
\DoxyCodeLine{03690\ \ \ \ \ \ \ \textcolor{comment}{//\ how\ many\ elements\ there\ actually\ are.}}
\DoxyCodeLine{03691\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested\ \&\&\ (actual\_count\ !=\ 0))\ \{}
\DoxyCodeLine{03692\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ has\ "{}}\ <<\ Elements(actual\_count);}
\DoxyCodeLine{03693\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03694\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03695\ \ \ \ \ \}}
\DoxyCodeLine{03696\ }
\DoxyCodeLine{03697\ \ \ \ \ \textcolor{keywordflow}{if}\ (unmatched\_found)\ \{}
\DoxyCodeLine{03698\ \ \ \ \ \ \ \textcolor{comment}{//\ The\ element\ count\ matches,\ but\ the\ exam\_pos-\/th\ element\ doesn't\ match.}}
\DoxyCodeLine{03699\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested)\ \{}
\DoxyCodeLine{03700\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Find\ the\ unmatched\ element.}}
\DoxyCodeLine{03701\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ unmatched\_it\ =\ stl\_container.begin();}
\DoxyCodeLine{03702\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ call\ std::advance()\ on\ the\ iterator,\ as\ some\ users\ use}}
\DoxyCodeLine{03703\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ ElementsAre()\ with\ a\ "{}container"{}\ whose\ iterator\ is\ incompatible\ with}}
\DoxyCodeLine{03704\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ std::advance()\ (e.g.\ it\ may\ not\ have\ the\ difference\_type\ member}}
\DoxyCodeLine{03705\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ type).}}
\DoxyCodeLine{03706\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ exam\_pos;\ ++i)\ \{}
\DoxyCodeLine{03707\ \ \ \ \ \ \ \ \ \ \ ++unmatched\_it;}
\DoxyCodeLine{03708\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03709\ }
\DoxyCodeLine{03710\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ array\ is\ long\ or\ the\ elements'\ print-\/out\ is\ large,\ it\ may\ be}}
\DoxyCodeLine{03711\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ hard\ for\ the\ user\ to\ find\ the\ mismatched\ element\ and\ its}}
\DoxyCodeLine{03712\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ corresponding\ matcher\ description.\ Therefore\ we\ print\ the\ index,\ the}}
\DoxyCodeLine{03713\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ value\ of\ the\ mismatched\ element,\ and\ the\ corresponding\ matcher}}
\DoxyCodeLine{03714\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ description\ to\ ease\ debugging.}}
\DoxyCodeLine{03715\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ exam\_pos\ <<\ \textcolor{stringliteral}{"{}\ ("{}}}
\DoxyCodeLine{03716\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ PrintToString(*unmatched\_it)\ <<\ \textcolor{stringliteral}{"{})\ "{}};}
\DoxyCodeLine{03717\ \ \ \ \ \ \ \ \ matchers\_[exam\_pos].DescribeNegationTo(listener-\/>stream());}
\DoxyCodeLine{03718\ \ \ \ \ \ \ \ \ PrintIfNotEmpty(explanations[exam\_pos],\ listener-\/>stream());}
\DoxyCodeLine{03719\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03720\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03721\ \ \ \ \ \}}
\DoxyCodeLine{03722\ }
\DoxyCodeLine{03723\ \ \ \ \ \textcolor{comment}{//\ Every\ element\ matches\ its\ expectation.\ \ We\ need\ to\ explain\ why}}
\DoxyCodeLine{03724\ \ \ \ \ \textcolor{comment}{//\ (the\ obvious\ ones\ can\ be\ skipped).}}
\DoxyCodeLine{03725\ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested)\ \{}
\DoxyCodeLine{03726\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ reason\_printed\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{03727\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count();\ ++i)\ \{}
\DoxyCodeLine{03728\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ s\ =\ explanations[i];}
\DoxyCodeLine{03729\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!s.empty())\ \{}
\DoxyCodeLine{03730\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (reason\_printed)\ \{}
\DoxyCodeLine{03731\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\(\backslash\)nand\ "{}};}
\DoxyCodeLine{03732\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03733\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ matches,\ "{}}\ <<\ s;}
\DoxyCodeLine{03734\ \ \ \ \ \ \ \ \ \ \ reason\_printed\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03735\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03736\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03737\ \ \ \ \ \}}
\DoxyCodeLine{03738\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03739\ \ \ \}}
\DoxyCodeLine{03740\ }
\DoxyCodeLine{03741\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03742\ \ \ \textcolor{keyword}{static}\ Message\ Elements(\textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{03743\ \ \ \ \ \textcolor{keywordflow}{return}\ Message()\ <<\ count\ <<\ (count\ ==\ 1\ ?\ \textcolor{stringliteral}{"{}\ element"{}}\ :\ \textcolor{stringliteral}{"{}\ elements"{}});}
\DoxyCodeLine{03744\ \ \ \}}
\DoxyCodeLine{03745\ }
\DoxyCodeLine{03746\ \ \ \textcolor{keywordtype}{size\_t}\ count()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ matchers\_.size();\ \}}
\DoxyCodeLine{03747\ }
\DoxyCodeLine{03748\ \ \ ::std::vector<Matcher<const\ Element\&>>\ matchers\_;}
\DoxyCodeLine{03749\ \};}
\DoxyCodeLine{03750\ }
\DoxyCodeLine{03751\ \textcolor{comment}{//\ Connectivity\ matrix\ of\ (elements\ X\ matchers),\ in\ element-\/major\ order.}}
\DoxyCodeLine{03752\ \textcolor{comment}{//\ Initially,\ there\ are\ no\ edges.}}
\DoxyCodeLine{03753\ \textcolor{comment}{//\ Use\ NextGraph()\ to\ iterate\ over\ all\ possible\ edge\ configurations.}}
\DoxyCodeLine{03754\ \textcolor{comment}{//\ Use\ Randomize()\ to\ generate\ a\ random\ edge\ configuration.}}
\DoxyCodeLine{03755\ \textcolor{keyword}{class\ }GTEST\_API\_\ MatchMatrix\ \{}
\DoxyCodeLine{03756\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03757\ \ \ MatchMatrix(\textcolor{keywordtype}{size\_t}\ num\_elements,\ \textcolor{keywordtype}{size\_t}\ num\_matchers)}
\DoxyCodeLine{03758\ \ \ \ \ \ \ :\ num\_elements\_(num\_elements),}
\DoxyCodeLine{03759\ \ \ \ \ \ \ \ \ num\_matchers\_(num\_matchers),}
\DoxyCodeLine{03760\ \ \ \ \ \ \ \ \ matched\_(num\_elements\_\ *\ num\_matchers\_,\ 0)\ \{\}}
\DoxyCodeLine{03761\ }
\DoxyCodeLine{03762\ \ \ \textcolor{keywordtype}{size\_t}\ LhsSize()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ num\_elements\_;\ \}}
\DoxyCodeLine{03763\ \ \ \textcolor{keywordtype}{size\_t}\ RhsSize()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ num\_matchers\_;\ \}}
\DoxyCodeLine{03764\ \ \ \textcolor{keywordtype}{bool}\ HasEdge(\textcolor{keywordtype}{size\_t}\ ilhs,\ \textcolor{keywordtype}{size\_t}\ irhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03765\ \ \ \ \ \textcolor{keywordflow}{return}\ matched\_[SpaceIndex(ilhs,\ irhs)]\ ==\ 1;}
\DoxyCodeLine{03766\ \ \ \}}
\DoxyCodeLine{03767\ \ \ \textcolor{keywordtype}{void}\ SetEdge(\textcolor{keywordtype}{size\_t}\ ilhs,\ \textcolor{keywordtype}{size\_t}\ irhs,\ \textcolor{keywordtype}{bool}\ b)\ \{}
\DoxyCodeLine{03768\ \ \ \ \ matched\_[SpaceIndex(ilhs,\ irhs)]\ =\ b\ ?\ 1\ :\ 0;}
\DoxyCodeLine{03769\ \ \ \}}
\DoxyCodeLine{03770\ }
\DoxyCodeLine{03771\ \ \ \textcolor{comment}{//\ Treating\ the\ connectivity\ matrix\ as\ a\ (LhsSize()*RhsSize())-\/bit\ number,}}
\DoxyCodeLine{03772\ \ \ \textcolor{comment}{//\ adds\ 1\ to\ that\ number;\ returns\ false\ if\ incrementing\ the\ graph\ left\ it}}
\DoxyCodeLine{03773\ \ \ \textcolor{comment}{//\ empty.}}
\DoxyCodeLine{03774\ \ \ \textcolor{keywordtype}{bool}\ NextGraph();}
\DoxyCodeLine{03775\ }
\DoxyCodeLine{03776\ \ \ \textcolor{keywordtype}{void}\ Randomize();}
\DoxyCodeLine{03777\ }
\DoxyCodeLine{03778\ \ \ std::string\ DebugString()\ \textcolor{keyword}{const};}
\DoxyCodeLine{03779\ }
\DoxyCodeLine{03780\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03781\ \ \ \textcolor{keywordtype}{size\_t}\ SpaceIndex(\textcolor{keywordtype}{size\_t}\ ilhs,\ \textcolor{keywordtype}{size\_t}\ irhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03782\ \ \ \ \ \textcolor{keywordflow}{return}\ ilhs\ *\ num\_matchers\_\ +\ irhs;}
\DoxyCodeLine{03783\ \ \ \}}
\DoxyCodeLine{03784\ }
\DoxyCodeLine{03785\ \ \ \textcolor{keywordtype}{size\_t}\ num\_elements\_;}
\DoxyCodeLine{03786\ \ \ \textcolor{keywordtype}{size\_t}\ num\_matchers\_;}
\DoxyCodeLine{03787\ }
\DoxyCodeLine{03788\ \ \ \textcolor{comment}{//\ Each\ element\ is\ a\ char\ interpreted\ as\ bool.\ They\ are\ stored\ as\ a}}
\DoxyCodeLine{03789\ \ \ \textcolor{comment}{//\ flattened\ array\ in\ lhs-\/major\ order,\ use\ 'SpaceIndex()'\ to\ translate}}
\DoxyCodeLine{03790\ \ \ \textcolor{comment}{//\ a\ (ilhs,\ irhs)\ matrix\ coordinate\ into\ an\ offset.}}
\DoxyCodeLine{03791\ \ \ ::std::vector<char>\ matched\_;}
\DoxyCodeLine{03792\ \};}
\DoxyCodeLine{03793\ }
\DoxyCodeLine{03794\ typedef\ ::std::pair<size\_t,\ size\_t>\ ElementMatcherPair;}
\DoxyCodeLine{03795\ typedef\ ::std::vector<ElementMatcherPair>\ ElementMatcherPairs;}
\DoxyCodeLine{03796\ }
\DoxyCodeLine{03797\ \textcolor{comment}{//\ Returns\ a\ maximum\ bipartite\ matching\ for\ the\ specified\ graph\ 'g'.}}
\DoxyCodeLine{03798\ \textcolor{comment}{//\ The\ matching\ is\ represented\ as\ a\ vector\ of\ \{element,\ matcher\}\ pairs.}}
\DoxyCodeLine{03799\ GTEST\_API\_\ ElementMatcherPairs\ FindMaxBipartiteMatching(\textcolor{keyword}{const}\ MatchMatrix\&\ g);}
\DoxyCodeLine{03800\ }
\DoxyCodeLine{03801\ \textcolor{keyword}{struct\ }UnorderedMatcherRequire\ \{}
\DoxyCodeLine{03802\ \ \ \textcolor{keyword}{enum}\ Flags\ \{}
\DoxyCodeLine{03803\ \ \ \ \ Superset\ =\ 1\ <<\ 0,}
\DoxyCodeLine{03804\ \ \ \ \ Subset\ =\ 1\ <<\ 1,}
\DoxyCodeLine{03805\ \ \ \ \ ExactMatch\ =\ Superset\ |\ Subset,}
\DoxyCodeLine{03806\ \ \ \};}
\DoxyCodeLine{03807\ \};}
\DoxyCodeLine{03808\ }
\DoxyCodeLine{03809\ \textcolor{comment}{//\ Untyped\ base\ class\ for\ implementing\ UnorderedElementsAre.\ \ By}}
\DoxyCodeLine{03810\ \textcolor{comment}{//\ putting\ logic\ that's\ not\ specific\ to\ the\ element\ type\ here,\ we}}
\DoxyCodeLine{03811\ \textcolor{comment}{//\ reduce\ binary\ bloat\ and\ increase\ compilation\ speed.}}
\DoxyCodeLine{03812\ \textcolor{keyword}{class\ }GTEST\_API\_\ UnorderedElementsAreMatcherImplBase\ \{}
\DoxyCodeLine{03813\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{03814\ \ \ \textcolor{keyword}{explicit}\ UnorderedElementsAreMatcherImplBase(}
\DoxyCodeLine{03815\ \ \ \ \ \ \ UnorderedMatcherRequire::Flags\ matcher\_flags)}
\DoxyCodeLine{03816\ \ \ \ \ \ \ :\ match\_flags\_(matcher\_flags)\ \{\}}
\DoxyCodeLine{03817\ }
\DoxyCodeLine{03818\ \ \ \textcolor{comment}{//\ A\ vector\ of\ matcher\ describers,\ one\ for\ each\ element\ matcher.}}
\DoxyCodeLine{03819\ \ \ \textcolor{comment}{//\ Does\ not\ own\ the\ describers\ (and\ thus\ can\ be\ used\ only\ when\ the}}
\DoxyCodeLine{03820\ \ \ \textcolor{comment}{//\ element\ matchers\ are\ alive).}}
\DoxyCodeLine{03821\ \ \ typedef\ ::std::vector<const\ MatcherDescriberInterface*>\ MatcherDescriberVec;}
\DoxyCodeLine{03822\ }
\DoxyCodeLine{03823\ \ \ \textcolor{comment}{//\ Describes\ this\ UnorderedElementsAre\ matcher.}}
\DoxyCodeLine{03824\ \ \ \textcolor{keywordtype}{void}\ DescribeToImpl(::std::ostream*\ os)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03825\ }
\DoxyCodeLine{03826\ \ \ \textcolor{comment}{//\ Describes\ the\ negation\ of\ this\ UnorderedElementsAre\ matcher.}}
\DoxyCodeLine{03827\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationToImpl(::std::ostream*\ os)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03828\ }
\DoxyCodeLine{03829\ \ \ \textcolor{keywordtype}{bool}\ VerifyMatchMatrix(const\ ::std::vector<std::string>\&\ element\_printouts,}
\DoxyCodeLine{03830\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ MatchMatrix\&\ matrix,}
\DoxyCodeLine{03831\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03832\ }
\DoxyCodeLine{03833\ \ \ \textcolor{keywordtype}{bool}\ FindPairing(\textcolor{keyword}{const}\ MatchMatrix\&\ matrix,}
\DoxyCodeLine{03834\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03835\ }
\DoxyCodeLine{03836\ \ \ MatcherDescriberVec\&\ matcher\_describers()\ \{\ \textcolor{keywordflow}{return}\ matcher\_describers\_;\ \}}
\DoxyCodeLine{03837\ }
\DoxyCodeLine{03838\ \ \ \textcolor{keyword}{static}\ Message\ Elements(\textcolor{keywordtype}{size\_t}\ n)\ \{}
\DoxyCodeLine{03839\ \ \ \ \ \textcolor{keywordflow}{return}\ Message()\ <<\ n\ <<\ \textcolor{stringliteral}{"{}\ element"{}}\ <<\ (n\ ==\ 1\ ?\ \textcolor{stringliteral}{"{}"{}}\ :\ \textcolor{stringliteral}{"{}s"{}});}
\DoxyCodeLine{03840\ \ \ \}}
\DoxyCodeLine{03841\ }
\DoxyCodeLine{03842\ \ \ UnorderedMatcherRequire::Flags\ match\_flags()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ match\_flags\_;\ \}}
\DoxyCodeLine{03843\ }
\DoxyCodeLine{03844\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03845\ \ \ UnorderedMatcherRequire::Flags\ match\_flags\_;}
\DoxyCodeLine{03846\ \ \ MatcherDescriberVec\ matcher\_describers\_;}
\DoxyCodeLine{03847\ \};}
\DoxyCodeLine{03848\ }
\DoxyCodeLine{03849\ \textcolor{comment}{//\ Implements\ UnorderedElementsAre,\ UnorderedElementsAreArray,\ IsSubsetOf,\ and}}
\DoxyCodeLine{03850\ \textcolor{comment}{//\ IsSupersetOf.}}
\DoxyCodeLine{03851\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03852\ \textcolor{keyword}{class\ }UnorderedElementsAreMatcherImpl}
\DoxyCodeLine{03853\ \ \ \ \ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>,}
\DoxyCodeLine{03854\ \ \ \ \ \ \ \textcolor{keyword}{public}\ UnorderedElementsAreMatcherImplBase\ \{}
\DoxyCodeLine{03855\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03856\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03857\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<RawContainer>\ View;}
\DoxyCodeLine{03858\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{03859\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{03860\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ StlContainer::value\_type\ Element;}
\DoxyCodeLine{03861\ }
\DoxyCodeLine{03862\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIter>}
\DoxyCodeLine{03863\ \ \ UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags\ matcher\_flags,}
\DoxyCodeLine{03864\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIter\ first,\ InputIter\ last)}
\DoxyCodeLine{03865\ \ \ \ \ \ \ :\ UnorderedElementsAreMatcherImplBase(matcher\_flags)\ \{}
\DoxyCodeLine{03866\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{03867\ \ \ \ \ \ \ matchers\_.push\_back(MatcherCast<const\ Element\&>(*first));}
\DoxyCodeLine{03868\ \ \ \ \ \}}
\DoxyCodeLine{03869\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ m\ :\ matchers\_)\ \{}
\DoxyCodeLine{03870\ \ \ \ \ \ \ matcher\_describers().push\_back(m.GetDescriber());}
\DoxyCodeLine{03871\ \ \ \ \ \}}
\DoxyCodeLine{03872\ \ \ \}}
\DoxyCodeLine{03873\ }
\DoxyCodeLine{03874\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03875\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03876\ \ \ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);}
\DoxyCodeLine{03877\ \ \ \}}
\DoxyCodeLine{03878\ }
\DoxyCodeLine{03879\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03880\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03881\ \ \ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);}
\DoxyCodeLine{03882\ \ \ \}}
\DoxyCodeLine{03883\ }
\DoxyCodeLine{03884\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{03885\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03886\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{03887\ \ \ \ \ ::std::vector<std::string>\ element\_printouts;}
\DoxyCodeLine{03888\ \ \ \ \ MatchMatrix\ matrix\ =}
\DoxyCodeLine{03889\ \ \ \ \ \ \ \ \ AnalyzeElements(stl\_container.begin(),\ stl\_container.end(),}
\DoxyCodeLine{03890\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&element\_printouts,\ listener);}
\DoxyCodeLine{03891\ }
\DoxyCodeLine{03892\ \ \ \ \ \textcolor{keywordflow}{return}\ VerifyMatchMatrix(element\_printouts,\ matrix,\ listener)\ \&\&}
\DoxyCodeLine{03893\ \ \ \ \ \ \ \ \ \ \ \ FindPairing(matrix,\ listener);}
\DoxyCodeLine{03894\ \ \ \}}
\DoxyCodeLine{03895\ }
\DoxyCodeLine{03896\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03897\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ElementIter>}
\DoxyCodeLine{03898\ \ \ MatchMatrix\ AnalyzeElements(ElementIter\ elem\_first,\ ElementIter\ elem\_last,}
\DoxyCodeLine{03899\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::vector<std::string>*\ element\_printouts,}
\DoxyCodeLine{03900\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03901\ \ \ \ \ element\_printouts-\/>clear();}
\DoxyCodeLine{03902\ \ \ \ \ ::std::vector<char>\ did\_match;}
\DoxyCodeLine{03903\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ num\_elements\ =\ 0;}
\DoxyCodeLine{03904\ \ \ \ \ DummyMatchResultListener\ dummy;}
\DoxyCodeLine{03905\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ elem\_first\ !=\ elem\_last;\ ++num\_elements,\ ++elem\_first)\ \{}
\DoxyCodeLine{03906\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03907\ \ \ \ \ \ \ \ \ element\_printouts-\/>push\_back(PrintToString(*elem\_first));}
\DoxyCodeLine{03908\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03909\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ irhs\ =\ 0;\ irhs\ !=\ matchers\_.size();\ ++irhs)\ \{}
\DoxyCodeLine{03910\ \ \ \ \ \ \ \ \ did\_match.push\_back(}
\DoxyCodeLine{03911\ \ \ \ \ \ \ \ \ \ \ \ \ matchers\_[irhs].MatchAndExplain(*elem\_first,\ \&dummy));}
\DoxyCodeLine{03912\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03913\ \ \ \ \ \}}
\DoxyCodeLine{03914\ }
\DoxyCodeLine{03915\ \ \ \ \ MatchMatrix\ matrix(num\_elements,\ matchers\_.size());}
\DoxyCodeLine{03916\ \ \ \ \ ::std::vector<char>::const\_iterator\ did\_match\_iter\ =\ did\_match.begin();}
\DoxyCodeLine{03917\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ ilhs\ =\ 0;\ ilhs\ !=\ num\_elements;\ ++ilhs)\ \{}
\DoxyCodeLine{03918\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ irhs\ =\ 0;\ irhs\ !=\ matchers\_.size();\ ++irhs)\ \{}
\DoxyCodeLine{03919\ \ \ \ \ \ \ \ \ matrix.SetEdge(ilhs,\ irhs,\ *did\_match\_iter++\ !=\ 0);}
\DoxyCodeLine{03920\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03921\ \ \ \ \ \}}
\DoxyCodeLine{03922\ \ \ \ \ \textcolor{keywordflow}{return}\ matrix;}
\DoxyCodeLine{03923\ \ \ \}}
\DoxyCodeLine{03924\ }
\DoxyCodeLine{03925\ \ \ ::std::vector<Matcher<const\ Element\&>>\ matchers\_;}
\DoxyCodeLine{03926\ \};}
\DoxyCodeLine{03927\ }
\DoxyCodeLine{03928\ \textcolor{comment}{//\ Functor\ for\ use\ in\ TransformTuple.}}
\DoxyCodeLine{03929\ \textcolor{comment}{//\ Performs\ MatcherCast<Target>\ on\ an\ input\ argument\ of\ any\ type.}}
\DoxyCodeLine{03930\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Target>}
\DoxyCodeLine{03931\ \textcolor{keyword}{struct\ }CastAndAppendTransform\ \{}
\DoxyCodeLine{03932\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Arg>}
\DoxyCodeLine{03933\ \ \ Matcher<Target>\ operator()(\textcolor{keyword}{const}\ Arg\&\ a)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03934\ \ \ \ \ \textcolor{keywordflow}{return}\ MatcherCast<Target>(a);}
\DoxyCodeLine{03935\ \ \ \}}
\DoxyCodeLine{03936\ \};}
\DoxyCodeLine{03937\ }
\DoxyCodeLine{03938\ \textcolor{comment}{//\ Implements\ UnorderedElementsAre.}}
\DoxyCodeLine{03939\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple>}
\DoxyCodeLine{03940\ \textcolor{keyword}{class\ }UnorderedElementsAreMatcher\ \{}
\DoxyCodeLine{03941\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03942\ \ \ \textcolor{keyword}{explicit}\ UnorderedElementsAreMatcher(\textcolor{keyword}{const}\ MatcherTuple\&\ args)}
\DoxyCodeLine{03943\ \ \ \ \ \ \ :\ matchers\_(args)\ \{\}}
\DoxyCodeLine{03944\ }
\DoxyCodeLine{03945\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03946\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03947\ \ \ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03948\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ internal::StlContainerView<RawContainer>::type\ View;}
\DoxyCodeLine{03949\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::value\_type\ Element;}
\DoxyCodeLine{03950\ \ \ \ \ typedef\ ::std::vector<Matcher<const\ Element\&>>\ MatcherVec;}
\DoxyCodeLine{03951\ \ \ \ \ MatcherVec\ matchers;}
\DoxyCodeLine{03952\ \ \ \ \ matchers.reserve(::std::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{03953\ \ \ \ \ TransformTupleValues(CastAndAppendTransform<const\ Element\&>(),\ matchers\_,}
\DoxyCodeLine{03954\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::back\_inserter(matchers));}
\DoxyCodeLine{03955\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{03956\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ UnorderedElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{03957\ \ \ \ \ \ \ \ \ \ \ \ \ UnorderedMatcherRequire::ExactMatch,\ matchers.begin(),}
\DoxyCodeLine{03958\ \ \ \ \ \ \ \ \ \ \ \ \ matchers.end()));}
\DoxyCodeLine{03959\ \ \ \}}
\DoxyCodeLine{03960\ }
\DoxyCodeLine{03961\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03962\ \ \ \textcolor{keyword}{const}\ MatcherTuple\ matchers\_;}
\DoxyCodeLine{03963\ \};}
\DoxyCodeLine{03964\ }
\DoxyCodeLine{03965\ \textcolor{comment}{//\ Implements\ ElementsAre.}}
\DoxyCodeLine{03966\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple>}
\DoxyCodeLine{03967\ \textcolor{keyword}{class\ }ElementsAreMatcher\ \{}
\DoxyCodeLine{03968\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03969\ \ \ \textcolor{keyword}{explicit}\ ElementsAreMatcher(\textcolor{keyword}{const}\ MatcherTuple\&\ args)\ :\ matchers\_(args)\ \{\}}
\DoxyCodeLine{03970\ }
\DoxyCodeLine{03971\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03972\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03973\ \ \ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{03974\ \ \ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>::value\ ||}
\DoxyCodeLine{03975\ \ \ \ \ \ \ \ \ \ \ \ \ ::std::tuple\_size<MatcherTuple>::value\ <\ 2,}
\DoxyCodeLine{03976\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}use\ UnorderedElementsAre\ with\ hash\ tables"{}});}
\DoxyCodeLine{03977\ }
\DoxyCodeLine{03978\ \ \ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03979\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ internal::StlContainerView<RawContainer>::type\ View;}
\DoxyCodeLine{03980\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::value\_type\ Element;}
\DoxyCodeLine{03981\ \ \ \ \ typedef\ ::std::vector<Matcher<const\ Element\&>>\ MatcherVec;}
\DoxyCodeLine{03982\ \ \ \ \ MatcherVec\ matchers;}
\DoxyCodeLine{03983\ \ \ \ \ matchers.reserve(::std::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{03984\ \ \ \ \ TransformTupleValues(CastAndAppendTransform<const\ Element\&>(),\ matchers\_,}
\DoxyCodeLine{03985\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::back\_inserter(matchers));}
\DoxyCodeLine{03986\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ ElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{03987\ \ \ \ \ \ \ \ \ matchers.begin(),\ matchers.end()));}
\DoxyCodeLine{03988\ \ \ \}}
\DoxyCodeLine{03989\ }
\DoxyCodeLine{03990\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03991\ \ \ \textcolor{keyword}{const}\ MatcherTuple\ matchers\_;}
\DoxyCodeLine{03992\ \};}
\DoxyCodeLine{03993\ }
\DoxyCodeLine{03994\ \textcolor{comment}{//\ Implements\ UnorderedElementsAreArray(),\ IsSubsetOf(),\ and\ IsSupersetOf().}}
\DoxyCodeLine{03995\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03996\ \textcolor{keyword}{class\ }UnorderedElementsAreArrayMatcher\ \{}
\DoxyCodeLine{03997\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03998\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{03999\ \ \ UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags\ match\_flags,}
\DoxyCodeLine{04000\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Iter\ first,\ Iter\ last)}
\DoxyCodeLine{04001\ \ \ \ \ \ \ :\ match\_flags\_(match\_flags),\ matchers\_(first,\ last)\ \{\}}
\DoxyCodeLine{04002\ }
\DoxyCodeLine{04003\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04004\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04005\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{04006\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ UnorderedElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{04007\ \ \ \ \ \ \ \ \ \ \ \ \ match\_flags\_,\ matchers\_.begin(),\ matchers\_.end()));}
\DoxyCodeLine{04008\ \ \ \}}
\DoxyCodeLine{04009\ }
\DoxyCodeLine{04010\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04011\ \ \ UnorderedMatcherRequire::Flags\ match\_flags\_;}
\DoxyCodeLine{04012\ \ \ std::vector<std::remove\_const\_t<T>>\ matchers\_;}
\DoxyCodeLine{04013\ \};}
\DoxyCodeLine{04014\ }
\DoxyCodeLine{04015\ \textcolor{comment}{//\ Implements\ ElementsAreArray().}}
\DoxyCodeLine{04016\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04017\ \textcolor{keyword}{class\ }ElementsAreArrayMatcher\ \{}
\DoxyCodeLine{04018\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04019\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04020\ \ \ ElementsAreArrayMatcher(Iter\ first,\ Iter\ last)\ :\ matchers\_(first,\ last)\ \{\}}
\DoxyCodeLine{04021\ }
\DoxyCodeLine{04022\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04023\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04024\ \ \ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{04025\ \ \ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>::value,}
\DoxyCodeLine{04026\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}use\ UnorderedElementsAreArray\ with\ hash\ tables"{}});}
\DoxyCodeLine{04027\ }
\DoxyCodeLine{04028\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ ElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{04029\ \ \ \ \ \ \ \ \ matchers\_.begin(),\ matchers\_.end()));}
\DoxyCodeLine{04030\ \ \ \}}
\DoxyCodeLine{04031\ }
\DoxyCodeLine{04032\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04033\ \ \ \textcolor{keyword}{const}\ std::vector<std::remove\_const\_t<T>>\ matchers\_;}
\DoxyCodeLine{04034\ \};}
\DoxyCodeLine{04035\ }
\DoxyCodeLine{04036\ \textcolor{comment}{//\ Given\ a\ 2-\/tuple\ matcher\ tm\ of\ type\ Tuple2Matcher\ and\ a\ value\ second}}
\DoxyCodeLine{04037\ \textcolor{comment}{//\ of\ type\ Second,\ BoundSecondMatcher<Tuple2Matcher,\ Second>(tm,}}
\DoxyCodeLine{04038\ \textcolor{comment}{//\ second)\ is\ a\ polymorphic\ matcher\ that\ matches\ a\ value\ x\ if\ and\ only\ if}}
\DoxyCodeLine{04039\ \textcolor{comment}{//\ tm\ matches\ tuple\ (x,\ second).\ \ Useful\ for\ implementing}}
\DoxyCodeLine{04040\ \textcolor{comment}{//\ UnorderedPointwise()\ in\ terms\ of\ UnorderedElementsAreArray().}}
\DoxyCodeLine{04041\ \textcolor{comment}{//}}
\DoxyCodeLine{04042\ \textcolor{comment}{//\ BoundSecondMatcher\ is\ copyable\ and\ assignable,\ as\ we\ need\ to\ put}}
\DoxyCodeLine{04043\ \textcolor{comment}{//\ instances\ of\ this\ class\ in\ a\ vector\ when\ implementing}}
\DoxyCodeLine{04044\ \textcolor{comment}{//\ UnorderedPointwise().}}
\DoxyCodeLine{04045\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ Second>}
\DoxyCodeLine{04046\ \textcolor{keyword}{class\ }BoundSecondMatcher\ \{}
\DoxyCodeLine{04047\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04048\ \ \ BoundSecondMatcher(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tm,\ \textcolor{keyword}{const}\ Second\&\ second)}
\DoxyCodeLine{04049\ \ \ \ \ \ \ :\ tuple2\_matcher\_(tm),\ second\_value\_(second)\ \{\}}
\DoxyCodeLine{04050\ }
\DoxyCodeLine{04051\ \ \ BoundSecondMatcher(\textcolor{keyword}{const}\ BoundSecondMatcher\&\ other)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{04052\ }
\DoxyCodeLine{04053\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04054\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04055\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<T>(tuple2\_matcher\_,\ second\_value\_));}
\DoxyCodeLine{04056\ \ \ \}}
\DoxyCodeLine{04057\ }
\DoxyCodeLine{04058\ \ \ \textcolor{comment}{//\ We\ have\ to\ define\ this\ for\ UnorderedPointwise()\ to\ compile\ in}}
\DoxyCodeLine{04059\ \ \ \textcolor{comment}{//\ C++98\ mode,\ as\ it\ puts\ BoundSecondMatcher\ instances\ in\ a\ vector,}}
\DoxyCodeLine{04060\ \ \ \textcolor{comment}{//\ which\ requires\ the\ elements\ to\ be\ assignable\ in\ C++98.\ \ The}}
\DoxyCodeLine{04061\ \ \ \textcolor{comment}{//\ compiler\ cannot\ generate\ the\ operator=\ for\ us,\ as\ Tuple2Matcher}}
\DoxyCodeLine{04062\ \ \ \textcolor{comment}{//\ and\ Second\ may\ not\ be\ assignable.}}
\DoxyCodeLine{04063\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{04064\ \ \ \textcolor{comment}{//\ However,\ this\ should\ never\ be\ called,\ so\ the\ implementation\ just}}
\DoxyCodeLine{04065\ \ \ \textcolor{comment}{//\ need\ to\ assert.}}
\DoxyCodeLine{04066\ \ \ \textcolor{keywordtype}{void}\ operator=(\textcolor{keyword}{const}\ BoundSecondMatcher\&\ \textcolor{comment}{/*rhs*/})\ \{}
\DoxyCodeLine{04067\ \ \ \ \ GTEST\_LOG\_(FATAL)\ <<\ \textcolor{stringliteral}{"{}BoundSecondMatcher\ should\ never\ be\ assigned."{}};}
\DoxyCodeLine{04068\ \ \ \}}
\DoxyCodeLine{04069\ }
\DoxyCodeLine{04070\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04071\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04072\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{04073\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04074\ \ \ \ \ typedef\ ::std::tuple<T,\ Second>\ ArgTuple;}
\DoxyCodeLine{04075\ }
\DoxyCodeLine{04076\ \ \ \ \ Impl(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tm,\ \textcolor{keyword}{const}\ Second\&\ second)}
\DoxyCodeLine{04077\ \ \ \ \ \ \ \ \ :\ mono\_tuple2\_matcher\_(SafeMatcherCast<const\ ArgTuple\&>(tm)),}
\DoxyCodeLine{04078\ \ \ \ \ \ \ \ \ \ \ second\_value\_(second)\ \{\}}
\DoxyCodeLine{04079\ }
\DoxyCodeLine{04080\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04081\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}and\ "{}};}
\DoxyCodeLine{04082\ \ \ \ \ \ \ UniversalPrint(second\_value\_,\ os);}
\DoxyCodeLine{04083\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{04084\ \ \ \ \ \ \ mono\_tuple2\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{04085\ \ \ \ \ \}}
\DoxyCodeLine{04086\ }
\DoxyCodeLine{04087\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04088\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ mono\_tuple2\_matcher\_.MatchAndExplain(ArgTuple(x,\ second\_value\_),}
\DoxyCodeLine{04089\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ listener);}
\DoxyCodeLine{04090\ \ \ \ \ \}}
\DoxyCodeLine{04091\ }
\DoxyCodeLine{04092\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04093\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ ArgTuple\&>\ mono\_tuple2\_matcher\_;}
\DoxyCodeLine{04094\ \ \ \ \ \textcolor{keyword}{const}\ Second\ second\_value\_;}
\DoxyCodeLine{04095\ \ \ \};}
\DoxyCodeLine{04096\ }
\DoxyCodeLine{04097\ \ \ \textcolor{keyword}{const}\ Tuple2Matcher\ tuple2\_matcher\_;}
\DoxyCodeLine{04098\ \ \ \textcolor{keyword}{const}\ Second\ second\_value\_;}
\DoxyCodeLine{04099\ \};}
\DoxyCodeLine{04100\ }
\DoxyCodeLine{04101\ \textcolor{comment}{//\ Given\ a\ 2-\/tuple\ matcher\ tm\ and\ a\ value\ second,}}
\DoxyCodeLine{04102\ \textcolor{comment}{//\ MatcherBindSecond(tm,\ second)\ returns\ a\ matcher\ that\ matches\ a}}
\DoxyCodeLine{04103\ \textcolor{comment}{//\ value\ x\ if\ and\ only\ if\ tm\ matches\ tuple\ (x,\ second).\ \ Useful\ for}}
\DoxyCodeLine{04104\ \textcolor{comment}{//\ implementing\ UnorderedPointwise()\ in\ terms\ of\ UnorderedElementsAreArray().}}
\DoxyCodeLine{04105\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ Second>}
\DoxyCodeLine{04106\ BoundSecondMatcher<Tuple2Matcher,\ Second>\ MatcherBindSecond(}
\DoxyCodeLine{04107\ \ \ \ \ \textcolor{keyword}{const}\ Tuple2Matcher\&\ tm,\ \textcolor{keyword}{const}\ Second\&\ second)\ \{}
\DoxyCodeLine{04108\ \ \ \textcolor{keywordflow}{return}\ BoundSecondMatcher<Tuple2Matcher,\ Second>(tm,\ second);}
\DoxyCodeLine{04109\ \}}
\DoxyCodeLine{04110\ }
\DoxyCodeLine{04111\ \textcolor{comment}{//\ Returns\ the\ description\ for\ a\ matcher\ defined\ using\ the\ MATCHER*()}}
\DoxyCodeLine{04112\ \textcolor{comment}{//\ macro\ where\ the\ user-\/supplied\ description\ string\ is\ "{}"{},\ if}}
\DoxyCodeLine{04113\ \textcolor{comment}{//\ 'negation'\ is\ false;\ otherwise\ returns\ the\ description\ of\ the}}
\DoxyCodeLine{04114\ \textcolor{comment}{//\ negation\ of\ the\ matcher.\ \ 'param\_values'\ contains\ a\ list\ of\ strings}}
\DoxyCodeLine{04115\ \textcolor{comment}{//\ that\ are\ the\ print-\/out\ of\ the\ matcher's\ parameters.}}
\DoxyCodeLine{04116\ GTEST\_API\_\ std::string\ FormatMatcherDescription(}
\DoxyCodeLine{04117\ \ \ \ \ \textcolor{keywordtype}{bool}\ negation,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ matcher\_name,}
\DoxyCodeLine{04118\ \ \ \ \ \textcolor{keyword}{const}\ std::vector<const\ char*>\&\ param\_names,\ \textcolor{keyword}{const}\ Strings\&\ param\_values);}
\DoxyCodeLine{04119\ }
\DoxyCodeLine{04120\ \textcolor{comment}{//\ Overloads\ to\ support\ \`{}OptionalMatcher`\ being\ used\ with\ a\ type\ that\ either}}
\DoxyCodeLine{04121\ \textcolor{comment}{//\ supports\ implicit\ conversion\ to\ bool\ or\ a\ \`{}has\_value()`\ method.}}
\DoxyCodeLine{04122\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Optional>}
\DoxyCodeLine{04123\ \textcolor{keyword}{auto}\ IsOptionalEngaged(\textcolor{keyword}{const}\ Optional\&\ optional,\ Rank1)}
\DoxyCodeLine{04124\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(!!optional)\ \{}
\DoxyCodeLine{04125\ \ \ \textcolor{comment}{//\ The\ use\ of\ double-\/negation\ here\ is\ to\ preserve\ historical\ behavior\ where}}
\DoxyCodeLine{04126\ \ \ \textcolor{comment}{//\ the\ matcher\ used\ \`{}operator!`\ rather\ than\ directly\ using\ \`{}operator\ bool`.}}
\DoxyCodeLine{04127\ \ \ \textcolor{keywordflow}{return}\ !\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(!optional);}
\DoxyCodeLine{04128\ \}}
\DoxyCodeLine{04129\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Optional>}
\DoxyCodeLine{04130\ \textcolor{keyword}{auto}\ IsOptionalEngaged(\textcolor{keyword}{const}\ Optional\&\ optional,\ Rank0)}
\DoxyCodeLine{04131\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(!optional.has\_value())\ \{}
\DoxyCodeLine{04132\ \ \ \textcolor{keywordflow}{return}\ optional.has\_value();}
\DoxyCodeLine{04133\ \}}
\DoxyCodeLine{04134\ }
\DoxyCodeLine{04135\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ value\ of\ a\ optional<>\ type\ variable.}}
\DoxyCodeLine{04136\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ValueMatcher>}
\DoxyCodeLine{04137\ \textcolor{keyword}{class\ }OptionalMatcher\ \{}
\DoxyCodeLine{04138\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04139\ \ \ \textcolor{keyword}{explicit}\ OptionalMatcher(\textcolor{keyword}{const}\ ValueMatcher\&\ value\_matcher)}
\DoxyCodeLine{04140\ \ \ \ \ \ \ :\ value\_matcher\_(value\_matcher)\ \{\}}
\DoxyCodeLine{04141\ }
\DoxyCodeLine{04142\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Optional>}
\DoxyCodeLine{04143\ \ \ \textcolor{keyword}{operator}\ Matcher<Optional>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04144\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Optional>(\textcolor{keyword}{new}\ Impl<const\ Optional\&>(value\_matcher\_));}
\DoxyCodeLine{04145\ \ \ \}}
\DoxyCodeLine{04146\ }
\DoxyCodeLine{04147\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Optional>}
\DoxyCodeLine{04148\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Optional>\ \{}
\DoxyCodeLine{04149\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04150\ \ \ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Optional)\ OptionalView;}
\DoxyCodeLine{04151\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ OptionalView::value\_type\ ValueType;}
\DoxyCodeLine{04152\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ ValueMatcher\&\ value\_matcher)}
\DoxyCodeLine{04153\ \ \ \ \ \ \ \ \ :\ value\_matcher\_(MatcherCast<ValueType>(value\_matcher))\ \{\}}
\DoxyCodeLine{04154\ }
\DoxyCodeLine{04155\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04156\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}value\ "{}};}
\DoxyCodeLine{04157\ \ \ \ \ \ \ value\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{04158\ \ \ \ \ \}}
\DoxyCodeLine{04159\ }
\DoxyCodeLine{04160\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04161\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}value\ "{}};}
\DoxyCodeLine{04162\ \ \ \ \ \ \ value\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{04163\ \ \ \ \ \}}
\DoxyCodeLine{04164\ }
\DoxyCodeLine{04165\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Optional\ optional,}
\DoxyCodeLine{04166\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04167\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!IsOptionalEngaged(optional,\ HighestRank()))\ \{}
\DoxyCodeLine{04168\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ not\ engaged"{}};}
\DoxyCodeLine{04169\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{04170\ \ \ \ \ \ \ \}}
\DoxyCodeLine{04171\ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueType\&\ value\ =\ *optional;}
\DoxyCodeLine{04172\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{04173\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Fast\ path\ to\ avoid\ unnecessary\ generation\ of\ match\ explanation.}}
\DoxyCodeLine{04174\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ value\_matcher\_.Matches(value);}
\DoxyCodeLine{04175\ \ \ \ \ \ \ \}}
\DoxyCodeLine{04176\ \ \ \ \ \ \ StringMatchResultListener\ value\_listener;}
\DoxyCodeLine{04177\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ value\_matcher\_.MatchAndExplain(value,\ \&value\_listener);}
\DoxyCodeLine{04178\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ "{}}\ <<\ PrintToString(value)}
\DoxyCodeLine{04179\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (match\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{04180\ \ \ \ \ \ \ PrintIfNotEmpty(value\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{04181\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{04182\ \ \ \ \ \}}
\DoxyCodeLine{04183\ }
\DoxyCodeLine{04184\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04185\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<ValueType>\ value\_matcher\_;}
\DoxyCodeLine{04186\ \ \ \};}
\DoxyCodeLine{04187\ }
\DoxyCodeLine{04188\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04189\ \ \ \textcolor{keyword}{const}\ ValueMatcher\ value\_matcher\_;}
\DoxyCodeLine{04190\ \};}
\DoxyCodeLine{04191\ }
\DoxyCodeLine{04192\ \textcolor{keyword}{namespace\ }variant\_matcher\ \{}
\DoxyCodeLine{04193\ \textcolor{comment}{//\ Overloads\ to\ allow\ VariantMatcher\ to\ do\ proper\ ADL\ lookup.}}
\DoxyCodeLine{04194\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04195\ \textcolor{keywordtype}{void}\ holds\_alternative()\ \{\}}
\DoxyCodeLine{04196\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04197\ \textcolor{keywordtype}{void}\ get()\ \{\}}
\DoxyCodeLine{04198\ }
\DoxyCodeLine{04199\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ value\ of\ a\ variant<>\ type\ variable.}}
\DoxyCodeLine{04200\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04201\ \textcolor{keyword}{class\ }VariantMatcher\ \{}
\DoxyCodeLine{04202\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04203\ \ \ \textcolor{keyword}{explicit}\ VariantMatcher(\mbox{\hyperlink{classtesting_1_1Matcher}{::testing::Matcher<const\ T\&>}}\ matcher)}
\DoxyCodeLine{04204\ \ \ \ \ \ \ :\ matcher\_(std::move(matcher))\ \{\}}
\DoxyCodeLine{04205\ }
\DoxyCodeLine{04206\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Variant>}
\DoxyCodeLine{04207\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Variant\&\ value,}
\DoxyCodeLine{04208\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04209\ \ \ \ \ \textcolor{keyword}{using\ }std::get;}
\DoxyCodeLine{04210\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{04211\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ holds\_alternative<T>(value)\ \&\&\ matcher\_.Matches(get<T>(value));}
\DoxyCodeLine{04212\ \ \ \ \ \}}
\DoxyCodeLine{04213\ }
\DoxyCodeLine{04214\ \ \ \ \ \textcolor{keywordflow}{if}\ (!holds\_alternative<T>(value))\ \{}
\DoxyCodeLine{04215\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ is\ not\ of\ type\ '"{}}\ <<\ GetTypeName()\ <<\ \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{04216\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{04217\ \ \ \ \ \}}
\DoxyCodeLine{04218\ }
\DoxyCodeLine{04219\ \ \ \ \ \textcolor{keyword}{const}\ T\&\ elem\ =\ get<T>(value);}
\DoxyCodeLine{04220\ \ \ \ \ StringMatchResultListener\ elem\_listener;}
\DoxyCodeLine{04221\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher\_.MatchAndExplain(elem,\ \&elem\_listener);}
\DoxyCodeLine{04222\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ "{}}\ <<\ PrintToString(elem)}
\DoxyCodeLine{04223\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (match\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{04224\ \ \ \ \ PrintIfNotEmpty(elem\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{04225\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{04226\ \ \ \}}
\DoxyCodeLine{04227\ }
\DoxyCodeLine{04228\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04229\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ a\ variant<>\ with\ value\ of\ type\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{04230\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ and\ the\ value\ "{}};}
\DoxyCodeLine{04231\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{04232\ \ \ \}}
\DoxyCodeLine{04233\ }
\DoxyCodeLine{04234\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04235\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ a\ variant<>\ with\ value\ of\ type\ other\ than\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{04236\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ or\ the\ value\ "{}};}
\DoxyCodeLine{04237\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{04238\ \ \ \}}
\DoxyCodeLine{04239\ }
\DoxyCodeLine{04240\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04241\ \ \ \textcolor{keyword}{static}\ std::string\ GetTypeName()\ \{}
\DoxyCodeLine{04242\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04243\ \ \ \ \ GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(}
\DoxyCodeLine{04244\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ internal::GetTypeName<T>());}
\DoxyCodeLine{04245\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04246\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}the\ element\ type"{}};}
\DoxyCodeLine{04247\ \ \ \}}
\DoxyCodeLine{04248\ }
\DoxyCodeLine{04249\ \ \ const\ ::testing::Matcher<const\ T\&>\ matcher\_;}
\DoxyCodeLine{04250\ \};}
\DoxyCodeLine{04251\ }
\DoxyCodeLine{04252\ \}\ \ \textcolor{comment}{//\ namespace\ variant\_matcher}}
\DoxyCodeLine{04253\ }
\DoxyCodeLine{04254\ \textcolor{keyword}{namespace\ }any\_cast\_matcher\ \{}
\DoxyCodeLine{04255\ }
\DoxyCodeLine{04256\ \textcolor{comment}{//\ Overloads\ to\ allow\ AnyCastMatcher\ to\ do\ proper\ ADL\ lookup.}}
\DoxyCodeLine{04257\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04258\ \textcolor{keywordtype}{void}\ any\_cast()\ \{\}}
\DoxyCodeLine{04259\ }
\DoxyCodeLine{04260\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ any\_casts\ the\ value.}}
\DoxyCodeLine{04261\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04262\ \textcolor{keyword}{class\ }AnyCastMatcher\ \{}
\DoxyCodeLine{04263\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04264\ \ \ \textcolor{keyword}{explicit}\ AnyCastMatcher(const\ ::testing::Matcher<const\ T\&>\&\ matcher)}
\DoxyCodeLine{04265\ \ \ \ \ \ \ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{04266\ }
\DoxyCodeLine{04267\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ AnyType>}
\DoxyCodeLine{04268\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ AnyType\&\ value,}
\DoxyCodeLine{04269\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04270\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{04271\ \ \ \ \ \ \ \textcolor{keyword}{const}\ T*\ ptr\ =\ any\_cast<T>(\&value);}
\DoxyCodeLine{04272\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ptr\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ matcher\_.Matches(*ptr);}
\DoxyCodeLine{04273\ \ \ \ \ \}}
\DoxyCodeLine{04274\ }
\DoxyCodeLine{04275\ \ \ \ \ \textcolor{keyword}{const}\ T*\ elem\ =\ any\_cast<T>(\&value);}
\DoxyCodeLine{04276\ \ \ \ \ \textcolor{keywordflow}{if}\ (elem\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{04277\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ is\ not\ of\ type\ '"{}}\ <<\ GetTypeName()\ <<\ \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{04278\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{04279\ \ \ \ \ \}}
\DoxyCodeLine{04280\ }
\DoxyCodeLine{04281\ \ \ \ \ StringMatchResultListener\ elem\_listener;}
\DoxyCodeLine{04282\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher\_.MatchAndExplain(*elem,\ \&elem\_listener);}
\DoxyCodeLine{04283\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ "{}}\ <<\ PrintToString(*elem)}
\DoxyCodeLine{04284\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (match\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{04285\ \ \ \ \ PrintIfNotEmpty(elem\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{04286\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{04287\ \ \ \}}
\DoxyCodeLine{04288\ }
\DoxyCodeLine{04289\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04290\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ 'any'\ type\ with\ value\ of\ type\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{04291\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ and\ the\ value\ "{}};}
\DoxyCodeLine{04292\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{04293\ \ \ \}}
\DoxyCodeLine{04294\ }
\DoxyCodeLine{04295\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04296\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ 'any'\ type\ with\ value\ of\ type\ other\ than\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{04297\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ or\ the\ value\ "{}};}
\DoxyCodeLine{04298\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{04299\ \ \ \}}
\DoxyCodeLine{04300\ }
\DoxyCodeLine{04301\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04302\ \ \ \textcolor{keyword}{static}\ std::string\ GetTypeName()\ \{}
\DoxyCodeLine{04303\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04304\ \ \ \ \ GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(}
\DoxyCodeLine{04305\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ internal::GetTypeName<T>());}
\DoxyCodeLine{04306\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04307\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}the\ element\ type"{}};}
\DoxyCodeLine{04308\ \ \ \}}
\DoxyCodeLine{04309\ }
\DoxyCodeLine{04310\ \ \ const\ ::testing::Matcher<const\ T\&>\ matcher\_;}
\DoxyCodeLine{04311\ \};}
\DoxyCodeLine{04312\ }
\DoxyCodeLine{04313\ \}\ \ \textcolor{comment}{//\ namespace\ any\_cast\_matcher}}
\DoxyCodeLine{04314\ }
\DoxyCodeLine{04315\ \textcolor{comment}{//\ Implements\ the\ Args()\ matcher.}}
\DoxyCodeLine{04316\ \textcolor{keyword}{template}\ <\textcolor{keyword}{class\ }ArgsTuple,\ \textcolor{keywordtype}{size\_t}...\ k>}
\DoxyCodeLine{04317\ \textcolor{keyword}{class\ }ArgsMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<ArgsTuple>\ \{}
\DoxyCodeLine{04318\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04319\ \ \ \textcolor{keyword}{using\ }RawArgsTuple\ =\ \textcolor{keyword}{typename}\ std::decay<ArgsTuple>::type;}
\DoxyCodeLine{04320\ \ \ \textcolor{keyword}{using\ }SelectedArgs\ =}
\DoxyCodeLine{04321\ \ \ \ \ \ \ std::tuple<typename\ std::tuple\_element<k,\ RawArgsTuple>::type...>;}
\DoxyCodeLine{04322\ \ \ \textcolor{keyword}{using\ }MonomorphicInnerMatcher\ =\ Matcher<const\ SelectedArgs\&>;}
\DoxyCodeLine{04323\ }
\DoxyCodeLine{04324\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04325\ \ \ \textcolor{keyword}{explicit}\ ArgsMatcherImpl(\textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)}
\DoxyCodeLine{04326\ \ \ \ \ \ \ :\ inner\_matcher\_(SafeMatcherCast<const\ SelectedArgs\&>(inner\_matcher))\ \{\}}
\DoxyCodeLine{04327\ }
\DoxyCodeLine{04328\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(ArgsTuple\ args,}
\DoxyCodeLine{04329\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04330\ \ \ \ \ \textcolor{comment}{//\ Workaround\ spurious\ C4100\ on\ MSVC<=15.7\ when\ k\ is\ empty.}}
\DoxyCodeLine{04331\ \ \ \ \ (void)args;}
\DoxyCodeLine{04332\ \ \ \ \ \textcolor{keyword}{const}\ SelectedArgs\&\ selected\_args\ =}
\DoxyCodeLine{04333\ \ \ \ \ \ \ \ \ std::forward\_as\_tuple(std::get<k>(args)...);}
\DoxyCodeLine{04334\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \textcolor{keywordflow}{return}\ inner\_matcher\_.Matches(selected\_args);}
\DoxyCodeLine{04335\ }
\DoxyCodeLine{04336\ \ \ \ \ PrintIndices(listener-\/>stream());}
\DoxyCodeLine{04337\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}are\ "{}}\ <<\ PrintToString(selected\_args);}
\DoxyCodeLine{04338\ }
\DoxyCodeLine{04339\ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{04340\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =}
\DoxyCodeLine{04341\ \ \ \ \ \ \ \ \ inner\_matcher\_.MatchAndExplain(selected\_args,\ \&inner\_listener);}
\DoxyCodeLine{04342\ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{04343\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{04344\ \ \ \}}
\DoxyCodeLine{04345\ }
\DoxyCodeLine{04346\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04347\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ a\ tuple\ "{}};}
\DoxyCodeLine{04348\ \ \ \ \ PrintIndices(os);}
\DoxyCodeLine{04349\ \ \ \ \ inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{04350\ \ \ \}}
\DoxyCodeLine{04351\ }
\DoxyCodeLine{04352\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04353\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ a\ tuple\ "{}};}
\DoxyCodeLine{04354\ \ \ \ \ PrintIndices(os);}
\DoxyCodeLine{04355\ \ \ \ \ inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{04356\ \ \ \}}
\DoxyCodeLine{04357\ }
\DoxyCodeLine{04358\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04359\ \ \ \textcolor{comment}{//\ Prints\ the\ indices\ of\ the\ selected\ fields.}}
\DoxyCodeLine{04360\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ PrintIndices(::std::ostream*\ os)\ \{}
\DoxyCodeLine{04361\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}whose\ fields\ ("{}};}
\DoxyCodeLine{04362\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ sep\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{04363\ \ \ \ \ \textcolor{comment}{//\ Workaround\ spurious\ C4189\ on\ MSVC<=15.7\ when\ k\ is\ empty.}}
\DoxyCodeLine{04364\ \ \ \ \ (void)sep;}
\DoxyCodeLine{04365\ \ \ \ \ \textcolor{comment}{//\ The\ static\_cast\ to\ void\ is\ needed\ to\ silence\ Clang's\ -\/Wcomma\ warning.}}
\DoxyCodeLine{04366\ \ \ \ \ \textcolor{comment}{//\ This\ pattern\ looks\ suspiciously\ like\ we\ may\ have\ mismatched\ parentheses}}
\DoxyCodeLine{04367\ \ \ \ \ \textcolor{comment}{//\ and\ may\ have\ been\ trying\ to\ use\ the\ first\ operation\ of\ the\ comma\ operator}}
\DoxyCodeLine{04368\ \ \ \ \ \textcolor{comment}{//\ as\ a\ member\ of\ the\ array,\ so\ Clang\ warns\ that\ we\ may\ have\ made\ a\ mistake.}}
\DoxyCodeLine{04369\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ dummy[]\ =\ \{}
\DoxyCodeLine{04370\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}},\ (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(*os\ <<\ sep\ <<\ \textcolor{stringliteral}{"{}\#"{}}\ <<\ k),\ sep\ =\ \textcolor{stringliteral}{"{},\ "{}})...\};}
\DoxyCodeLine{04371\ \ \ \ \ (void)dummy;}
\DoxyCodeLine{04372\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})\ "{}};}
\DoxyCodeLine{04373\ \ \ \}}
\DoxyCodeLine{04374\ }
\DoxyCodeLine{04375\ \ \ MonomorphicInnerMatcher\ inner\_matcher\_;}
\DoxyCodeLine{04376\ \};}
\DoxyCodeLine{04377\ }
\DoxyCodeLine{04378\ \textcolor{keyword}{template}\ <\textcolor{keyword}{class\ }InnerMatcher,\ \textcolor{keywordtype}{size\_t}...\ k>}
\DoxyCodeLine{04379\ \textcolor{keyword}{class\ }ArgsMatcher\ \{}
\DoxyCodeLine{04380\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04381\ \ \ \textcolor{keyword}{explicit}\ ArgsMatcher(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{04382\ \ \ \ \ \ \ :\ inner\_matcher\_(std::move(inner\_matcher))\ \{\}}
\DoxyCodeLine{04383\ }
\DoxyCodeLine{04384\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ArgsTuple>}
\DoxyCodeLine{04385\ \ \ \textcolor{keyword}{operator}\ Matcher<ArgsTuple>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04386\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ ArgsMatcherImpl<ArgsTuple,\ k...>(inner\_matcher\_));}
\DoxyCodeLine{04387\ \ \ \}}
\DoxyCodeLine{04388\ }
\DoxyCodeLine{04389\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04390\ \ \ InnerMatcher\ inner\_matcher\_;}
\DoxyCodeLine{04391\ \};}
\DoxyCodeLine{04392\ }
\DoxyCodeLine{04393\ \}\ \ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{04394\ }
\DoxyCodeLine{04395\ \textcolor{comment}{//\ ElementsAreArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{04396\ \textcolor{comment}{//\ ElementsAreArray(pointer,\ count)}}
\DoxyCodeLine{04397\ \textcolor{comment}{//\ ElementsAreArray(array)}}
\DoxyCodeLine{04398\ \textcolor{comment}{//\ ElementsAreArray(container)}}
\DoxyCodeLine{04399\ \textcolor{comment}{//\ ElementsAreArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{04400\ \textcolor{comment}{//}}
\DoxyCodeLine{04401\ \textcolor{comment}{//\ The\ ElementsAreArray()\ functions\ are\ like\ ElementsAre(...),\ except}}
\DoxyCodeLine{04402\ \textcolor{comment}{//\ that\ they\ are\ given\ a\ homogeneous\ sequence\ rather\ than\ taking\ each}}
\DoxyCodeLine{04403\ \textcolor{comment}{//\ element\ as\ a\ function\ argument.\ The\ sequence\ can\ be\ specified\ as\ an}}
\DoxyCodeLine{04404\ \textcolor{comment}{//\ array,\ a\ pointer\ and\ count,\ a\ vector,\ an\ initializer\ list,\ or\ an}}
\DoxyCodeLine{04405\ \textcolor{comment}{//\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the\ underlying\ sequence}}
\DoxyCodeLine{04406\ \textcolor{comment}{//\ can\ be\ either\ a\ sequence\ of\ values\ or\ a\ sequence\ of\ matchers.}}
\DoxyCodeLine{04407\ \textcolor{comment}{//}}
\DoxyCodeLine{04408\ \textcolor{comment}{//\ All\ forms\ of\ ElementsAreArray()\ make\ a\ copy\ of\ the\ input\ matcher\ sequence.}}
\DoxyCodeLine{04409\ }
\DoxyCodeLine{04410\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04411\ \textcolor{keyword}{inline}\ internal::ElementsAreArrayMatcher<}
\DoxyCodeLine{04412\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{04413\ ElementsAreArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{04414\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{04415\ \ \ \textcolor{keywordflow}{return}\ internal::ElementsAreArrayMatcher<T>(first,\ last);}
\DoxyCodeLine{04416\ \}}
\DoxyCodeLine{04417\ }
\DoxyCodeLine{04418\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04419\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(\textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{04420\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(pointer,\ pointer\ +\ count))\ \{}
\DoxyCodeLine{04421\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{04422\ \}}
\DoxyCodeLine{04423\ }
\DoxyCodeLine{04424\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{04425\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(\textcolor{keyword}{const}\ T\ (\&array)[N])}
\DoxyCodeLine{04426\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(array,\ N))\ \{}
\DoxyCodeLine{04427\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(array,\ N);}
\DoxyCodeLine{04428\ \}}
\DoxyCodeLine{04429\ }
\DoxyCodeLine{04430\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04431\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(\textcolor{keyword}{const}\ Container\&\ container)}
\DoxyCodeLine{04432\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(container.begin(),\ container.end()))\ \{}
\DoxyCodeLine{04433\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(container.begin(),\ container.end());}
\DoxyCodeLine{04434\ \}}
\DoxyCodeLine{04435\ }
\DoxyCodeLine{04436\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04437\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(::std::initializer\_list<T>\ xs)}
\DoxyCodeLine{04438\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(xs.begin(),\ xs.end()))\ \{}
\DoxyCodeLine{04439\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{04440\ \}}
\DoxyCodeLine{04441\ }
\DoxyCodeLine{04442\ \textcolor{comment}{//\ UnorderedElementsAreArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{04443\ \textcolor{comment}{//\ UnorderedElementsAreArray(pointer,\ count)}}
\DoxyCodeLine{04444\ \textcolor{comment}{//\ UnorderedElementsAreArray(array)}}
\DoxyCodeLine{04445\ \textcolor{comment}{//\ UnorderedElementsAreArray(container)}}
\DoxyCodeLine{04446\ \textcolor{comment}{//\ UnorderedElementsAreArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{04447\ \textcolor{comment}{//}}
\DoxyCodeLine{04448\ \textcolor{comment}{//\ UnorderedElementsAreArray()\ verifies\ that\ a\ bijective\ mapping\ onto\ a}}
\DoxyCodeLine{04449\ \textcolor{comment}{//\ collection\ of\ matchers\ exists.}}
\DoxyCodeLine{04450\ \textcolor{comment}{//}}
\DoxyCodeLine{04451\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{04452\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{04453\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{04454\ }
\DoxyCodeLine{04455\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04456\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04457\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{04458\ UnorderedElementsAreArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{04459\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{04460\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{04461\ \ \ \ \ \ \ internal::UnorderedMatcherRequire::ExactMatch,\ first,\ last);}
\DoxyCodeLine{04462\ \}}
\DoxyCodeLine{04463\ }
\DoxyCodeLine{04464\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04465\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ UnorderedElementsAreArray(}
\DoxyCodeLine{04466\ \ \ \ \ \textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{04467\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{04468\ \}}
\DoxyCodeLine{04469\ }
\DoxyCodeLine{04470\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{04471\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ UnorderedElementsAreArray(}
\DoxyCodeLine{04472\ \ \ \ \ \textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{04473\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(array,\ N);}
\DoxyCodeLine{04474\ \}}
\DoxyCodeLine{04475\ }
\DoxyCodeLine{04476\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04477\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04478\ \ \ \ \ \textcolor{keyword}{typename}\ Container::value\_type>}
\DoxyCodeLine{04479\ UnorderedElementsAreArray(\textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{04480\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(container.begin(),\ container.end());}
\DoxyCodeLine{04481\ \}}
\DoxyCodeLine{04482\ }
\DoxyCodeLine{04483\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04484\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ UnorderedElementsAreArray(}
\DoxyCodeLine{04485\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{04486\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{04487\ \}}
\DoxyCodeLine{04488\ }
\DoxyCodeLine{04489\ \textcolor{comment}{//\ \_\ is\ a\ matcher\ that\ matches\ anything\ of\ any\ type.}}
\DoxyCodeLine{04490\ \textcolor{comment}{//}}
\DoxyCodeLine{04491\ \textcolor{comment}{//\ This\ definition\ is\ fine\ as:}}
\DoxyCodeLine{04492\ \textcolor{comment}{//}}
\DoxyCodeLine{04493\ \textcolor{comment}{//\ \ \ 1.\ The\ C++\ standard\ permits\ using\ the\ name\ \_\ in\ a\ namespace\ that}}
\DoxyCodeLine{04494\ \textcolor{comment}{//\ \ \ \ \ \ is\ not\ the\ global\ namespace\ or\ ::std.}}
\DoxyCodeLine{04495\ \textcolor{comment}{//\ \ \ 2.\ The\ AnythingMatcher\ class\ has\ no\ data\ member\ or\ constructor,}}
\DoxyCodeLine{04496\ \textcolor{comment}{//\ \ \ \ \ \ so\ it's\ OK\ to\ create\ global\ variables\ of\ this\ type.}}
\DoxyCodeLine{04497\ \textcolor{comment}{//\ \ \ 3.\ c-\/style\ has\ approved\ of\ using\ \_\ in\ this\ case.}}
\DoxyCodeLine{04498\ \textcolor{keyword}{const}\ internal::AnythingMatcher\ \_\ =\ \{\};}
\DoxyCodeLine{04499\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ value\ of\ the\ given\ type\ T.}}
\DoxyCodeLine{04500\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04501\ \textcolor{keyword}{inline}\ Matcher<T>\ A()\ \{}
\DoxyCodeLine{04502\ \ \ \textcolor{keywordflow}{return}\ \_;}
\DoxyCodeLine{04503\ \}}
\DoxyCodeLine{04504\ }
\DoxyCodeLine{04505\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ value\ of\ the\ given\ type\ T.}}
\DoxyCodeLine{04506\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04507\ \textcolor{keyword}{inline}\ Matcher<T>\ An()\ \{}
\DoxyCodeLine{04508\ \ \ \textcolor{keywordflow}{return}\ \_;}
\DoxyCodeLine{04509\ \}}
\DoxyCodeLine{04510\ }
\DoxyCodeLine{04511\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ NULL\ pointer.}}
\DoxyCodeLine{04512\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::IsNullMatcher>\ IsNull()\ \{}
\DoxyCodeLine{04513\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::IsNullMatcher());}
\DoxyCodeLine{04514\ \}}
\DoxyCodeLine{04515\ }
\DoxyCodeLine{04516\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ non-\/NULL\ pointer.}}
\DoxyCodeLine{04517\ \textcolor{comment}{//\ This\ is\ convenient\ as\ Not(NULL)\ doesn't\ compile\ (the\ compiler}}
\DoxyCodeLine{04518\ \textcolor{comment}{//\ thinks\ that\ that\ expression\ is\ comparing\ a\ pointer\ with\ an\ integer).}}
\DoxyCodeLine{04519\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::NotNullMatcher>\ NotNull()\ \{}
\DoxyCodeLine{04520\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::NotNullMatcher());}
\DoxyCodeLine{04521\ \}}
\DoxyCodeLine{04522\ }
\DoxyCodeLine{04523\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ argument\ that}}
\DoxyCodeLine{04524\ \textcolor{comment}{//\ references\ variable\ x.}}
\DoxyCodeLine{04525\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04526\ \textcolor{keyword}{inline}\ internal::RefMatcher<T\&>\ Ref(T\&\ x)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04527\ \ \ \textcolor{keywordflow}{return}\ internal::RefMatcher<T\&>(x);}
\DoxyCodeLine{04528\ \}}
\DoxyCodeLine{04529\ }
\DoxyCodeLine{04530\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ NaN\ floating\ point.}}
\DoxyCodeLine{04531\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::IsNanMatcher>\ IsNan()\ \{}
\DoxyCodeLine{04532\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::IsNanMatcher());}
\DoxyCodeLine{04533\ \}}
\DoxyCodeLine{04534\ }
\DoxyCodeLine{04535\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately}}
\DoxyCodeLine{04536\ \textcolor{comment}{//\ equal\ to\ rhs,\ where\ two\ NANs\ are\ considered\ unequal.}}
\DoxyCodeLine{04537\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ DoubleEq(\textcolor{keywordtype}{double}\ rhs)\ \{}
\DoxyCodeLine{04538\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{false});}
\DoxyCodeLine{04539\ \}}
\DoxyCodeLine{04540\ }
\DoxyCodeLine{04541\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately}}
\DoxyCodeLine{04542\ \textcolor{comment}{//\ equal\ to\ rhs,\ including\ NaN\ values\ when\ rhs\ is\ NaN.}}
\DoxyCodeLine{04543\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ NanSensitiveDoubleEq(\textcolor{keywordtype}{double}\ rhs)\ \{}
\DoxyCodeLine{04544\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04545\ \}}
\DoxyCodeLine{04546\ }
\DoxyCodeLine{04547\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04548\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ where\ two\ NANs\ are}}
\DoxyCodeLine{04549\ \textcolor{comment}{//\ considered\ unequal.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04550\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ DoubleNear(\textcolor{keywordtype}{double}\ rhs,}
\DoxyCodeLine{04551\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04552\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{false},\ max\_abs\_error);}
\DoxyCodeLine{04553\ \}}
\DoxyCodeLine{04554\ }
\DoxyCodeLine{04555\ \textcolor{comment}{//\ The\ DistanceFrom(target,\ get\_distance,\ m)\ and\ DistanceFrom(target,\ m)}}
\DoxyCodeLine{04556\ \textcolor{comment}{//\ matchers\ work\ on\ arbitrary\ types\ that\ have\ the\ "{}distance"{}\ concept.\ What\ they}}
\DoxyCodeLine{04557\ \textcolor{comment}{//\ do:}}
\DoxyCodeLine{04558\ \textcolor{comment}{//}}
\DoxyCodeLine{04559\ \textcolor{comment}{//\ 1.\ compute\ the\ distance\ between\ the\ value\ and\ the\ target\ using}}
\DoxyCodeLine{04560\ \textcolor{comment}{//\ \ \ \ get\_distance(value,\ target)\ if\ get\_distance\ is\ provided;\ otherwise\ compute}}
\DoxyCodeLine{04561\ \textcolor{comment}{//\ \ \ \ the\ distance\ as\ abs(value\ -\/\ target).}}
\DoxyCodeLine{04562\ \textcolor{comment}{//\ 2.\ match\ the\ distance\ against\ the\ user-\/provided\ matcher\ m;\ if\ the\ match}}
\DoxyCodeLine{04563\ \textcolor{comment}{//\ \ \ \ succeeds,\ the\ DistanceFrom()\ match\ succeeds.}}
\DoxyCodeLine{04564\ \textcolor{comment}{//}}
\DoxyCodeLine{04565\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{04566\ \textcolor{comment}{//}}
\DoxyCodeLine{04567\ \textcolor{comment}{//\ \ \ //\ 0.5's\ distance\ from\ 0.6\ should\ be\ <=\ 0.2.}}
\DoxyCodeLine{04568\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(0.5,\ DistanceFrom(0.6,\ Le(0.2)));}}
\DoxyCodeLine{04569\ \textcolor{comment}{//}}
\DoxyCodeLine{04570\ \textcolor{comment}{//\ \ \ Vector2D\ v1(3.0,\ 4.0),\ v2(3.2,\ 6.0);}}
\DoxyCodeLine{04571\ \textcolor{comment}{//\ \ \ //\ v1's\ distance\ from\ v2,\ as\ computed\ by\ EuclideanDistance(v1,\ v2),}}
\DoxyCodeLine{04572\ \textcolor{comment}{//\ \ \ //\ should\ be\ >=\ 1.0.}}
\DoxyCodeLine{04573\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(v1,\ DistanceFrom(v2,\ EuclideanDistance,\ Ge(1.0)));}}
\DoxyCodeLine{04574\ }
\DoxyCodeLine{04575\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ GetDistance,\ \textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{04576\ \textcolor{keyword}{inline}\ internal::DistanceFromMatcher<T,\ GetDistance,\ DistanceMatcher>}
\DoxyCodeLine{04577\ DistanceFrom(T\ target,\ GetDistance\ get\_distance,}
\DoxyCodeLine{04578\ \ \ \ \ \ \ \ \ \ \ \ \ \ DistanceMatcher\ distance\_matcher)\ \{}
\DoxyCodeLine{04579\ \ \ \textcolor{keywordflow}{return}\ internal::DistanceFromMatcher<T,\ GetDistance,\ DistanceMatcher>(}
\DoxyCodeLine{04580\ \ \ \ \ \ \ std::move(target),\ std::move(get\_distance),\ std::move(distance\_matcher));}
\DoxyCodeLine{04581\ \}}
\DoxyCodeLine{04582\ }
\DoxyCodeLine{04583\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{04584\ \textcolor{keyword}{inline}\ internal::DistanceFromMatcher<T,\ internal::DefaultGetDistance,}
\DoxyCodeLine{04585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ DistanceMatcher>}
\DoxyCodeLine{04586\ DistanceFrom(T\ target,\ DistanceMatcher\ distance\_matcher)\ \{}
\DoxyCodeLine{04587\ \ \ \textcolor{keywordflow}{return}\ DistanceFrom(std::move(target),\ internal::DefaultGetDistance(),}
\DoxyCodeLine{04588\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(distance\_matcher));}
\DoxyCodeLine{04589\ \}}
\DoxyCodeLine{04590\ }
\DoxyCodeLine{04591\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04592\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ including\ NaN\ values\ when}}
\DoxyCodeLine{04593\ \textcolor{comment}{//\ rhs\ is\ NaN.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04594\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ NanSensitiveDoubleNear(}
\DoxyCodeLine{04595\ \ \ \ \ \textcolor{keywordtype}{double}\ rhs,\ \textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04596\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{true},\ max\_abs\_error);}
\DoxyCodeLine{04597\ \}}
\DoxyCodeLine{04598\ }
\DoxyCodeLine{04599\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately}}
\DoxyCodeLine{04600\ \textcolor{comment}{//\ equal\ to\ rhs,\ where\ two\ NANs\ are\ considered\ unequal.}}
\DoxyCodeLine{04601\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ FloatEq(\textcolor{keywordtype}{float}\ rhs)\ \{}
\DoxyCodeLine{04602\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{false});}
\DoxyCodeLine{04603\ \}}
\DoxyCodeLine{04604\ }
\DoxyCodeLine{04605\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately}}
\DoxyCodeLine{04606\ \textcolor{comment}{//\ equal\ to\ rhs,\ including\ NaN\ values\ when\ rhs\ is\ NaN.}}
\DoxyCodeLine{04607\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ NanSensitiveFloatEq(\textcolor{keywordtype}{float}\ rhs)\ \{}
\DoxyCodeLine{04608\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04609\ \}}
\DoxyCodeLine{04610\ }
\DoxyCodeLine{04611\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04612\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ where\ two\ NANs\ are}}
\DoxyCodeLine{04613\ \textcolor{comment}{//\ considered\ unequal.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04614\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ FloatNear(\textcolor{keywordtype}{float}\ rhs,}
\DoxyCodeLine{04615\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04616\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{false},\ max\_abs\_error);}
\DoxyCodeLine{04617\ \}}
\DoxyCodeLine{04618\ }
\DoxyCodeLine{04619\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04620\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ including\ NaN\ values\ when}}
\DoxyCodeLine{04621\ \textcolor{comment}{//\ rhs\ is\ NaN.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04622\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ NanSensitiveFloatNear(}
\DoxyCodeLine{04623\ \ \ \ \ \textcolor{keywordtype}{float}\ rhs,\ \textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04624\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{true},\ max\_abs\_error);}
\DoxyCodeLine{04625\ \}}
\DoxyCodeLine{04626\ }
\DoxyCodeLine{04627\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ a\ pointer\ (raw\ or\ smart)\ that\ points}}
\DoxyCodeLine{04628\ \textcolor{comment}{//\ to\ a\ value\ that\ matches\ inner\_matcher.}}
\DoxyCodeLine{04629\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04630\ \textcolor{keyword}{inline}\ internal::PointeeMatcher<InnerMatcher>\ Pointee(}
\DoxyCodeLine{04631\ \ \ \ \ \textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)\ \{}
\DoxyCodeLine{04632\ \ \ \textcolor{keywordflow}{return}\ internal::PointeeMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{04633\ \}}
\DoxyCodeLine{04634\ }
\DoxyCodeLine{04635\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04636\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ a\ pointer\ or\ reference\ that\ matches}}
\DoxyCodeLine{04637\ \textcolor{comment}{//\ inner\_matcher\ when\ dynamic\_cast<To>\ is\ applied.}}
\DoxyCodeLine{04638\ \textcolor{comment}{//\ The\ result\ of\ dynamic\_cast<To>\ is\ forwarded\ to\ the\ inner\ matcher.}}
\DoxyCodeLine{04639\ \textcolor{comment}{//\ If\ To\ is\ a\ pointer\ and\ the\ cast\ fails,\ the\ inner\ matcher\ will\ receive\ NULL.}}
\DoxyCodeLine{04640\ \textcolor{comment}{//\ If\ To\ is\ a\ reference\ and\ the\ cast\ fails,\ this\ matcher\ returns\ false}}
\DoxyCodeLine{04641\ \textcolor{comment}{//\ immediately.}}
\DoxyCodeLine{04642\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{04643\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To>>}
\DoxyCodeLine{04644\ WhenDynamicCastTo(\textcolor{keyword}{const}\ Matcher<To>\&\ inner\_matcher)\ \{}
\DoxyCodeLine{04645\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04646\ \ \ \ \ \ \ internal::WhenDynamicCastToMatcher<To>(inner\_matcher));}
\DoxyCodeLine{04647\ \}}
\DoxyCodeLine{04648\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04649\ }
\DoxyCodeLine{04650\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ whose\ given\ field\ matches}}
\DoxyCodeLine{04651\ \textcolor{comment}{//\ 'matcher'.\ \ For\ example,}}
\DoxyCodeLine{04652\ \textcolor{comment}{//\ \ \ Field(\&Foo::number,\ Ge(5))}}
\DoxyCodeLine{04653\ \textcolor{comment}{//\ matches\ a\ Foo\ object\ x\ if\ and\ only\ if\ x.number\ >=\ 5.}}
\DoxyCodeLine{04654\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ FieldType,\ \textcolor{keyword}{typename}\ FieldMatcher>}
\DoxyCodeLine{04655\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::FieldMatcher<Class,\ FieldType>>\ Field(}
\DoxyCodeLine{04656\ \ \ \ \ FieldType\ Class::*\ field,\ const\ FieldMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04657\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::FieldMatcher<Class,\ FieldType>(}
\DoxyCodeLine{04658\ \ \ \ \ \ \ field,\ MatcherCast<const\ FieldType\&>(matcher)));}
\DoxyCodeLine{04659\ \ \ \textcolor{comment}{//\ The\ call\ to\ MatcherCast()\ is\ required\ for\ supporting\ inner}}
\DoxyCodeLine{04660\ \ \ \textcolor{comment}{//\ matchers\ of\ compatible\ types.\ \ For\ example,\ it\ allows}}
\DoxyCodeLine{04661\ \ \ \textcolor{comment}{//\ \ \ Field(\&Foo::bar,\ m)}}
\DoxyCodeLine{04662\ \ \ \textcolor{comment}{//\ to\ compile\ where\ bar\ is\ an\ int32\ and\ m\ is\ a\ matcher\ for\ int64.}}
\DoxyCodeLine{04663\ \}}
\DoxyCodeLine{04664\ }
\DoxyCodeLine{04665\ \textcolor{comment}{//\ Same\ as\ Field()\ but\ also\ takes\ the\ name\ of\ the\ field\ to\ provide\ better\ error}}
\DoxyCodeLine{04666\ \textcolor{comment}{//\ messages.}}
\DoxyCodeLine{04667\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ FieldType,\ \textcolor{keyword}{typename}\ FieldMatcher>}
\DoxyCodeLine{04668\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::FieldMatcher<Class,\ FieldType>>\ Field(}
\DoxyCodeLine{04669\ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ field\_name,\ FieldType\ Class::*\ field,}
\DoxyCodeLine{04670\ \ \ \ \ const\ FieldMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04671\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::FieldMatcher<Class,\ FieldType>(}
\DoxyCodeLine{04672\ \ \ \ \ \ \ field\_name,\ field,\ MatcherCast<const\ FieldType\&>(matcher)));}
\DoxyCodeLine{04673\ \}}
\DoxyCodeLine{04674\ }
\DoxyCodeLine{04675\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ whose\ given\ property}}
\DoxyCodeLine{04676\ \textcolor{comment}{//\ matches\ 'matcher'.\ \ For\ example,}}
\DoxyCodeLine{04677\ \textcolor{comment}{//\ \ \ Property(\&Foo::str,\ StartsWith("{}hi"{}))}}
\DoxyCodeLine{04678\ \textcolor{comment}{//\ matches\ a\ Foo\ object\ x\ if\ and\ only\ if\ x.str()\ starts\ with\ "{}hi"{}.}}
\DoxyCodeLine{04679\ \textcolor{comment}{//}}
\DoxyCodeLine{04680\ \textcolor{comment}{//\ Warning:\ Don't\ use\ \`{}Property()`\ against\ member\ functions\ that\ you\ do\ not}}
\DoxyCodeLine{04681\ \textcolor{comment}{//\ own,\ because\ taking\ addresses\ of\ functions\ is\ fragile\ and\ generally\ not\ part}}
\DoxyCodeLine{04682\ \textcolor{comment}{//\ of\ the\ contract\ of\ the\ function.}}
\DoxyCodeLine{04683\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04684\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04685\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const>>}
\DoxyCodeLine{04686\ Property(PropertyType\ (Class::*property)()\ const,}
\DoxyCodeLine{04687\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04688\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04689\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04690\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const>(}
\DoxyCodeLine{04691\ \ \ \ \ \ \ \ \ \ \ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04692\ \ \ \textcolor{comment}{//\ The\ call\ to\ MatcherCast()\ is\ required\ for\ supporting\ inner}}
\DoxyCodeLine{04693\ \ \ \textcolor{comment}{//\ matchers\ of\ compatible\ types.\ \ For\ example,\ it\ allows}}
\DoxyCodeLine{04694\ \ \ \textcolor{comment}{//\ \ \ Property(\&Foo::bar,\ m)}}
\DoxyCodeLine{04695\ \ \ \textcolor{comment}{//\ to\ compile\ where\ bar()\ returns\ an\ int32\ and\ m\ is\ a\ matcher\ for\ int64.}}
\DoxyCodeLine{04696\ \}}
\DoxyCodeLine{04697\ }
\DoxyCodeLine{04698\ \textcolor{comment}{//\ Same\ as\ Property()\ above,\ but\ also\ takes\ the\ name\ of\ the\ property\ to\ provide}}
\DoxyCodeLine{04699\ \textcolor{comment}{//\ better\ error\ messages.}}
\DoxyCodeLine{04700\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04701\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04702\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const>>}
\DoxyCodeLine{04703\ Property(const\ std::string\&\ property\_name,}
\DoxyCodeLine{04704\ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*property)()\ const,}
\DoxyCodeLine{04705\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04706\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04707\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04708\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const>(}
\DoxyCodeLine{04709\ \ \ \ \ \ \ \ \ \ \ property\_name,\ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04710\ \}}
\DoxyCodeLine{04711\ }
\DoxyCodeLine{04712\ \textcolor{comment}{//\ The\ same\ as\ above\ but\ for\ reference-\/qualified\ member\ functions.}}
\DoxyCodeLine{04713\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04714\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04715\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const\&>>}
\DoxyCodeLine{04716\ Property(PropertyType\ (Class::*property)()\ const\&,}
\DoxyCodeLine{04717\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04718\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04719\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04720\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const\&>(}
\DoxyCodeLine{04721\ \ \ \ \ \ \ \ \ \ \ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04722\ \}}
\DoxyCodeLine{04723\ }
\DoxyCodeLine{04724\ \textcolor{comment}{//\ Three-\/argument\ form\ for\ reference-\/qualified\ member\ functions.}}
\DoxyCodeLine{04725\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04726\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04727\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const\&>>}
\DoxyCodeLine{04728\ Property(const\ std::string\&\ property\_name,}
\DoxyCodeLine{04729\ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*property)()\ const\&,}
\DoxyCodeLine{04730\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04731\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04732\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04733\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const\&>(}
\DoxyCodeLine{04734\ \ \ \ \ \ \ \ \ \ \ property\_name,\ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04735\ \}}
\DoxyCodeLine{04736\ }
\DoxyCodeLine{04737\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ if\ and\ only\ if\ the\ result\ of}}
\DoxyCodeLine{04738\ \textcolor{comment}{//\ applying\ a\ callable\ to\ x\ matches\ 'matcher'.\ For\ example,}}
\DoxyCodeLine{04739\ \textcolor{comment}{//\ \ \ ResultOf(f,\ StartsWith("{}hi"{}))}}
\DoxyCodeLine{04740\ \textcolor{comment}{//\ matches\ a\ Foo\ object\ x\ if\ and\ only\ if\ f(x)\ starts\ with\ "{}hi"{}.}}
\DoxyCodeLine{04741\ \textcolor{comment}{//\ \`{}callable`\ parameter\ can\ be\ a\ function,\ function\ pointer,\ or\ a\ functor.\ It\ is}}
\DoxyCodeLine{04742\ \textcolor{comment}{//\ required\ to\ keep\ no\ state\ affecting\ the\ results\ of\ the\ calls\ on\ it\ and\ make}}
\DoxyCodeLine{04743\ \textcolor{comment}{//\ no\ assumptions\ about\ how\ many\ calls\ will\ be\ made.\ Any\ state\ it\ keeps\ must\ be}}
\DoxyCodeLine{04744\ \textcolor{comment}{//\ protected\ from\ the\ concurrent\ access.}}
\DoxyCodeLine{04745\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Callable,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04746\ internal::ResultOfMatcher<Callable,\ InnerMatcher>\ ResultOf(}
\DoxyCodeLine{04747\ \ \ \ \ Callable\ callable,\ InnerMatcher\ matcher)\ \{}
\DoxyCodeLine{04748\ \ \ \textcolor{keywordflow}{return}\ internal::ResultOfMatcher<Callable,\ InnerMatcher>(std::move(callable),}
\DoxyCodeLine{04749\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(matcher));}
\DoxyCodeLine{04750\ \}}
\DoxyCodeLine{04751\ }
\DoxyCodeLine{04752\ \textcolor{comment}{//\ Same\ as\ ResultOf()\ above,\ but\ also\ takes\ a\ description\ of\ the\ \`{}callable`}}
\DoxyCodeLine{04753\ \textcolor{comment}{//\ result\ to\ provide\ better\ error\ messages.}}
\DoxyCodeLine{04754\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Callable,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04755\ internal::ResultOfMatcher<Callable,\ InnerMatcher>\ ResultOf(}
\DoxyCodeLine{04756\ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ result\_description,\ Callable\ callable,}
\DoxyCodeLine{04757\ \ \ \ \ InnerMatcher\ matcher)\ \{}
\DoxyCodeLine{04758\ \ \ \textcolor{keywordflow}{return}\ internal::ResultOfMatcher<Callable,\ InnerMatcher>(}
\DoxyCodeLine{04759\ \ \ \ \ \ \ result\_description,\ std::move(callable),\ std::move(matcher));}
\DoxyCodeLine{04760\ \}}
\DoxyCodeLine{04761\ }
\DoxyCodeLine{04762\ \textcolor{comment}{//\ String\ matchers.}}
\DoxyCodeLine{04763\ }
\DoxyCodeLine{04764\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str.}}
\DoxyCodeLine{04765\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04766\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>>\ StrEq(}
\DoxyCodeLine{04767\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04768\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04769\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::string>(std::string(str),\ \textcolor{keyword}{true},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04770\ \}}
\DoxyCodeLine{04771\ }
\DoxyCodeLine{04772\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str.}}
\DoxyCodeLine{04773\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04774\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>>\ StrNe(}
\DoxyCodeLine{04775\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04776\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04777\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::string>(std::string(str),\ \textcolor{keyword}{false},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04778\ \}}
\DoxyCodeLine{04779\ }
\DoxyCodeLine{04780\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04781\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04782\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>>\ StrCaseEq(}
\DoxyCodeLine{04783\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04784\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04785\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::string>(std::string(str),\ \textcolor{keyword}{true},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04786\ \}}
\DoxyCodeLine{04787\ }
\DoxyCodeLine{04788\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04789\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04790\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>>\ StrCaseNe(}
\DoxyCodeLine{04791\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04792\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::StrEqualityMatcher<std::string>(}
\DoxyCodeLine{04793\ \ \ \ \ \ \ std::string(str),\ \textcolor{keyword}{false},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04794\ \}}
\DoxyCodeLine{04795\ }
\DoxyCodeLine{04796\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ string,\ std::string,\ or\ C\ string}}
\DoxyCodeLine{04797\ \textcolor{comment}{//\ that\ contains\ the\ given\ substring.}}
\DoxyCodeLine{04798\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04799\ PolymorphicMatcher<internal::HasSubstrMatcher<std::string>>\ HasSubstr(}
\DoxyCodeLine{04800\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ substring)\ \{}
\DoxyCodeLine{04801\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04802\ \ \ \ \ \ \ internal::HasSubstrMatcher<std::string>(std::string(substring)));}
\DoxyCodeLine{04803\ \}}
\DoxyCodeLine{04804\ }
\DoxyCodeLine{04805\ \textcolor{comment}{//\ Matches\ a\ string\ that\ starts\ with\ 'prefix'\ (case-\/sensitive).}}
\DoxyCodeLine{04806\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04807\ PolymorphicMatcher<internal::StartsWithMatcher<std::string>>\ StartsWith(}
\DoxyCodeLine{04808\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ prefix)\ \{}
\DoxyCodeLine{04809\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04810\ \ \ \ \ \ \ internal::StartsWithMatcher<std::string>(std::string(prefix)));}
\DoxyCodeLine{04811\ \}}
\DoxyCodeLine{04812\ }
\DoxyCodeLine{04813\ \textcolor{comment}{//\ Matches\ a\ string\ that\ ends\ with\ 'suffix'\ (case-\/sensitive).}}
\DoxyCodeLine{04814\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04815\ PolymorphicMatcher<internal::EndsWithMatcher<std::string>>\ EndsWith(}
\DoxyCodeLine{04816\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ suffix)\ \{}
\DoxyCodeLine{04817\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04818\ \ \ \ \ \ \ internal::EndsWithMatcher<std::string>(std::string(suffix)));}
\DoxyCodeLine{04819\ \}}
\DoxyCodeLine{04820\ }
\DoxyCodeLine{04821\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{04822\ \textcolor{comment}{//\ Wide\ string\ matchers.}}
\DoxyCodeLine{04823\ }
\DoxyCodeLine{04824\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str.}}
\DoxyCodeLine{04825\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>>\ StrEq(}
\DoxyCodeLine{04826\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04827\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04828\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{true},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04829\ \}}
\DoxyCodeLine{04830\ }
\DoxyCodeLine{04831\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str.}}
\DoxyCodeLine{04832\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>>\ StrNe(}
\DoxyCodeLine{04833\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04834\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04835\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{false},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04836\ \}}
\DoxyCodeLine{04837\ }
\DoxyCodeLine{04838\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04839\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>>\ StrCaseEq(}
\DoxyCodeLine{04840\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04841\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04842\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{true},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04843\ \}}
\DoxyCodeLine{04844\ }
\DoxyCodeLine{04845\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04846\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>>\ StrCaseNe(}
\DoxyCodeLine{04847\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04848\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04849\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{false},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04850\ \}}
\DoxyCodeLine{04851\ }
\DoxyCodeLine{04852\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ ::wstring,\ std::wstring,\ or\ C\ wide\ string}}
\DoxyCodeLine{04853\ \textcolor{comment}{//\ that\ contains\ the\ given\ substring.}}
\DoxyCodeLine{04854\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::HasSubstrMatcher<std::wstring>>\ HasSubstr(}
\DoxyCodeLine{04855\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ substring)\ \{}
\DoxyCodeLine{04856\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04857\ \ \ \ \ \ \ internal::HasSubstrMatcher<std::wstring>(substring));}
\DoxyCodeLine{04858\ \}}
\DoxyCodeLine{04859\ }
\DoxyCodeLine{04860\ \textcolor{comment}{//\ Matches\ a\ string\ that\ starts\ with\ 'prefix'\ (case-\/sensitive).}}
\DoxyCodeLine{04861\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StartsWithMatcher<std::wstring>>\ StartsWith(}
\DoxyCodeLine{04862\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ prefix)\ \{}
\DoxyCodeLine{04863\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04864\ \ \ \ \ \ \ internal::StartsWithMatcher<std::wstring>(prefix));}
\DoxyCodeLine{04865\ \}}
\DoxyCodeLine{04866\ }
\DoxyCodeLine{04867\ \textcolor{comment}{//\ Matches\ a\ string\ that\ ends\ with\ 'suffix'\ (case-\/sensitive).}}
\DoxyCodeLine{04868\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::EndsWithMatcher<std::wstring>>\ EndsWith(}
\DoxyCodeLine{04869\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ suffix)\ \{}
\DoxyCodeLine{04870\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04871\ \ \ \ \ \ \ internal::EndsWithMatcher<std::wstring>(suffix));}
\DoxyCodeLine{04872\ \}}
\DoxyCodeLine{04873\ }
\DoxyCodeLine{04874\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{04875\ }
\DoxyCodeLine{04876\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04877\ \textcolor{comment}{//\ first\ field\ ==\ the\ second\ field.}}
\DoxyCodeLine{04878\ \textcolor{keyword}{inline}\ internal::Eq2Matcher\ Eq()\ \{\ \textcolor{keywordflow}{return}\ internal::Eq2Matcher();\ \}}
\DoxyCodeLine{04879\ }
\DoxyCodeLine{04880\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04881\ \textcolor{comment}{//\ first\ field\ >=\ the\ second\ field.}}
\DoxyCodeLine{04882\ \textcolor{keyword}{inline}\ internal::Ge2Matcher\ Ge()\ \{\ \textcolor{keywordflow}{return}\ internal::Ge2Matcher();\ \}}
\DoxyCodeLine{04883\ }
\DoxyCodeLine{04884\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04885\ \textcolor{comment}{//\ first\ field\ >\ the\ second\ field.}}
\DoxyCodeLine{04886\ \textcolor{keyword}{inline}\ internal::Gt2Matcher\ Gt()\ \{\ \textcolor{keywordflow}{return}\ internal::Gt2Matcher();\ \}}
\DoxyCodeLine{04887\ }
\DoxyCodeLine{04888\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04889\ \textcolor{comment}{//\ first\ field\ <=\ the\ second\ field.}}
\DoxyCodeLine{04890\ \textcolor{keyword}{inline}\ internal::Le2Matcher\ Le()\ \{\ \textcolor{keywordflow}{return}\ internal::Le2Matcher();\ \}}
\DoxyCodeLine{04891\ }
\DoxyCodeLine{04892\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04893\ \textcolor{comment}{//\ first\ field\ <\ the\ second\ field.}}
\DoxyCodeLine{04894\ \textcolor{keyword}{inline}\ internal::Lt2Matcher\ Lt()\ \{\ \textcolor{keywordflow}{return}\ internal::Lt2Matcher();\ \}}
\DoxyCodeLine{04895\ }
\DoxyCodeLine{04896\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04897\ \textcolor{comment}{//\ first\ field\ !=\ the\ second\ field.}}
\DoxyCodeLine{04898\ \textcolor{keyword}{inline}\ internal::Ne2Matcher\ Ne()\ \{\ \textcolor{keywordflow}{return}\ internal::Ne2Matcher();\ \}}
\DoxyCodeLine{04899\ }
\DoxyCodeLine{04900\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04901\ \textcolor{comment}{//\ FloatEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04902\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ FloatEq()\ \{}
\DoxyCodeLine{04903\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>();}
\DoxyCodeLine{04904\ \}}
\DoxyCodeLine{04905\ }
\DoxyCodeLine{04906\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04907\ \textcolor{comment}{//\ DoubleEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04908\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ DoubleEq()\ \{}
\DoxyCodeLine{04909\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>();}
\DoxyCodeLine{04910\ \}}
\DoxyCodeLine{04911\ }
\DoxyCodeLine{04912\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04913\ \textcolor{comment}{//\ FloatEq(first\ field)\ matches\ the\ second\ field\ with\ NaN\ equality.}}
\DoxyCodeLine{04914\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ NanSensitiveFloatEq()\ \{}
\DoxyCodeLine{04915\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>(\textcolor{keyword}{true});}
\DoxyCodeLine{04916\ \}}
\DoxyCodeLine{04917\ }
\DoxyCodeLine{04918\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04919\ \textcolor{comment}{//\ DoubleEq(first\ field)\ matches\ the\ second\ field\ with\ NaN\ equality.}}
\DoxyCodeLine{04920\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ NanSensitiveDoubleEq()\ \{}
\DoxyCodeLine{04921\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>(\textcolor{keyword}{true});}
\DoxyCodeLine{04922\ \}}
\DoxyCodeLine{04923\ }
\DoxyCodeLine{04924\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04925\ \textcolor{comment}{//\ FloatNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04926\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ FloatNear(\textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04927\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>(max\_abs\_error);}
\DoxyCodeLine{04928\ \}}
\DoxyCodeLine{04929\ }
\DoxyCodeLine{04930\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04931\ \textcolor{comment}{//\ DoubleNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04932\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ DoubleNear(\textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04933\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>(max\_abs\_error);}
\DoxyCodeLine{04934\ \}}
\DoxyCodeLine{04935\ }
\DoxyCodeLine{04936\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04937\ \textcolor{comment}{//\ FloatNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field\ with\ NaN}}
\DoxyCodeLine{04938\ \textcolor{comment}{//\ equality.}}
\DoxyCodeLine{04939\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ NanSensitiveFloatNear(}
\DoxyCodeLine{04940\ \ \ \ \ \textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04941\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>(max\_abs\_error,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04942\ \}}
\DoxyCodeLine{04943\ }
\DoxyCodeLine{04944\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04945\ \textcolor{comment}{//\ DoubleNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field\ with\ NaN}}
\DoxyCodeLine{04946\ \textcolor{comment}{//\ equality.}}
\DoxyCodeLine{04947\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ NanSensitiveDoubleNear(}
\DoxyCodeLine{04948\ \ \ \ \ \textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04949\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>(max\_abs\_error,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04950\ \}}
\DoxyCodeLine{04951\ }
\DoxyCodeLine{04952\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ value\ of\ type\ T\ that\ m\ doesn't}}
\DoxyCodeLine{04953\ \textcolor{comment}{//\ match.}}
\DoxyCodeLine{04954\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04955\ \textcolor{keyword}{inline}\ internal::NotMatcher<InnerMatcher>\ Not(InnerMatcher\ m)\ \{}
\DoxyCodeLine{04956\ \ \ \textcolor{keywordflow}{return}\ internal::NotMatcher<InnerMatcher>(m);}
\DoxyCodeLine{04957\ \}}
\DoxyCodeLine{04958\ }
\DoxyCodeLine{04959\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ anything\ that\ satisfies\ the\ given}}
\DoxyCodeLine{04960\ \textcolor{comment}{//\ predicate.\ \ The\ predicate\ can\ be\ any\ unary\ function\ or\ functor}}
\DoxyCodeLine{04961\ \textcolor{comment}{//\ whose\ return\ type\ can\ be\ implicitly\ converted\ to\ bool.}}
\DoxyCodeLine{04962\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Predicate>}
\DoxyCodeLine{04963\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::TrulyMatcher<Predicate>>\ Truly(}
\DoxyCodeLine{04964\ \ \ \ \ Predicate\ pred)\ \{}
\DoxyCodeLine{04965\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));}
\DoxyCodeLine{04966\ \}}
\DoxyCodeLine{04967\ }
\DoxyCodeLine{04968\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ container\ size.\ The\ container\ must}}
\DoxyCodeLine{04969\ \textcolor{comment}{//\ support\ both\ size()\ and\ size\_type\ which\ all\ STL-\/like\ containers\ provide.}}
\DoxyCodeLine{04970\ \textcolor{comment}{//\ Note\ that\ the\ parameter\ 'size'\ can\ be\ a\ value\ of\ type\ size\_type\ as\ well\ as}}
\DoxyCodeLine{04971\ \textcolor{comment}{//\ matcher.\ For\ instance:}}
\DoxyCodeLine{04972\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(container,\ SizeIs(2));\ \ \ \ \ //\ Checks\ container\ has\ 2\ elements.}}
\DoxyCodeLine{04973\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(container,\ SizeIs(Le(2));\ \ //\ Checks\ container\ has\ at\ most\ 2.}}
\DoxyCodeLine{04974\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ SizeMatcher>}
\DoxyCodeLine{04975\ \textcolor{keyword}{inline}\ internal::SizeIsMatcher<SizeMatcher>\ SizeIs(}
\DoxyCodeLine{04976\ \ \ \ \ \textcolor{keyword}{const}\ SizeMatcher\&\ size\_matcher)\ \{}
\DoxyCodeLine{04977\ \ \ \textcolor{keywordflow}{return}\ internal::SizeIsMatcher<SizeMatcher>(size\_matcher);}
\DoxyCodeLine{04978\ \}}
\DoxyCodeLine{04979\ }
\DoxyCodeLine{04980\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ distance\ between\ the\ container's\ begin()}}
\DoxyCodeLine{04981\ \textcolor{comment}{//\ iterator\ and\ its\ end()\ iterator,\ i.e.\ the\ size\ of\ the\ container.\ This\ matcher}}
\DoxyCodeLine{04982\ \textcolor{comment}{//\ can\ be\ used\ instead\ of\ SizeIs\ with\ containers\ such\ as\ std::forward\_list\ which}}
\DoxyCodeLine{04983\ \textcolor{comment}{//\ do\ not\ implement\ size().\ The\ container\ must\ provide\ const\_iterator\ (with}}
\DoxyCodeLine{04984\ \textcolor{comment}{//\ valid\ iterator\_traits),\ begin()\ and\ end().}}
\DoxyCodeLine{04985\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{04986\ \textcolor{keyword}{inline}\ internal::BeginEndDistanceIsMatcher<DistanceMatcher>\ BeginEndDistanceIs(}
\DoxyCodeLine{04987\ \ \ \ \ \textcolor{keyword}{const}\ DistanceMatcher\&\ distance\_matcher)\ \{}
\DoxyCodeLine{04988\ \ \ \textcolor{keywordflow}{return}\ internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance\_matcher);}
\DoxyCodeLine{04989\ \}}
\DoxyCodeLine{04990\ }
\DoxyCodeLine{04991\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ an\ equal\ container.}}
\DoxyCodeLine{04992\ \textcolor{comment}{//\ This\ matcher\ behaves\ like\ Eq(),\ but\ in\ the\ event\ of\ mismatch\ lists\ the}}
\DoxyCodeLine{04993\ \textcolor{comment}{//\ values\ that\ are\ included\ in\ one\ container\ but\ not\ the\ other.\ (Duplicate}}
\DoxyCodeLine{04994\ \textcolor{comment}{//\ values\ and\ order\ differences\ are\ not\ explained.)}}
\DoxyCodeLine{04995\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04996\ \textcolor{keyword}{inline}\ PolymorphicMatcher<}
\DoxyCodeLine{04997\ \ \ \ \ internal::ContainerEqMatcher<typename\ std::remove\_const<Container>::type>>}
\DoxyCodeLine{04998\ ContainerEq(\textcolor{keyword}{const}\ Container\&\ rhs)\ \{}
\DoxyCodeLine{04999\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::ContainerEqMatcher<Container>(rhs));}
\DoxyCodeLine{05000\ \}}
\DoxyCodeLine{05001\ }
\DoxyCodeLine{05002\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ a\ container\ that,\ when\ sorted\ using}}
\DoxyCodeLine{05003\ \textcolor{comment}{//\ the\ given\ comparator,\ matches\ container\_matcher.}}
\DoxyCodeLine{05004\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Comparator,\ \textcolor{keyword}{typename}\ ContainerMatcher>}
\DoxyCodeLine{05005\ \textcolor{keyword}{inline}\ internal::WhenSortedByMatcher<Comparator,\ ContainerMatcher>\ WhenSortedBy(}
\DoxyCodeLine{05006\ \ \ \ \ \textcolor{keyword}{const}\ Comparator\&\ comparator,\ \textcolor{keyword}{const}\ ContainerMatcher\&\ container\_matcher)\ \{}
\DoxyCodeLine{05007\ \ \ \textcolor{keywordflow}{return}\ internal::WhenSortedByMatcher<Comparator,\ ContainerMatcher>(}
\DoxyCodeLine{05008\ \ \ \ \ \ \ comparator,\ container\_matcher);}
\DoxyCodeLine{05009\ \}}
\DoxyCodeLine{05010\ }
\DoxyCodeLine{05011\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ a\ container\ that,\ when\ sorted\ using}}
\DoxyCodeLine{05012\ \textcolor{comment}{//\ the\ <\ operator,\ matches\ container\_matcher.}}
\DoxyCodeLine{05013\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ContainerMatcher>}
\DoxyCodeLine{05014\ \textcolor{keyword}{inline}\ internal::WhenSortedByMatcher<internal::LessComparator,\ ContainerMatcher>}
\DoxyCodeLine{05015\ WhenSorted(\textcolor{keyword}{const}\ ContainerMatcher\&\ container\_matcher)\ \{}
\DoxyCodeLine{05016\ \ \ \textcolor{keywordflow}{return}\ internal::WhenSortedByMatcher<internal::LessComparator,}
\DoxyCodeLine{05017\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ContainerMatcher>(}
\DoxyCodeLine{05018\ \ \ \ \ \ \ internal::LessComparator(),\ container\_matcher);}
\DoxyCodeLine{05019\ \}}
\DoxyCodeLine{05020\ }
\DoxyCodeLine{05021\ \textcolor{comment}{//\ Matches\ an\ STL-\/style\ container\ or\ a\ native\ array\ that\ contains\ the}}
\DoxyCodeLine{05022\ \textcolor{comment}{//\ same\ number\ of\ elements\ as\ in\ rhs,\ where\ its\ i-\/th\ element\ and\ rhs's}}
\DoxyCodeLine{05023\ \textcolor{comment}{//\ i-\/th\ element\ (as\ a\ pair)\ satisfy\ the\ given\ pair\ matcher,\ for\ all\ i.}}
\DoxyCodeLine{05024\ \textcolor{comment}{//\ TupleMatcher\ must\ be\ able\ to\ be\ safely\ cast\ to\ Matcher<std::tuple<const}}
\DoxyCodeLine{05025\ \textcolor{comment}{//\ T1\&,\ const\ T2\&>\ >,\ where\ T1\ and\ T2\ are\ the\ types\ of\ elements\ in\ the}}
\DoxyCodeLine{05026\ \textcolor{comment}{//\ LHS\ container\ and\ the\ RHS\ container\ respectively.}}
\DoxyCodeLine{05027\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TupleMatcher,\ \textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05028\ \textcolor{keyword}{inline}\ internal::PointwiseMatcher<TupleMatcher,}
\DoxyCodeLine{05029\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<Container>::type>}
\DoxyCodeLine{05030\ Pointwise(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ \textcolor{keyword}{const}\ Container\&\ rhs)\ \{}
\DoxyCodeLine{05031\ \ \ \textcolor{keywordflow}{return}\ internal::PointwiseMatcher<TupleMatcher,\ Container>(tuple\_matcher,}
\DoxyCodeLine{05032\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rhs);}
\DoxyCodeLine{05033\ \}}
\DoxyCodeLine{05034\ }
\DoxyCodeLine{05035\ \textcolor{comment}{//\ Supports\ the\ Pointwise(m,\ \{a,\ b,\ c\})\ syntax.}}
\DoxyCodeLine{05036\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TupleMatcher,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05037\ \textcolor{keyword}{inline}\ internal::PointwiseMatcher<TupleMatcher,}
\DoxyCodeLine{05038\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<std::remove\_const\_t<T>>>}
\DoxyCodeLine{05039\ Pointwise(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ std::initializer\_list<T>\ rhs)\ \{}
\DoxyCodeLine{05040\ \ \ \textcolor{keywordflow}{return}\ Pointwise(tuple\_matcher,\ std::vector<std::remove\_const\_t<T>>(rhs));}
\DoxyCodeLine{05041\ \}}
\DoxyCodeLine{05042\ }
\DoxyCodeLine{05043\ \textcolor{comment}{//\ UnorderedPointwise(pair\_matcher,\ rhs)\ matches\ an\ STL-\/style}}
\DoxyCodeLine{05044\ \textcolor{comment}{//\ container\ or\ a\ native\ array\ that\ contains\ the\ same\ number\ of}}
\DoxyCodeLine{05045\ \textcolor{comment}{//\ elements\ as\ in\ rhs,\ where\ in\ some\ permutation\ of\ the\ container,\ its}}
\DoxyCodeLine{05046\ \textcolor{comment}{//\ i-\/th\ element\ and\ rhs's\ i-\/th\ element\ (as\ a\ pair)\ satisfy\ the\ given}}
\DoxyCodeLine{05047\ \textcolor{comment}{//\ pair\ matcher,\ for\ all\ i.\ \ Tuple2Matcher\ must\ be\ able\ to\ be\ safely}}
\DoxyCodeLine{05048\ \textcolor{comment}{//\ cast\ to\ Matcher<std::tuple<const\ T1\&,\ const\ T2\&>\ >,\ where\ T1\ and\ T2\ are}}
\DoxyCodeLine{05049\ \textcolor{comment}{//\ the\ types\ of\ elements\ in\ the\ LHS\ container\ and\ the\ RHS\ container}}
\DoxyCodeLine{05050\ \textcolor{comment}{//\ respectively.}}
\DoxyCodeLine{05051\ \textcolor{comment}{//}}
\DoxyCodeLine{05052\ \textcolor{comment}{//\ This\ is\ like\ Pointwise(pair\_matcher,\ rhs),\ except\ that\ the\ element}}
\DoxyCodeLine{05053\ \textcolor{comment}{//\ order\ doesn't\ matter.}}
\DoxyCodeLine{05054\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ RhsContainer>}
\DoxyCodeLine{05055\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{05056\ \ \ \ \ \textcolor{keyword}{typename}\ internal::BoundSecondMatcher<}
\DoxyCodeLine{05057\ \ \ \ \ \ \ \ \ Tuple2Matcher,}
\DoxyCodeLine{05058\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ internal::StlContainerView<}
\DoxyCodeLine{05059\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<RhsContainer>::type>::type::value\_type>>}
\DoxyCodeLine{05060\ UnorderedPointwise(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tuple2\_matcher,}
\DoxyCodeLine{05061\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ RhsContainer\&\ rhs\_container)\ \{}
\DoxyCodeLine{05062\ \ \ \textcolor{comment}{//\ RhsView\ allows\ the\ same\ code\ to\ handle\ RhsContainer\ being\ a}}
\DoxyCodeLine{05063\ \ \ \textcolor{comment}{//\ STL-\/style\ container\ and\ it\ being\ a\ native\ C-\/style\ array.}}
\DoxyCodeLine{05064\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ internal::StlContainerView<RhsContainer>\ RhsView;}
\DoxyCodeLine{05065\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsView::type\ RhsStlContainer;}
\DoxyCodeLine{05066\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsStlContainer::value\_type\ Second;}
\DoxyCodeLine{05067\ \ \ \textcolor{keyword}{const}\ RhsStlContainer\&\ rhs\_stl\_container\ =}
\DoxyCodeLine{05068\ \ \ \ \ \ \ RhsView::ConstReference(rhs\_container);}
\DoxyCodeLine{05069\ }
\DoxyCodeLine{05070\ \ \ \textcolor{comment}{//\ Create\ a\ matcher\ for\ each\ element\ in\ rhs\_container.}}
\DoxyCodeLine{05071\ \ \ ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher,\ Second>>\ matchers;}
\DoxyCodeLine{05072\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ rhs\_stl\_container.begin();\ it\ !=\ rhs\_stl\_container.end();}
\DoxyCodeLine{05073\ \ \ \ \ \ \ \ ++it)\ \{}
\DoxyCodeLine{05074\ \ \ \ \ matchers.push\_back(internal::MatcherBindSecond(tuple2\_matcher,\ *it));}
\DoxyCodeLine{05075\ \ \ \}}
\DoxyCodeLine{05076\ }
\DoxyCodeLine{05077\ \ \ \textcolor{comment}{//\ Delegate\ the\ work\ to\ UnorderedElementsAreArray().}}
\DoxyCodeLine{05078\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(matchers);}
\DoxyCodeLine{05079\ \}}
\DoxyCodeLine{05080\ }
\DoxyCodeLine{05081\ \textcolor{comment}{//\ Supports\ the\ UnorderedPointwise(m,\ \{a,\ b,\ c\})\ syntax.}}
\DoxyCodeLine{05082\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05083\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{05084\ \ \ \ \ \textcolor{keyword}{typename}\ internal::BoundSecondMatcher<Tuple2Matcher,\ T>>}
\DoxyCodeLine{05085\ UnorderedPointwise(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tuple2\_matcher,}
\DoxyCodeLine{05086\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::initializer\_list<T>\ rhs)\ \{}
\DoxyCodeLine{05087\ \ \ \textcolor{keywordflow}{return}\ UnorderedPointwise(tuple2\_matcher,\ std::vector<T>(rhs));}
\DoxyCodeLine{05088\ \}}
\DoxyCodeLine{05089\ }
\DoxyCodeLine{05090\ \textcolor{comment}{//\ Matches\ an\ STL-\/style\ container\ or\ a\ native\ array\ that\ contains\ at}}
\DoxyCodeLine{05091\ \textcolor{comment}{//\ least\ one\ element\ matching\ the\ given\ value\ or\ matcher.}}
\DoxyCodeLine{05092\ \textcolor{comment}{//}}
\DoxyCodeLine{05093\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{05094\ \textcolor{comment}{//\ \ \ ::std::set<int>\ page\_ids;}}
\DoxyCodeLine{05095\ \textcolor{comment}{//\ \ \ page\_ids.insert(3);}}
\DoxyCodeLine{05096\ \textcolor{comment}{//\ \ \ page\_ids.insert(1);}}
\DoxyCodeLine{05097\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Contains(1));}}
\DoxyCodeLine{05098\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Contains(Gt(2)));}}
\DoxyCodeLine{05099\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Not(Contains(4)));\ \ //\ See\ below\ for\ Times(0)}}
\DoxyCodeLine{05100\ \textcolor{comment}{//}}
\DoxyCodeLine{05101\ \textcolor{comment}{//\ \ \ ::std::map<int,\ size\_t>\ page\_lengths;}}
\DoxyCodeLine{05102\ \textcolor{comment}{//\ \ \ page\_lengths[1]\ =\ 100;}}
\DoxyCodeLine{05103\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_lengths,}}
\DoxyCodeLine{05104\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Contains(::std::pair<const\ int,\ size\_t>(1,\ 100)));}}
\DoxyCodeLine{05105\ \textcolor{comment}{//}}
\DoxyCodeLine{05106\ \textcolor{comment}{//\ \ \ const\ char*\ user\_ids[]\ =\ \{\ "{}joe"{},\ "{}mike"{},\ "{}tom"{}\ \};}}
\DoxyCodeLine{05107\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(user\_ids,\ Contains(Eq(::std::string("{}tom"{}))));}}
\DoxyCodeLine{05108\ \textcolor{comment}{//}}
\DoxyCodeLine{05109\ \textcolor{comment}{//\ The\ matcher\ supports\ a\ modifier\ \`{}Times`\ that\ allows\ to\ check\ for\ arbitrary}}
\DoxyCodeLine{05110\ \textcolor{comment}{//\ occurrences\ including\ testing\ for\ absence\ with\ Times(0).}}
\DoxyCodeLine{05111\ \textcolor{comment}{//}}
\DoxyCodeLine{05112\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{05113\ \textcolor{comment}{//\ \ \ ::std::vector<int>\ ids;}}
\DoxyCodeLine{05114\ \textcolor{comment}{//\ \ \ ids.insert(1);}}
\DoxyCodeLine{05115\ \textcolor{comment}{//\ \ \ ids.insert(1);}}
\DoxyCodeLine{05116\ \textcolor{comment}{//\ \ \ ids.insert(3);}}
\DoxyCodeLine{05117\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(ids,\ Contains(1).Times(2));\ \ \ \ \ \ //\ 1\ occurs\ 2\ times}}
\DoxyCodeLine{05118\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(ids,\ Contains(2).Times(0));\ \ \ \ \ \ //\ 2\ is\ not\ present}}
\DoxyCodeLine{05119\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(ids,\ Contains(3).Times(Ge(1)));\ \ //\ 3\ occurs\ at\ least\ once}}
\DoxyCodeLine{05120\ }
\DoxyCodeLine{05121\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05122\ \textcolor{keyword}{inline}\ internal::ContainsMatcher<M>\ Contains(M\ matcher)\ \{}
\DoxyCodeLine{05123\ \ \ \textcolor{keywordflow}{return}\ internal::ContainsMatcher<M>(matcher);}
\DoxyCodeLine{05124\ \}}
\DoxyCodeLine{05125\ }
\DoxyCodeLine{05126\ \textcolor{comment}{//\ IsSupersetOf(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{05127\ \textcolor{comment}{//\ IsSupersetOf(pointer,\ count)}}
\DoxyCodeLine{05128\ \textcolor{comment}{//\ IsSupersetOf(array)}}
\DoxyCodeLine{05129\ \textcolor{comment}{//\ IsSupersetOf(container)}}
\DoxyCodeLine{05130\ \textcolor{comment}{//\ IsSupersetOf(\{e1,\ e2,\ ...,\ en\})}}
\DoxyCodeLine{05131\ \textcolor{comment}{//}}
\DoxyCodeLine{05132\ \textcolor{comment}{//\ IsSupersetOf()\ verifies\ that\ a\ surjective\ partial\ mapping\ onto\ a\ collection}}
\DoxyCodeLine{05133\ \textcolor{comment}{//\ of\ matchers\ exists.\ In\ other\ words,\ a\ container\ matches}}
\DoxyCodeLine{05134\ \textcolor{comment}{//\ IsSupersetOf(\{e1,\ ...,\ en\})\ if\ and\ only\ if\ there\ is\ a\ permutation}}
\DoxyCodeLine{05135\ \textcolor{comment}{//\ \{y1,\ ...,\ yn\}\ of\ some\ of\ the\ container's\ elements\ where\ y1\ matches\ e1,}}
\DoxyCodeLine{05136\ \textcolor{comment}{//\ ...,\ and\ yn\ matches\ en.\ Obviously,\ the\ size\ of\ the\ container\ must\ be\ >=\ n}}
\DoxyCodeLine{05137\ \textcolor{comment}{//\ in\ order\ to\ have\ a\ match.\ Examples:}}
\DoxyCodeLine{05138\ \textcolor{comment}{//}}
\DoxyCodeLine{05139\ \textcolor{comment}{//\ -\/\ \{1,\ 2,\ 3\}\ matches\ IsSupersetOf(\{Ge(3),\ Ne(0)\}),\ as\ 3\ matches\ Ge(3)\ and}}
\DoxyCodeLine{05140\ \textcolor{comment}{//\ \ \ 1\ matches\ Ne(0).}}
\DoxyCodeLine{05141\ \textcolor{comment}{//\ -\/\ \{1,\ 2\}\ doesn't\ match\ IsSupersetOf(\{Eq(1),\ Lt(2)\}),\ even\ though\ 1\ matches}}
\DoxyCodeLine{05142\ \textcolor{comment}{//\ \ \ both\ Eq(1)\ and\ Lt(2).\ The\ reason\ is\ that\ different\ matchers\ must\ be\ used}}
\DoxyCodeLine{05143\ \textcolor{comment}{//\ \ \ for\ elements\ in\ different\ slots\ of\ the\ container.}}
\DoxyCodeLine{05144\ \textcolor{comment}{//\ -\/\ \{1,\ 1,\ 2\}\ matches\ IsSupersetOf(\{Eq(1),\ Lt(2)\}),\ as\ (the\ first)\ 1\ matches}}
\DoxyCodeLine{05145\ \textcolor{comment}{//\ \ \ Eq(1)\ and\ (the\ second)\ 1\ matches\ Lt(2).}}
\DoxyCodeLine{05146\ \textcolor{comment}{//\ -\/\ \{1,\ 2,\ 3\}\ matches\ IsSupersetOf(Gt(1),\ Gt(1)),\ as\ 2\ matches\ (the\ first)}}
\DoxyCodeLine{05147\ \textcolor{comment}{//\ \ \ Gt(1)\ and\ 3\ matches\ (the\ second)\ Gt(1).}}
\DoxyCodeLine{05148\ \textcolor{comment}{//}}
\DoxyCodeLine{05149\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{05150\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{05151\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{05152\ }
\DoxyCodeLine{05153\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{05154\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{05155\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{05156\ IsSupersetOf(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{05157\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{05158\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{05159\ \ \ \ \ \ \ internal::UnorderedMatcherRequire::Superset,\ first,\ last);}
\DoxyCodeLine{05160\ \}}
\DoxyCodeLine{05161\ }
\DoxyCodeLine{05162\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05163\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSupersetOf(}
\DoxyCodeLine{05164\ \ \ \ \ \textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{05165\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{05166\ \}}
\DoxyCodeLine{05167\ }
\DoxyCodeLine{05168\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{05169\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSupersetOf(}
\DoxyCodeLine{05170\ \ \ \ \ \textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{05171\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(array,\ N);}
\DoxyCodeLine{05172\ \}}
\DoxyCodeLine{05173\ }
\DoxyCodeLine{05174\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05175\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{05176\ \ \ \ \ \textcolor{keyword}{typename}\ Container::value\_type>}
\DoxyCodeLine{05177\ IsSupersetOf(\textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{05178\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(container.begin(),\ container.end());}
\DoxyCodeLine{05179\ \}}
\DoxyCodeLine{05180\ }
\DoxyCodeLine{05181\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05182\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSupersetOf(}
\DoxyCodeLine{05183\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{05184\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(xs.begin(),\ xs.end());}
\DoxyCodeLine{05185\ \}}
\DoxyCodeLine{05186\ }
\DoxyCodeLine{05187\ \textcolor{comment}{//\ IsSubsetOf(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{05188\ \textcolor{comment}{//\ IsSubsetOf(pointer,\ count)}}
\DoxyCodeLine{05189\ \textcolor{comment}{//\ IsSubsetOf(array)}}
\DoxyCodeLine{05190\ \textcolor{comment}{//\ IsSubsetOf(container)}}
\DoxyCodeLine{05191\ \textcolor{comment}{//\ IsSubsetOf(\{e1,\ e2,\ ...,\ en\})}}
\DoxyCodeLine{05192\ \textcolor{comment}{//}}
\DoxyCodeLine{05193\ \textcolor{comment}{//\ IsSubsetOf()\ verifies\ that\ an\ injective\ mapping\ onto\ a\ collection\ of\ matchers}}
\DoxyCodeLine{05194\ \textcolor{comment}{//\ exists.\ \ In\ other\ words,\ a\ container\ matches\ IsSubsetOf(\{e1,\ ...,\ en\})\ if\ and}}
\DoxyCodeLine{05195\ \textcolor{comment}{//\ only\ if\ there\ is\ a\ subset\ of\ matchers\ \{m1,\ ...,\ mk\}\ which\ would\ match\ the}}
\DoxyCodeLine{05196\ \textcolor{comment}{//\ container\ using\ UnorderedElementsAre.\ \ Obviously,\ the\ size\ of\ the\ container}}
\DoxyCodeLine{05197\ \textcolor{comment}{//\ must\ be\ <=\ n\ in\ order\ to\ have\ a\ match.\ Examples:}}
\DoxyCodeLine{05198\ \textcolor{comment}{//}}
\DoxyCodeLine{05199\ \textcolor{comment}{//\ -\/\ \{1\}\ matches\ IsSubsetOf(\{Gt(0),\ Lt(0)\}),\ as\ 1\ matches\ Gt(0).}}
\DoxyCodeLine{05200\ \textcolor{comment}{//\ -\/\ \{1,\ -\/1\}\ matches\ IsSubsetOf(\{Lt(0),\ Gt(0)\}),\ as\ 1\ matches\ Gt(0)\ and\ -\/1}}
\DoxyCodeLine{05201\ \textcolor{comment}{//\ \ \ matches\ Lt(0).}}
\DoxyCodeLine{05202\ \textcolor{comment}{//\ -\/\ \{1,\ 2\}\ doesn't\ match\ IsSubsetOf(\{Gt(0),\ Lt(0)\}),\ even\ though\ 1\ and\ 2\ both}}
\DoxyCodeLine{05203\ \textcolor{comment}{//\ \ \ match\ Gt(0).\ The\ reason\ is\ that\ different\ matchers\ must\ be\ used\ for}}
\DoxyCodeLine{05204\ \textcolor{comment}{//\ \ \ elements\ in\ different\ slots\ of\ the\ container.}}
\DoxyCodeLine{05205\ \textcolor{comment}{//}}
\DoxyCodeLine{05206\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{05207\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{05208\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{05209\ }
\DoxyCodeLine{05210\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{05211\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{05212\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{05213\ IsSubsetOf(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{05214\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{05215\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{05216\ \ \ \ \ \ \ internal::UnorderedMatcherRequire::Subset,\ first,\ last);}
\DoxyCodeLine{05217\ \}}
\DoxyCodeLine{05218\ }
\DoxyCodeLine{05219\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05220\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSubsetOf(}
\DoxyCodeLine{05221\ \ \ \ \ \textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{05222\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{05223\ \}}
\DoxyCodeLine{05224\ }
\DoxyCodeLine{05225\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{05226\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSubsetOf(}
\DoxyCodeLine{05227\ \ \ \ \ \textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{05228\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(array,\ N);}
\DoxyCodeLine{05229\ \}}
\DoxyCodeLine{05230\ }
\DoxyCodeLine{05231\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05232\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{05233\ \ \ \ \ \textcolor{keyword}{typename}\ Container::value\_type>}
\DoxyCodeLine{05234\ IsSubsetOf(\textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{05235\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(container.begin(),\ container.end());}
\DoxyCodeLine{05236\ \}}
\DoxyCodeLine{05237\ }
\DoxyCodeLine{05238\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05239\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSubsetOf(}
\DoxyCodeLine{05240\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{05241\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(xs.begin(),\ xs.end());}
\DoxyCodeLine{05242\ \}}
\DoxyCodeLine{05243\ }
\DoxyCodeLine{05244\ \textcolor{comment}{//\ Matches\ an\ STL-\/style\ container\ or\ a\ native\ array\ that\ contains\ only}}
\DoxyCodeLine{05245\ \textcolor{comment}{//\ elements\ matching\ the\ given\ value\ or\ matcher.}}
\DoxyCodeLine{05246\ \textcolor{comment}{//}}
\DoxyCodeLine{05247\ \textcolor{comment}{//\ Each(m)\ is\ semantically\ equivalent\ to\ \`{}Not(Contains(Not(m)))`.\ Only}}
\DoxyCodeLine{05248\ \textcolor{comment}{//\ the\ messages\ are\ different.}}
\DoxyCodeLine{05249\ \textcolor{comment}{//}}
\DoxyCodeLine{05250\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{05251\ \textcolor{comment}{//\ \ \ ::std::set<int>\ page\_ids;}}
\DoxyCodeLine{05252\ \textcolor{comment}{//\ \ \ //\ Each(m)\ matches\ an\ empty\ container,\ regardless\ of\ what\ m\ is.}}
\DoxyCodeLine{05253\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Each(Eq(1)));}}
\DoxyCodeLine{05254\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Each(Eq(77)));}}
\DoxyCodeLine{05255\ \textcolor{comment}{//}}
\DoxyCodeLine{05256\ \textcolor{comment}{//\ \ \ page\_ids.insert(3);}}
\DoxyCodeLine{05257\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Each(Gt(0)));}}
\DoxyCodeLine{05258\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Not(Each(Gt(4))));}}
\DoxyCodeLine{05259\ \textcolor{comment}{//\ \ \ page\_ids.insert(1);}}
\DoxyCodeLine{05260\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Not(Each(Lt(2))));}}
\DoxyCodeLine{05261\ \textcolor{comment}{//}}
\DoxyCodeLine{05262\ \textcolor{comment}{//\ \ \ ::std::map<int,\ size\_t>\ page\_lengths;}}
\DoxyCodeLine{05263\ \textcolor{comment}{//\ \ \ page\_lengths[1]\ =\ 100;}}
\DoxyCodeLine{05264\ \textcolor{comment}{//\ \ \ page\_lengths[2]\ =\ 200;}}
\DoxyCodeLine{05265\ \textcolor{comment}{//\ \ \ page\_lengths[3]\ =\ 300;}}
\DoxyCodeLine{05266\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_lengths,\ Not(Each(Pair(1,\ 100))));}}
\DoxyCodeLine{05267\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_lengths,\ Each(Key(Le(3))));}}
\DoxyCodeLine{05268\ \textcolor{comment}{//}}
\DoxyCodeLine{05269\ \textcolor{comment}{//\ \ \ const\ char*\ user\_ids[]\ =\ \{\ "{}joe"{},\ "{}mike"{},\ "{}tom"{}\ \};}}
\DoxyCodeLine{05270\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(user\_ids,\ Not(Each(Eq(::std::string("{}tom"{})))));}}
\DoxyCodeLine{05271\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05272\ \textcolor{keyword}{inline}\ internal::EachMatcher<M>\ Each(M\ matcher)\ \{}
\DoxyCodeLine{05273\ \ \ \textcolor{keywordflow}{return}\ internal::EachMatcher<M>(matcher);}
\DoxyCodeLine{05274\ \}}
\DoxyCodeLine{05275\ }
\DoxyCodeLine{05276\ \textcolor{comment}{//\ Key(inner\_matcher)\ matches\ an\ std::pair\ whose\ 'first'\ field\ matches}}
\DoxyCodeLine{05277\ \textcolor{comment}{//\ inner\_matcher.\ \ For\ example,\ Contains(Key(Ge(5)))\ can\ be\ used\ to\ match\ an}}
\DoxyCodeLine{05278\ \textcolor{comment}{//\ std::map\ that\ contains\ at\ least\ one\ element\ whose\ key\ is\ >=\ 5.}}
\DoxyCodeLine{05279\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05280\ \textcolor{keyword}{inline}\ internal::KeyMatcher<M>\ Key(M\ inner\_matcher)\ \{}
\DoxyCodeLine{05281\ \ \ \textcolor{keywordflow}{return}\ internal::KeyMatcher<M>(inner\_matcher);}
\DoxyCodeLine{05282\ \}}
\DoxyCodeLine{05283\ }
\DoxyCodeLine{05284\ \textcolor{comment}{//\ Pair(first\_matcher,\ second\_matcher)\ matches\ a\ std::pair\ whose\ 'first'\ field}}
\DoxyCodeLine{05285\ \textcolor{comment}{//\ matches\ first\_matcher\ and\ whose\ 'second'\ field\ matches\ second\_matcher.\ \ For}}
\DoxyCodeLine{05286\ \textcolor{comment}{//\ example,\ EXPECT\_THAT(map\_type,\ ElementsAre(Pair(Ge(5),\ "{}foo"{})))\ can\ be\ used}}
\DoxyCodeLine{05287\ \textcolor{comment}{//\ to\ match\ a\ std::map<int,\ string>\ that\ contains\ exactly\ one\ element\ whose\ key}}
\DoxyCodeLine{05288\ \textcolor{comment}{//\ is\ >=\ 5\ and\ whose\ value\ equals\ "{}foo"{}.}}
\DoxyCodeLine{05289\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FirstMatcher,\ \textcolor{keyword}{typename}\ SecondMatcher>}
\DoxyCodeLine{05290\ \textcolor{keyword}{inline}\ internal::PairMatcher<FirstMatcher,\ SecondMatcher>\ Pair(}
\DoxyCodeLine{05291\ \ \ \ \ FirstMatcher\ first\_matcher,\ SecondMatcher\ second\_matcher)\ \{}
\DoxyCodeLine{05292\ \ \ \textcolor{keywordflow}{return}\ internal::PairMatcher<FirstMatcher,\ SecondMatcher>(first\_matcher,}
\DoxyCodeLine{05293\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ second\_matcher);}
\DoxyCodeLine{05294\ \}}
\DoxyCodeLine{05295\ }
\DoxyCodeLine{05296\ \textcolor{keyword}{namespace\ }no\_adl\ \{}
\DoxyCodeLine{05297\ \textcolor{comment}{//\ Conditional()\ creates\ a\ matcher\ that\ conditionally\ uses\ either\ the\ first\ or}}
\DoxyCodeLine{05298\ \textcolor{comment}{//\ second\ matcher\ provided.\ For\ example,\ we\ could\ create\ an\ \`{}equal\ if,\ and\ only}}
\DoxyCodeLine{05299\ \textcolor{comment}{//\ if'\ matcher\ using\ the\ Conditional\ wrapper\ as\ follows:}}
\DoxyCodeLine{05300\ \textcolor{comment}{//}}
\DoxyCodeLine{05301\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(result,\ Conditional(condition,\ Eq(expected),\ Ne(expected)));}}
\DoxyCodeLine{05302\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTrue,\ \textcolor{keyword}{typename}\ MatcherFalse>}
\DoxyCodeLine{05303\ internal::ConditionalMatcher<MatcherTrue,\ MatcherFalse>\ Conditional(}
\DoxyCodeLine{05304\ \ \ \ \ \textcolor{keywordtype}{bool}\ condition,\ MatcherTrue\ matcher\_true,\ MatcherFalse\ matcher\_false)\ \{}
\DoxyCodeLine{05305\ \ \ \textcolor{keywordflow}{return}\ internal::ConditionalMatcher<MatcherTrue,\ MatcherFalse>(}
\DoxyCodeLine{05306\ \ \ \ \ \ \ condition,\ std::move(matcher\_true),\ std::move(matcher\_false));}
\DoxyCodeLine{05307\ \}}
\DoxyCodeLine{05308\ }
\DoxyCodeLine{05309\ \textcolor{comment}{//\ FieldsAre(matchers...)\ matches\ piecewise\ the\ fields\ of\ compatible\ structs.}}
\DoxyCodeLine{05310\ \textcolor{comment}{//\ These\ include\ those\ that\ support\ \`{}get<I>(obj)`,\ and\ when\ structured\ bindings}}
\DoxyCodeLine{05311\ \textcolor{comment}{//\ are\ enabled\ any\ class\ that\ supports\ them.}}
\DoxyCodeLine{05312\ \textcolor{comment}{//\ In\ particular,\ \`{}std::tuple`,\ \`{}std::pair`,\ \`{}std::array`\ and\ aggregate\ types.}}
\DoxyCodeLine{05313\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ M>}
\DoxyCodeLine{05314\ internal::FieldsAreMatcher<typename\ std::decay<M>::type...>\ FieldsAre(}
\DoxyCodeLine{05315\ \ \ \ \ M\&\&...\ matchers)\ \{}
\DoxyCodeLine{05316\ \ \ \textcolor{keywordflow}{return}\ internal::FieldsAreMatcher<typename\ std::decay<M>::type...>(}
\DoxyCodeLine{05317\ \ \ \ \ \ \ std::forward<M>(matchers)...);}
\DoxyCodeLine{05318\ \}}
\DoxyCodeLine{05319\ }
\DoxyCodeLine{05320\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ a\ pointer\ (raw\ or\ smart)\ that\ matches}}
\DoxyCodeLine{05321\ \textcolor{comment}{//\ inner\_matcher.}}
\DoxyCodeLine{05322\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05323\ \textcolor{keyword}{inline}\ internal::PointerMatcher<InnerMatcher>\ Pointer(}
\DoxyCodeLine{05324\ \ \ \ \ \textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)\ \{}
\DoxyCodeLine{05325\ \ \ \textcolor{keywordflow}{return}\ internal::PointerMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{05326\ \}}
\DoxyCodeLine{05327\ }
\DoxyCodeLine{05328\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ that\ has\ an\ address\ that\ matches}}
\DoxyCodeLine{05329\ \textcolor{comment}{//\ inner\_matcher.}}
\DoxyCodeLine{05330\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05331\ \textcolor{keyword}{inline}\ internal::AddressMatcher<InnerMatcher>\ Address(}
\DoxyCodeLine{05332\ \ \ \ \ \textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)\ \{}
\DoxyCodeLine{05333\ \ \ \textcolor{keywordflow}{return}\ internal::AddressMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{05334\ \}}
\DoxyCodeLine{05335\ }
\DoxyCodeLine{05336\ \textcolor{comment}{//\ Matches\ a\ base64\ escaped\ string,\ when\ the\ unescaped\ string\ matches\ the}}
\DoxyCodeLine{05337\ \textcolor{comment}{//\ internal\ matcher.}}
\DoxyCodeLine{05338\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherType>}
\DoxyCodeLine{05339\ internal::WhenBase64UnescapedMatcher\ WhenBase64Unescaped(}
\DoxyCodeLine{05340\ \ \ \ \ \textcolor{keyword}{const}\ MatcherType\&\ internal\_matcher)\ \{}
\DoxyCodeLine{05341\ \ \ \textcolor{keywordflow}{return}\ internal::WhenBase64UnescapedMatcher(internal\_matcher);}
\DoxyCodeLine{05342\ \}}
\DoxyCodeLine{05343\ \}\ \ \textcolor{comment}{//\ namespace\ no\_adl}}
\DoxyCodeLine{05344\ }
\DoxyCodeLine{05345\ \textcolor{comment}{//\ Returns\ a\ predicate\ that\ is\ satisfied\ by\ anything\ that\ matches\ the}}
\DoxyCodeLine{05346\ \textcolor{comment}{//\ given\ matcher.}}
\DoxyCodeLine{05347\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05348\ \textcolor{keyword}{inline}\ internal::MatcherAsPredicate<M>\ Matches(M\ matcher)\ \{}
\DoxyCodeLine{05349\ \ \ \textcolor{keywordflow}{return}\ internal::MatcherAsPredicate<M>(matcher);}
\DoxyCodeLine{05350\ \}}
\DoxyCodeLine{05351\ }
\DoxyCodeLine{05352\ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ the\ value\ matches\ the\ matcher.}}
\DoxyCodeLine{05353\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05354\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ Value(\textcolor{keyword}{const}\ T\&\ value,\ M\ matcher)\ \{}
\DoxyCodeLine{05355\ \ \ \textcolor{keywordflow}{return}\ testing::Matches(matcher)(value);}
\DoxyCodeLine{05356\ \}}
\DoxyCodeLine{05357\ }
\DoxyCodeLine{05358\ \textcolor{comment}{//\ Matches\ the\ value\ against\ the\ given\ matcher\ and\ explains\ the\ match}}
\DoxyCodeLine{05359\ \textcolor{comment}{//\ result\ to\ listener.}}
\DoxyCodeLine{05360\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05361\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ ExplainMatchResult(M\ matcher,\ \textcolor{keyword}{const}\ T\&\ value,}
\DoxyCodeLine{05362\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \{}
\DoxyCodeLine{05363\ \ \ \textcolor{keywordflow}{return}\ SafeMatcherCast<const\ T\&>(matcher).MatchAndExplain(value,\ listener);}
\DoxyCodeLine{05364\ \}}
\DoxyCodeLine{05365\ }
\DoxyCodeLine{05366\ \textcolor{comment}{//\ Returns\ a\ string\ representation\ of\ the\ given\ matcher.\ \ Useful\ for\ description}}
\DoxyCodeLine{05367\ \textcolor{comment}{//\ strings\ of\ matchers\ defined\ using\ MATCHER\_P*\ macros\ that\ accept\ matchers\ as}}
\DoxyCodeLine{05368\ \textcolor{comment}{//\ their\ arguments.\ \ For\ example:}}
\DoxyCodeLine{05369\ \textcolor{comment}{//}}
\DoxyCodeLine{05370\ \textcolor{comment}{//\ MATCHER\_P(XAndYThat,\ matcher,}}
\DoxyCodeLine{05371\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ "{}X\ that\ "{}\ +\ DescribeMatcher<int>(matcher,\ negation)\ +}}
\DoxyCodeLine{05372\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (negation\ ?\ "{}\ or"{}\ :\ "{}\ and"{})\ +\ "{}\ Y\ that\ "{}\ +}}
\DoxyCodeLine{05373\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ DescribeMatcher<double>(matcher,\ negation))\ \{}}
\DoxyCodeLine{05374\ \textcolor{comment}{//\ \ \ return\ ExplainMatchResult(matcher,\ arg.x(),\ result\_listener)\ \&\&}}
\DoxyCodeLine{05375\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ ExplainMatchResult(matcher,\ arg.y(),\ result\_listener);}}
\DoxyCodeLine{05376\ \textcolor{comment}{//\ \}}}
\DoxyCodeLine{05377\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05378\ std::string\ DescribeMatcher(\textcolor{keyword}{const}\ M\&\ matcher,\ \textcolor{keywordtype}{bool}\ negation\ =\ \textcolor{keyword}{false})\ \{}
\DoxyCodeLine{05379\ \ \ ::std::stringstream\ ss;}
\DoxyCodeLine{05380\ \ \ Matcher<T>\ monomorphic\_matcher\ =\ SafeMatcherCast<T>(matcher);}
\DoxyCodeLine{05381\ \ \ \textcolor{keywordflow}{if}\ (negation)\ \{}
\DoxyCodeLine{05382\ \ \ \ \ monomorphic\_matcher.DescribeNegationTo(\&ss);}
\DoxyCodeLine{05383\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{05384\ \ \ \ \ monomorphic\_matcher.DescribeTo(\&ss);}
\DoxyCodeLine{05385\ \ \ \}}
\DoxyCodeLine{05386\ \ \ \textcolor{keywordflow}{return}\ ss.str();}
\DoxyCodeLine{05387\ \}}
\DoxyCodeLine{05388\ }
\DoxyCodeLine{05389\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05390\ internal::ElementsAreMatcher<}
\DoxyCodeLine{05391\ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>}
\DoxyCodeLine{05392\ ElementsAre(\textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05393\ \ \ \textcolor{keywordflow}{return}\ internal::ElementsAreMatcher<}
\DoxyCodeLine{05394\ \ \ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>(}
\DoxyCodeLine{05395\ \ \ \ \ \ \ std::make\_tuple(matchers...));}
\DoxyCodeLine{05396\ \}}
\DoxyCodeLine{05397\ }
\DoxyCodeLine{05398\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05399\ internal::UnorderedElementsAreMatcher<}
\DoxyCodeLine{05400\ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>}
\DoxyCodeLine{05401\ UnorderedElementsAre(\textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05402\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreMatcher<}
\DoxyCodeLine{05403\ \ \ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>(}
\DoxyCodeLine{05404\ \ \ \ \ \ \ std::make\_tuple(matchers...));}
\DoxyCodeLine{05405\ \}}
\DoxyCodeLine{05406\ }
\DoxyCodeLine{05407\ \textcolor{comment}{//\ Define\ variadic\ matcher\ versions.}}
\DoxyCodeLine{05408\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05409\ internal::AllOfMatcher<typename\ std::decay<const\ Args\&>::type...>\ AllOf(}
\DoxyCodeLine{05410\ \ \ \ \ \textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05411\ \ \ \textcolor{keywordflow}{return}\ internal::AllOfMatcher<typename\ std::decay<const\ Args\&>::type...>(}
\DoxyCodeLine{05412\ \ \ \ \ \ \ matchers...);}
\DoxyCodeLine{05413\ \}}
\DoxyCodeLine{05414\ }
\DoxyCodeLine{05415\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05416\ internal::AnyOfMatcher<typename\ std::decay<const\ Args\&>::type...>\ AnyOf(}
\DoxyCodeLine{05417\ \ \ \ \ \textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05418\ \ \ \textcolor{keywordflow}{return}\ internal::AnyOfMatcher<typename\ std::decay<const\ Args\&>::type...>(}
\DoxyCodeLine{05419\ \ \ \ \ \ \ matchers...);}
\DoxyCodeLine{05420\ \}}
\DoxyCodeLine{05421\ }
\DoxyCodeLine{05422\ \textcolor{comment}{//\ AnyOfArray(array)}}
\DoxyCodeLine{05423\ \textcolor{comment}{//\ AnyOfArray(pointer,\ count)}}
\DoxyCodeLine{05424\ \textcolor{comment}{//\ AnyOfArray(container)}}
\DoxyCodeLine{05425\ \textcolor{comment}{//\ AnyOfArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{05426\ \textcolor{comment}{//\ AnyOfArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{05427\ \textcolor{comment}{//}}
\DoxyCodeLine{05428\ \textcolor{comment}{//\ AnyOfArray()\ verifies\ whether\ a\ given\ value\ matches\ any\ member\ of\ a}}
\DoxyCodeLine{05429\ \textcolor{comment}{//\ collection\ of\ matchers.}}
\DoxyCodeLine{05430\ \textcolor{comment}{//}}
\DoxyCodeLine{05431\ \textcolor{comment}{//\ AllOfArray(array)}}
\DoxyCodeLine{05432\ \textcolor{comment}{//\ AllOfArray(pointer,\ count)}}
\DoxyCodeLine{05433\ \textcolor{comment}{//\ AllOfArray(container)}}
\DoxyCodeLine{05434\ \textcolor{comment}{//\ AllOfArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{05435\ \textcolor{comment}{//\ AllOfArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{05436\ \textcolor{comment}{//}}
\DoxyCodeLine{05437\ \textcolor{comment}{//\ AllOfArray()\ verifies\ whether\ a\ given\ value\ matches\ all\ members\ of\ a}}
\DoxyCodeLine{05438\ \textcolor{comment}{//\ collection\ of\ matchers.}}
\DoxyCodeLine{05439\ \textcolor{comment}{//}}
\DoxyCodeLine{05440\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{05441\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{05442\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{05443\ }
\DoxyCodeLine{05444\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{05445\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<}
\DoxyCodeLine{05446\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{05447\ AnyOfArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{05448\ \ \ \textcolor{keywordflow}{return}\ internal::AnyOfArrayMatcher<}
\DoxyCodeLine{05449\ \ \ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>(first,\ last);}
\DoxyCodeLine{05450\ \}}
\DoxyCodeLine{05451\ }
\DoxyCodeLine{05452\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{05453\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<}
\DoxyCodeLine{05454\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{05455\ AllOfArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{05456\ \ \ \textcolor{keywordflow}{return}\ internal::AllOfArrayMatcher<}
\DoxyCodeLine{05457\ \ \ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>(first,\ last);}
\DoxyCodeLine{05458\ \}}
\DoxyCodeLine{05459\ }
\DoxyCodeLine{05460\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05461\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<T>\ AnyOfArray(\textcolor{keyword}{const}\ T*\ ptr,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{05462\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(ptr,\ ptr\ +\ count);}
\DoxyCodeLine{05463\ \}}
\DoxyCodeLine{05464\ }
\DoxyCodeLine{05465\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05466\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<T>\ AllOfArray(\textcolor{keyword}{const}\ T*\ ptr,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{05467\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(ptr,\ ptr\ +\ count);}
\DoxyCodeLine{05468\ \}}
\DoxyCodeLine{05469\ }
\DoxyCodeLine{05470\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{05471\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<T>\ AnyOfArray(\textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{05472\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(array,\ N);}
\DoxyCodeLine{05473\ \}}
\DoxyCodeLine{05474\ }
\DoxyCodeLine{05475\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{05476\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<T>\ AllOfArray(\textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{05477\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(array,\ N);}
\DoxyCodeLine{05478\ \}}
\DoxyCodeLine{05479\ }
\DoxyCodeLine{05480\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05481\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<typename\ Container::value\_type>\ AnyOfArray(}
\DoxyCodeLine{05482\ \ \ \ \ \textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{05483\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(container.begin(),\ container.end());}
\DoxyCodeLine{05484\ \}}
\DoxyCodeLine{05485\ }
\DoxyCodeLine{05486\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05487\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<typename\ Container::value\_type>\ AllOfArray(}
\DoxyCodeLine{05488\ \ \ \ \ \textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{05489\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(container.begin(),\ container.end());}
\DoxyCodeLine{05490\ \}}
\DoxyCodeLine{05491\ }
\DoxyCodeLine{05492\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05493\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<T>\ AnyOfArray(}
\DoxyCodeLine{05494\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{05495\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{05496\ \}}
\DoxyCodeLine{05497\ }
\DoxyCodeLine{05498\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05499\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<T>\ AllOfArray(}
\DoxyCodeLine{05500\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{05501\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{05502\ \}}
\DoxyCodeLine{05503\ }
\DoxyCodeLine{05504\ \textcolor{comment}{//\ Args<N1,\ N2,\ ...,\ Nk>(a\_matcher)\ matches\ a\ tuple\ if\ the\ selected}}
\DoxyCodeLine{05505\ \textcolor{comment}{//\ fields\ of\ it\ matches\ a\_matcher.\ \ C++\ doesn't\ support\ default}}
\DoxyCodeLine{05506\ \textcolor{comment}{//\ arguments\ for\ function\ templates,\ so\ we\ have\ to\ overload\ it.}}
\DoxyCodeLine{05507\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}...\ k,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05508\ internal::ArgsMatcher<typename\ std::decay<InnerMatcher>::type,\ k...>\ Args(}
\DoxyCodeLine{05509\ \ \ \ \ InnerMatcher\&\&\ matcher)\ \{}
\DoxyCodeLine{05510\ \ \ \textcolor{keywordflow}{return}\ internal::ArgsMatcher<typename\ std::decay<InnerMatcher>::type,\ k...>(}
\DoxyCodeLine{05511\ \ \ \ \ \ \ std::forward<InnerMatcher>(matcher));}
\DoxyCodeLine{05512\ \}}
\DoxyCodeLine{05513\ }
\DoxyCodeLine{05514\ \textcolor{comment}{//\ AllArgs(m)\ is\ a\ synonym\ of\ m.\ \ This\ is\ useful\ in}}
\DoxyCodeLine{05515\ \textcolor{comment}{//}}
\DoxyCodeLine{05516\ \textcolor{comment}{//\ \ \ EXPECT\_CALL(foo,\ Bar(\_,\ \_)).With(AllArgs(Eq()));}}
\DoxyCodeLine{05517\ \textcolor{comment}{//}}
\DoxyCodeLine{05518\ \textcolor{comment}{//\ which\ is\ easier\ to\ read\ than}}
\DoxyCodeLine{05519\ \textcolor{comment}{//}}
\DoxyCodeLine{05520\ \textcolor{comment}{//\ \ \ EXPECT\_CALL(foo,\ Bar(\_,\ \_)).With(Eq());}}
\DoxyCodeLine{05521\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05522\ \textcolor{keyword}{inline}\ InnerMatcher\ AllArgs(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)\ \{}
\DoxyCodeLine{05523\ \ \ \textcolor{keywordflow}{return}\ matcher;}
\DoxyCodeLine{05524\ \}}
\DoxyCodeLine{05525\ }
\DoxyCodeLine{05526\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ value\ of\ an\ optional<>\ type\ variable.}}
\DoxyCodeLine{05527\ \textcolor{comment}{//\ The\ matcher\ implementation\ only\ uses\ '!arg'\ (or\ 'arg.has\_value()'\ if\ '!arg`}}
\DoxyCodeLine{05528\ \textcolor{comment}{//\ isn't\ a\ valid\ expression)\ and\ requires\ that\ the\ optional<>\ type\ has\ a}}
\DoxyCodeLine{05529\ \textcolor{comment}{//\ 'value\_type'\ member\ type\ and\ that\ '*arg'\ is\ of\ type\ 'value\_type'\ and\ is}}
\DoxyCodeLine{05530\ \textcolor{comment}{//\ printable\ using\ 'PrintToString'.\ It\ is\ compatible\ with}}
\DoxyCodeLine{05531\ \textcolor{comment}{//\ std::optional/std::experimental::optional.}}
\DoxyCodeLine{05532\ \textcolor{comment}{//\ Note\ that\ to\ compare\ an\ optional\ type\ variable\ against\ nullopt\ you\ should}}
\DoxyCodeLine{05533\ \textcolor{comment}{//\ use\ Eq(nullopt)\ and\ not\ Eq(Optional(nullopt)).\ The\ latter\ implies\ that\ the}}
\DoxyCodeLine{05534\ \textcolor{comment}{//\ optional\ value\ contains\ an\ optional\ itself.}}
\DoxyCodeLine{05535\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ValueMatcher>}
\DoxyCodeLine{05536\ \textcolor{keyword}{inline}\ internal::OptionalMatcher<ValueMatcher>\ Optional(}
\DoxyCodeLine{05537\ \ \ \ \ \textcolor{keyword}{const}\ ValueMatcher\&\ value\_matcher)\ \{}
\DoxyCodeLine{05538\ \ \ \textcolor{keywordflow}{return}\ internal::OptionalMatcher<ValueMatcher>(value\_matcher);}
\DoxyCodeLine{05539\ \}}
\DoxyCodeLine{05540\ }
\DoxyCodeLine{05541\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ value\ of\ a\ absl::any\ type\ variable.}}
\DoxyCodeLine{05542\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05543\ PolymorphicMatcher<internal::any\_cast\_matcher::AnyCastMatcher<T>>\ AnyWith(}
\DoxyCodeLine{05544\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ T\&>\&\ matcher)\ \{}
\DoxyCodeLine{05545\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{05546\ \ \ \ \ \ \ internal::any\_cast\_matcher::AnyCastMatcher<T>(matcher));}
\DoxyCodeLine{05547\ \}}
\DoxyCodeLine{05548\ }
\DoxyCodeLine{05549\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ value\ of\ a\ variant<>\ type\ variable.}}
\DoxyCodeLine{05550\ \textcolor{comment}{//\ The\ matcher\ implementation\ uses\ ADL\ to\ find\ the\ holds\_alternative\ and\ get}}
\DoxyCodeLine{05551\ \textcolor{comment}{//\ functions.}}
\DoxyCodeLine{05552\ \textcolor{comment}{//\ It\ is\ compatible\ with\ std::variant.}}
\DoxyCodeLine{05553\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05554\ PolymorphicMatcher<internal::variant\_matcher::VariantMatcher<T>>\ VariantWith(}
\DoxyCodeLine{05555\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ T\&>\&\ matcher)\ \{}
\DoxyCodeLine{05556\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{05557\ \ \ \ \ \ \ internal::variant\_matcher::VariantMatcher<T>(matcher));}
\DoxyCodeLine{05558\ \}}
\DoxyCodeLine{05559\ }
\DoxyCodeLine{05560\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{05561\ }
\DoxyCodeLine{05562\ \textcolor{comment}{//\ Anything\ inside\ the\ \`{}internal`\ namespace\ is\ internal\ to\ the\ implementation}}
\DoxyCodeLine{05563\ \textcolor{comment}{//\ and\ must\ not\ be\ used\ in\ user\ code!}}
\DoxyCodeLine{05564\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{05565\ }
\DoxyCodeLine{05566\ \textcolor{keyword}{class\ }WithWhatMatcherImpl\ \{}
\DoxyCodeLine{05567\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05568\ \ \ WithWhatMatcherImpl(Matcher<std::string>\ matcher)}
\DoxyCodeLine{05569\ \ \ \ \ \ \ :\ matcher\_(std::move(matcher))\ \{\}}
\DoxyCodeLine{05570\ }
\DoxyCodeLine{05571\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05572\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ .what()\ that\ "{}};}
\DoxyCodeLine{05573\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{05574\ \ \ \}}
\DoxyCodeLine{05575\ }
\DoxyCodeLine{05576\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05577\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ .what()\ that\ does\ not\ "{}};}
\DoxyCodeLine{05578\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{05579\ \ \ \}}
\DoxyCodeLine{05580\ }
\DoxyCodeLine{05581\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err>}
\DoxyCodeLine{05582\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Err\&\ err,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05583\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ contains\ .what()\ (of\ value\ =\ "{}}\ <<\ err.what()}
\DoxyCodeLine{05584\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{})\ that\ "{}};}
\DoxyCodeLine{05585\ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_.MatchAndExplain(err.what(),\ listener);}
\DoxyCodeLine{05586\ \ \ \}}
\DoxyCodeLine{05587\ }
\DoxyCodeLine{05588\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05589\ \ \ \textcolor{keyword}{const}\ Matcher<std::string>\ matcher\_;}
\DoxyCodeLine{05590\ \};}
\DoxyCodeLine{05591\ }
\DoxyCodeLine{05592\ \textcolor{keyword}{inline}\ PolymorphicMatcher<WithWhatMatcherImpl>\ WithWhat(}
\DoxyCodeLine{05593\ \ \ \ \ Matcher<std::string>\ m)\ \{}
\DoxyCodeLine{05594\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(WithWhatMatcherImpl(std::move(m)));}
\DoxyCodeLine{05595\ \}}
\DoxyCodeLine{05596\ }
\DoxyCodeLine{05597\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err>}
\DoxyCodeLine{05598\ \textcolor{keyword}{class\ }ExceptionMatcherImpl\ \{}
\DoxyCodeLine{05599\ \ \ \textcolor{keyword}{class\ }NeverThrown\ \{}
\DoxyCodeLine{05600\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05601\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ what()\ const\ noexcept\ \{}
\DoxyCodeLine{05602\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}this\ exception\ should\ never\ be\ thrown"{}};}
\DoxyCodeLine{05603\ \ \ \ \ \}}
\DoxyCodeLine{05604\ \ \ \};}
\DoxyCodeLine{05605\ }
\DoxyCodeLine{05606\ \ \ \textcolor{comment}{//\ If\ the\ matchee\ raises\ an\ exception\ of\ a\ wrong\ type,\ we'd\ like\ to}}
\DoxyCodeLine{05607\ \ \ \textcolor{comment}{//\ catch\ it\ and\ print\ its\ message\ and\ type.\ To\ do\ that,\ we\ add\ an\ additional}}
\DoxyCodeLine{05608\ \ \ \textcolor{comment}{//\ catch\ clause:}}
\DoxyCodeLine{05609\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05610\ \ \ \textcolor{comment}{//\ \ \ \ \ try\ \{\ ...\ \}}}
\DoxyCodeLine{05611\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ Err\&)\ \{\ /*\ an\ expected\ exception\ */\ \}}}
\DoxyCodeLine{05612\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ exception\ of\ a\ wrong\ type\ */\ \}}}
\DoxyCodeLine{05613\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05614\ \ \ \textcolor{comment}{//\ However,\ if\ the\ \`{}Err`\ itself\ is\ \`{}std::exception`,\ we'd\ end\ up\ with\ two}}
\DoxyCodeLine{05615\ \ \ \textcolor{comment}{//\ identical\ \`{}catch`\ clauses:}}
\DoxyCodeLine{05616\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05617\ \ \ \textcolor{comment}{//\ \ \ \ \ try\ \{\ ...\ \}}}
\DoxyCodeLine{05618\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ an\ expected\ exception\ */\ \}}}
\DoxyCodeLine{05619\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ exception\ of\ a\ wrong\ type\ */\ \}}}
\DoxyCodeLine{05620\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05621\ \ \ \textcolor{comment}{//\ This\ can\ cause\ a\ warning\ or\ an\ error\ in\ some\ compilers.\ To\ resolve}}
\DoxyCodeLine{05622\ \ \ \textcolor{comment}{//\ the\ issue,\ we\ use\ a\ fake\ error\ type\ whenever\ \`{}Err`\ is\ \`{}std::exception`:}}
\DoxyCodeLine{05623\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05624\ \ \ \textcolor{comment}{//\ \ \ \ \ try\ \{\ ...\ \}}}
\DoxyCodeLine{05625\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ an\ expected\ exception\ */\ \}}}
\DoxyCodeLine{05626\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ NeverThrown\&)\ \{\ /*\ exception\ of\ a\ wrong\ type\ */\ \}}}
\DoxyCodeLine{05627\ \ \ \textcolor{keyword}{using\ }DefaultExceptionType\ =\ \textcolor{keyword}{typename}\ std::conditional<}
\DoxyCodeLine{05628\ \ \ \ \ \ \ std::is\_same<\textcolor{keyword}{typename}\ std::remove\_cv<}
\DoxyCodeLine{05629\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_reference<Err>::type>::type,}
\DoxyCodeLine{05630\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::exception>::value,}
\DoxyCodeLine{05631\ \ \ \ \ \ \ \textcolor{keyword}{const}\ NeverThrown\&,\ \textcolor{keyword}{const}\ std::exception\&>::type;}
\DoxyCodeLine{05632\ }
\DoxyCodeLine{05633\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05634\ \ \ ExceptionMatcherImpl(Matcher<const\ Err\&>\ matcher)}
\DoxyCodeLine{05635\ \ \ \ \ \ \ :\ matcher\_(std::move(matcher))\ \{\}}
\DoxyCodeLine{05636\ }
\DoxyCodeLine{05637\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05638\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ which\ is\ a\ "{}}\ <<\ GetTypeName<Err>();}
\DoxyCodeLine{05639\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ which\ "{}};}
\DoxyCodeLine{05640\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{05641\ \ \ \}}
\DoxyCodeLine{05642\ }
\DoxyCodeLine{05643\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05644\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ which\ is\ not\ a\ "{}}\ <<\ GetTypeName<Err>();}
\DoxyCodeLine{05645\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ which\ "{}};}
\DoxyCodeLine{05646\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{05647\ \ \ \}}
\DoxyCodeLine{05648\ }
\DoxyCodeLine{05649\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05650\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\&\&\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05651\ \ \ \ \ \textcolor{keywordflow}{try}\ \{}
\DoxyCodeLine{05652\ \ \ \ \ \ \ (void)(std::forward<T>(x)());}
\DoxyCodeLine{05653\ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (\textcolor{keyword}{const}\ Err\&\ err)\ \{}
\DoxyCodeLine{05654\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ which\ is\ a\ "{}}\ <<\ GetTypeName<Err>();}
\DoxyCodeLine{05655\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{05656\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_.MatchAndExplain(err,\ listener);}
\DoxyCodeLine{05657\ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (DefaultExceptionType\ err)\ \{}
\DoxyCodeLine{05658\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{05659\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ of\ type\ "{}}\ <<\ GetTypeName(\textcolor{keyword}{typeid}(err));}
\DoxyCodeLine{05660\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{05661\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{05662\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ std::exception-\/derived\ type\ "{}};}
\DoxyCodeLine{05663\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05664\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}with\ description\ \(\backslash\)"{}"{}}\ <<\ err.what()\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}};}
\DoxyCodeLine{05665\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{05666\ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (...)\ \{}
\DoxyCodeLine{05667\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ of\ an\ unknown\ type"{}};}
\DoxyCodeLine{05668\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{05669\ \ \ \ \ \}}
\DoxyCodeLine{05670\ }
\DoxyCodeLine{05671\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}does\ not\ throw\ any\ exception"{}};}
\DoxyCodeLine{05672\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{05673\ \ \ \}}
\DoxyCodeLine{05674\ }
\DoxyCodeLine{05675\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05676\ \ \ \textcolor{keyword}{const}\ Matcher<const\ Err\&>\ matcher\_;}
\DoxyCodeLine{05677\ \};}
\DoxyCodeLine{05678\ }
\DoxyCodeLine{05679\ \}\ \ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{05680\ }
\DoxyCodeLine{05681\ \textcolor{comment}{//\ Throws()}}
\DoxyCodeLine{05682\ \textcolor{comment}{//\ Throws(exceptionMatcher)}}
\DoxyCodeLine{05683\ \textcolor{comment}{//\ ThrowsMessage(messageMatcher)}}
\DoxyCodeLine{05684\ \textcolor{comment}{//}}
\DoxyCodeLine{05685\ \textcolor{comment}{//\ This\ matcher\ accepts\ a\ callable\ and\ verifies\ that\ when\ invoked,\ it\ throws}}
\DoxyCodeLine{05686\ \textcolor{comment}{//\ an\ exception\ with\ the\ given\ type\ and\ properties.}}
\DoxyCodeLine{05687\ \textcolor{comment}{//}}
\DoxyCodeLine{05688\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{05689\ \textcolor{comment}{//}}
\DoxyCodeLine{05690\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(}}
\DoxyCodeLine{05691\ \textcolor{comment}{//\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error("{}message"{});\ \},}}
\DoxyCodeLine{05692\ \textcolor{comment}{//\ \ \ \ \ \ \ Throws<std::runtime\_error>());}}
\DoxyCodeLine{05693\ \textcolor{comment}{//}}
\DoxyCodeLine{05694\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(}}
\DoxyCodeLine{05695\ \textcolor{comment}{//\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error("{}message"{});\ \},}}
\DoxyCodeLine{05696\ \textcolor{comment}{//\ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr("{}message"{})));}}
\DoxyCodeLine{05697\ \textcolor{comment}{//}}
\DoxyCodeLine{05698\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(}}
\DoxyCodeLine{05699\ \textcolor{comment}{//\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error("{}message"{});\ \},}}
\DoxyCodeLine{05700\ \textcolor{comment}{//\ \ \ \ \ \ \ Throws<std::runtime\_error>(}}
\DoxyCodeLine{05701\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ Property(\&std::runtime\_error::what,\ HasSubstr("{}message"{}))));}}
\DoxyCodeLine{05702\ }
\DoxyCodeLine{05703\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err>}
\DoxyCodeLine{05704\ PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>\ Throws()\ \{}
\DoxyCodeLine{05705\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{05706\ \ \ \ \ \ \ internal::ExceptionMatcherImpl<Err>(A<const\ Err\&>()));}
\DoxyCodeLine{05707\ \}}
\DoxyCodeLine{05708\ }
\DoxyCodeLine{05709\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err,\ \textcolor{keyword}{typename}\ ExceptionMatcher>}
\DoxyCodeLine{05710\ PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>\ Throws(}
\DoxyCodeLine{05711\ \ \ \ \ \textcolor{keyword}{const}\ ExceptionMatcher\&\ exception\_matcher)\ \{}
\DoxyCodeLine{05712\ \ \ \textcolor{comment}{//\ Using\ matcher\ cast\ allows\ users\ to\ pass\ a\ matcher\ of\ a\ more\ broad\ type.}}
\DoxyCodeLine{05713\ \ \ \textcolor{comment}{//\ For\ example\ user\ may\ want\ to\ pass\ Matcher<std::exception>}}
\DoxyCodeLine{05714\ \ \ \textcolor{comment}{//\ to\ Throws<std::runtime\_error>,\ or\ Matcher<int64>\ to\ Throws<int32>.}}
\DoxyCodeLine{05715\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::ExceptionMatcherImpl<Err>(}
\DoxyCodeLine{05716\ \ \ \ \ \ \ SafeMatcherCast<const\ Err\&>(exception\_matcher)));}
\DoxyCodeLine{05717\ \}}
\DoxyCodeLine{05718\ }
\DoxyCodeLine{05719\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err,\ \textcolor{keyword}{typename}\ MessageMatcher>}
\DoxyCodeLine{05720\ PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>\ ThrowsMessage(}
\DoxyCodeLine{05721\ \ \ \ \ MessageMatcher\&\&\ message\_matcher)\ \{}
\DoxyCodeLine{05722\ \ \ \textcolor{keyword}{static\_assert}(std::is\_base\_of<std::exception,\ Err>::value,}
\DoxyCodeLine{05723\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}expected\ an\ std::exception-\/derived\ type"{}});}
\DoxyCodeLine{05724\ \ \ \textcolor{keywordflow}{return}\ Throws<Err>(internal::WithWhat(}
\DoxyCodeLine{05725\ \ \ \ \ \ \ MatcherCast<std::string>(std::forward<MessageMatcher>(message\_matcher))));}
\DoxyCodeLine{05726\ \}}
\DoxyCodeLine{05727\ }
\DoxyCodeLine{05728\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{05729\ }
\DoxyCodeLine{05730\ \textcolor{comment}{//\ These\ macros\ allow\ using\ matchers\ to\ check\ values\ in\ Google\ Test}}
\DoxyCodeLine{05731\ \textcolor{comment}{//\ tests.\ \ ASSERT\_THAT(value,\ matcher)\ and\ EXPECT\_THAT(value,\ matcher)}}
\DoxyCodeLine{05732\ \textcolor{comment}{//\ succeed\ if\ and\ only\ if\ the\ value\ matches\ the\ matcher.\ \ If\ the\ assertion}}
\DoxyCodeLine{05733\ \textcolor{comment}{//\ fails,\ the\ value\ and\ the\ description\ of\ the\ matcher\ will\ be\ printed.}}
\DoxyCodeLine{05734\ \textcolor{preprocessor}{\#define\ ASSERT\_THAT(value,\ matcher)\ \(\backslash\)}}
\DoxyCodeLine{05735\ \textcolor{preprocessor}{\ \ ASSERT\_PRED\_FORMAT1(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05736\ \textcolor{preprocessor}{\ \ \ \ \ \ ::testing::internal::MakePredicateFormatterFromMatcher(matcher),\ value)}}
\DoxyCodeLine{05737\ \textcolor{preprocessor}{\#define\ EXPECT\_THAT(value,\ matcher)\ \(\backslash\)}}
\DoxyCodeLine{05738\ \textcolor{preprocessor}{\ \ EXPECT\_PRED\_FORMAT1(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05739\ \textcolor{preprocessor}{\ \ \ \ \ \ ::testing::internal::MakePredicateFormatterFromMatcher(matcher),\ value)}}
\DoxyCodeLine{05740\ }
\DoxyCodeLine{05741\ \textcolor{comment}{//\ MATCHER*\ macros\ itself\ are\ listed\ below.}}
\DoxyCodeLine{05742\ \textcolor{preprocessor}{\#define\ MATCHER(name,\ description)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05743\ \textcolor{preprocessor}{\ \ class\ name\#\#Matcher\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05744\ \textcolor{preprocessor}{\ \ \ \ \ \ :\ public\ ::testing::internal::MatcherBaseImpl<name\#\#Matcher>\ \{\ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05745\ \textcolor{preprocessor}{\ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05746\ \textcolor{preprocessor}{\ \ \ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05747\ \textcolor{preprocessor}{\ \ \ \ class\ gmock\_Impl\ :\ public\ ::testing::MatcherInterface<const\ arg\_type\&>\ \{\ \ \(\backslash\)}}
\DoxyCodeLine{05748\ \textcolor{preprocessor}{\ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05749\ \textcolor{preprocessor}{\ \ \ \ \ \ gmock\_Impl()\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05750\ \textcolor{preprocessor}{\ \ \ \ \ \ bool\ MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05751\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05752\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ result\_listener)\ const\ override;\ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05753\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05754\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(false);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05755\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05756\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeNegationTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05757\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(true);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05758\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05759\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05760\ \textcolor{preprocessor}{\ \ \ \ \ private:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05761\ \textcolor{preprocessor}{\ \ \ \ \ \ ::std::string\ FormatDescription(bool\ negation)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05762\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ }\textcolor{comment}{/*\ NOLINTNEXTLINE\ readability-\/redundant-\/string-\/init\ */}\textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05763\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ ::std::string\ gmock\_description\ =\ (description);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05764\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ if\ (!gmock\_description.empty())\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05765\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ return\ gmock\_description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05766\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05767\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ return\ ::testing::internal::FormatMatcherDescription(negation,\ \#name,\ \(\backslash\)}}
\DoxyCodeLine{05768\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\},\ \{\});\ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05769\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05770\ \textcolor{preprocessor}{\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05771\ \textcolor{preprocessor}{\ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05772\ \textcolor{preprocessor}{\ \ inline\ name\#\#Matcher\ GMOCK\_INTERNAL\_WARNING\_PUSH()\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05773\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_WARNING\_CLANG(ignored,\ "{}-\/Wunused-\/function"{})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05774\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ GMOCK\_INTERNAL\_WARNING\_CLANG(ignored,\ "{}-\/Wunused-\/member-\/function"{})\ \ \ \(\backslash\)}}
\DoxyCodeLine{05775\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ name\ GMOCK\_INTERNAL\_WARNING\_POP()()\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05776\ \textcolor{preprocessor}{\ \ \ \ return\ \{\};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05777\ \textcolor{preprocessor}{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05778\ \textcolor{preprocessor}{\ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05779\ \textcolor{preprocessor}{\ \ bool\ name\#\#Matcher::gmock\_Impl<arg\_type>::MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05780\ \textcolor{preprocessor}{\ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05781\ \textcolor{preprocessor}{\ \ \ \ \ \ [[maybe\_unused]]\ ::testing::MatchResultListener*\ result\_listener)\ const}}
\DoxyCodeLine{05782\ }
\DoxyCodeLine{05783\ \textcolor{preprocessor}{\#define\ MATCHER\_P(name,\ p0,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05784\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP,\ description,\ (\#p0),\ (p0))}}
\DoxyCodeLine{05785\ \textcolor{preprocessor}{\#define\ MATCHER\_P2(name,\ p0,\ p1,\ description)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05786\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP2,\ description,\ (\#p0,\ \#p1),\ \(\backslash\)}}
\DoxyCodeLine{05787\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1))}}
\DoxyCodeLine{05788\ \textcolor{preprocessor}{\#define\ MATCHER\_P3(name,\ p0,\ p1,\ p2,\ description)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05789\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP3,\ description,\ (\#p0,\ \#p1,\ \#p2),\ \(\backslash\)}}
\DoxyCodeLine{05790\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2))}}
\DoxyCodeLine{05791\ \textcolor{preprocessor}{\#define\ MATCHER\_P4(name,\ p0,\ p1,\ p2,\ p3,\ description)\ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05792\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP4,\ description,\ \(\backslash\)}}
\DoxyCodeLine{05793\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3),\ (p0,\ p1,\ p2,\ p3))}}
\DoxyCodeLine{05794\ \textcolor{preprocessor}{\#define\ MATCHER\_P5(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ description)\ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05795\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP5,\ description,\ \(\backslash\)}}
\DoxyCodeLine{05796\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3,\ \#p4),\ (p0,\ p1,\ p2,\ p3,\ p4))}}
\DoxyCodeLine{05797\ \textcolor{preprocessor}{\#define\ MATCHER\_P6(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05798\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP6,\ description,\ \ \(\backslash\)}}
\DoxyCodeLine{05799\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3,\ \#p4,\ \#p5),\ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05800\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5))}}
\DoxyCodeLine{05801\ \textcolor{preprocessor}{\#define\ MATCHER\_P7(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05802\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP7,\ description,\ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05803\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3,\ \#p4,\ \#p5,\ \#p6),\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05804\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6))}}
\DoxyCodeLine{05805\ \textcolor{preprocessor}{\#define\ MATCHER\_P8(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05806\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP8,\ description,\ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05807\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3,\ \#p4,\ \#p5,\ \#p6,\ \#p7),\ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05808\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7))}}
\DoxyCodeLine{05809\ \textcolor{preprocessor}{\#define\ MATCHER\_P9(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05810\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP9,\ description,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05811\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3,\ \#p4,\ \#p5,\ \#p6,\ \#p7,\ \#p8),\ \ \ \(\backslash\)}}
\DoxyCodeLine{05812\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8))}}
\DoxyCodeLine{05813\ \textcolor{preprocessor}{\#define\ MATCHER\_P10(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8,\ p9,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05814\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP10,\ description,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05815\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\#p0,\ \#p1,\ \#p2,\ \#p3,\ \#p4,\ \#p5,\ \#p6,\ \#p7,\ \#p8,\ \#p9),\ \ \ \(\backslash\)}}
\DoxyCodeLine{05816\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8,\ p9))}}
\DoxyCodeLine{05817\ }
\DoxyCodeLine{05818\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER(name,\ full\_name,\ description,\ arg\_names,\ args)\ \ \(\backslash\)}}
\DoxyCodeLine{05819\ \textcolor{preprocessor}{\ \ template\ <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05820\ \textcolor{preprocessor}{\ \ class\ full\_name\ :\ public\ ::testing::internal::MatcherBaseImpl<\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05821\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>>\ \{\ \(\backslash\)}}
\DoxyCodeLine{05822\ \textcolor{preprocessor}{\ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05823\ \textcolor{preprocessor}{\ \ \ \ using\ full\_name::MatcherBaseImpl::MatcherBaseImpl;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05824\ \textcolor{preprocessor}{\ \ \ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05825\ \textcolor{preprocessor}{\ \ \ \ class\ gmock\_Impl\ :\ public\ ::testing::MatcherInterface<const\ arg\_type\&>\ \{\ \ \ \(\backslash\)}}
\DoxyCodeLine{05826\ \textcolor{preprocessor}{\ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05827\ \textcolor{preprocessor}{\ \ \ \ \ \ explicit\ gmock\_Impl(GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args))\ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05828\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ :\ GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARGS(args)\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05829\ \textcolor{preprocessor}{\ \ \ \ \ \ bool\ MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05830\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05831\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ result\_listener)\ const\ override;\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05832\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05833\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(false);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05834\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05835\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeNegationTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05836\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(true);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05837\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05838\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_MEMBERS(args)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05839\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05840\ \textcolor{preprocessor}{\ \ \ \ \ private:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05841\ \textcolor{preprocessor}{\ \ \ \ \ \ ::std::string\ FormatDescription(bool\ negation)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05842\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ ::std::string\ gmock\_description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05843\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ gmock\_description\ =\ (description);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05844\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ if\ (!gmock\_description.empty())\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05845\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ return\ gmock\_description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05846\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05847\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ return\ ::testing::internal::FormatMatcherDescription(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05848\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ negation,\ \#name,\ \{GMOCK\_PP\_REMOVE\_PARENS(arg\_names)\},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05849\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05850\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::tuple<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>(\ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05851\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_MEMBERS\_USAGE(args))));\ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05852\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05853\ \textcolor{preprocessor}{\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05854\ \textcolor{preprocessor}{\ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05855\ \textcolor{preprocessor}{\ \ template\ <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05856\ \textcolor{preprocessor}{\ \ inline\ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>\ name(\ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05857\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05858\ \textcolor{preprocessor}{\ \ \ \ return\ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05859\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_ARGS\_USAGE(args));\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05860\ \textcolor{preprocessor}{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05861\ \textcolor{preprocessor}{\ \ template\ <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05862\ \textcolor{preprocessor}{\ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05863\ \textcolor{preprocessor}{\ \ bool\ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>::\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05864\ \textcolor{preprocessor}{\ \ \ \ \ \ gmock\_Impl<arg\_type>::MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05865\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05866\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ [[maybe\_unused]]\ ::testing::MatchResultListener*\ result\_listener)\ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05867\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ const}}
\DoxyCodeLine{05868\ }
\DoxyCodeLine{05869\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)\ \(\backslash\)}}
\DoxyCodeLine{05870\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05871\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAM,\ ,\ args))}}
\DoxyCodeLine{05872\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAM(i\_unused,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05873\ \textcolor{preprocessor}{\ \ ,\ typename\ arg\#\#\_type}}
\DoxyCodeLine{05874\ }
\DoxyCodeLine{05875\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)\ \(\backslash\)}}
\DoxyCodeLine{05876\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAM,\ ,\ args))}}
\DoxyCodeLine{05877\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAM(i\_unused,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05878\ \textcolor{preprocessor}{\ \ ,\ arg\#\#\_type}}
\DoxyCodeLine{05879\ }
\DoxyCodeLine{05880\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args)\ \(\backslash\)}}
\DoxyCodeLine{05881\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(dummy\_first\ GMOCK\_PP\_FOR\_EACH(\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05882\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARG,\ ,\ args))}}
\DoxyCodeLine{05883\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARG(i,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05884\ \textcolor{preprocessor}{\ \ ,\ arg\#\#\_type\ gmock\_p\#\#i}}
\DoxyCodeLine{05885\ }
\DoxyCodeLine{05886\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARGS(args)\ \(\backslash\)}}
\DoxyCodeLine{05887\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARG,\ ,\ args))}}
\DoxyCodeLine{05888\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARG(i,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05889\ \textcolor{preprocessor}{\ \ ,\ arg(::std::forward<arg\#\#\_type>(gmock\_p\#\#i))}}
\DoxyCodeLine{05890\ }
\DoxyCodeLine{05891\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBERS(args)\ \(\backslash\)}}
\DoxyCodeLine{05892\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_MEMBER,\ ,\ args)}}
\DoxyCodeLine{05893\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBER(i\_unused,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05894\ \textcolor{preprocessor}{\ \ const\ arg\#\#\_type\ arg;}}
\DoxyCodeLine{05895\ }
\DoxyCodeLine{05896\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBERS\_USAGE(args)\ \(\backslash\)}}
\DoxyCodeLine{05897\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_MEMBER\_USAGE,\ ,\ args))}}
\DoxyCodeLine{05898\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBER\_USAGE(i\_unused,\ data\_unused,\ arg)\ ,\ arg}}
\DoxyCodeLine{05899\ }
\DoxyCodeLine{05900\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_ARGS\_USAGE(args)\ \(\backslash\)}}
\DoxyCodeLine{05901\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_ARG\_USAGE,\ ,\ args))}}
\DoxyCodeLine{05902\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_ARG\_USAGE(i,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05903\ \textcolor{preprocessor}{\ \ ,\ ::std::forward<arg\#\#\_type>(gmock\_p\#\#i)}}
\DoxyCodeLine{05904\ }
\DoxyCodeLine{05905\ \textcolor{comment}{//\ To\ prevent\ ADL\ on\ certain\ functions\ we\ put\ them\ on\ a\ separate\ namespace.}}
\DoxyCodeLine{05906\ \textcolor{keyword}{using\ namespace\ }no\_adl;\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{05907\ }
\DoxyCodeLine{05908\ \}\ \ \textcolor{comment}{//\ namespace\ testing}}
\DoxyCodeLine{05909\ }
\DoxyCodeLine{05910\ GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_()\ \ \textcolor{comment}{//\ \ 4251\ 5046}}
\DoxyCodeLine{05911\ }
\DoxyCodeLine{05912\ \textcolor{comment}{//\ Include\ any\ custom\ callback\ matchers\ added\ by\ the\ local\ installation.}}
\DoxyCodeLine{05913\ \textcolor{comment}{//\ We\ must\ include\ this\ header\ at\ the\ end\ to\ make\ sure\ it\ can\ use\ the}}
\DoxyCodeLine{05914\ \textcolor{comment}{//\ declarations\ from\ this\ file.}}
\DoxyCodeLine{05915\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/custom/gmock-\/matchers.h"{}}}
\DoxyCodeLine{05916\ }
\DoxyCodeLine{05917\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}

\end{DoxyCode}
